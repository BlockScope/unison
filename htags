!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_NAME	hasktags
(+>)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^(+>) :: Key -> a -> KeyMap a$/;"	ft	signature:(Key -> a -> KeyMap a)	line:129	language:Haskell
(.||.)	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^(.||.) :: (a -> Bool) -> (a -> Bool) -> a -> Bool$/;"	ft	signature:((a -> Bool) -> (a -> Bool) -> a -> Bool)	line:298	language:Haskell
(<$|)	./unison-core/src/Unison/Util/Relation.hs	/^(<$|) :: (Ord a, Ord b) => Set a -> Set b -> Relation a b -> Set a$/;"	ft	signature:((Ord a, Ord b) => Set a -> Set b -> Relation a b -> Set a)	line:329	language:Haskell
(<*>)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  (<*>) = ap$/;"	fi	instance:Monad f => Applicative (MT v loc f)	line:1806	language:Haskell
(<*>)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  (<*>) = ap$/;"	fi	instance:Applicative (SubseqExtractor' n)	line:313	language:Haskell
(<*>)	./parser-typechecker/src/Unison/Util/Free.hs	/^  (<*>) = ap$/;"	fi	instance:Applicative (Free f)	line:66	language:Haskell
(<*>)	./yaks/easytest/src/EasyTest.hs	/^  (<*>) = ap$/;"	fi	instance:Applicative Test	line:397	language:Haskell
(<*>)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    (<*>) = ap$/;"	fi	instance:Monad m => Applicative (CmdM m)	line:70	language:Haskell
(<*>)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    (<*>) = ap$/;"	fi	instance:Monad m => Applicative (StateT s m)	line:79	language:Haskell
(<>)	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  (<>) = mappend$/;"	fi	instance:Semigroup RefCollisions	line:836	language:Haskell
(<>)	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^  (<>) = mappend$/;"	fi	instance:Monad m => Semigroup (CodeLookup v m a)	line:47	language:Haskell
(<>)	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^instance Ord v => Semigroup (SlurpComponent v) where (<>) = mappend$/;"	fi	instance:Ord v => Semigroup (SlurpComponent v)	line:36	language:Haskell
(<>)	./parser-typechecker/src/Unison/Lexer.hs	/^instance Semigroup Pos where (<>) = mappend$/;"	fi	instance:Semigroup Pos	line:125	language:Haskell
(<>)	./parser-typechecker/src/Unison/Parser.hs	/^instance Semigroup UniqueName where (<>) = mappend$/;"	fi	instance:Semigroup UniqueName	line:57	language:Haskell
(<>)	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  (<>) = mappend$/;"	fi	instance:Semigroup PrettyPrintEnv	line:119	language:Haskell
(<>)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Semigroup (CompilationEnv e cont) where (<>) = mappend$/;"	fi	instance:Semigroup (CompilationEnv e cont)	line:985	language:Haskell
(<>)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  (<>) = mappend$/;"	fi	instance:Semigroup (SubseqExtractor' n a)	line:348	language:Haskell
(<>)	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^instance Semigroup (TypeLookup v a) where (<>) = mappend$/;"	fi	instance:Semigroup (TypeLookup v a)	line:56	language:Haskell
(<>)	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance Semigroup Bytes where (<>) = mappend$/;"	fi	instance:Semigroup Bytes	line:81	language:Haskell
(<>)	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Semigroup (Pretty s) where (<>) = mappend$/;"	fi	instance:Semigroup (Pretty s)	line:635	language:Haskell
(<>)	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Semigroup Delta where (<>) = mappend$/;"	fi	instance:Semigroup Delta	line:649	language:Haskell
(<>)	./parser-typechecker/src/Unison/Util/Star3.hs	/^  (<>) = mappend$/;"	fi	instance:(Ord fact, Ord d1, Ord d2, Ord d3) => Semigroup (Star3 fact d1 d2 d3)	line:188	language:Haskell
(<>)	./unison-core/src/Unison/ABT.hs	/^  (<>) = mappend$/;"	fi	instance:Semigroup (Path s t a b m)	line:62	language:Haskell
(<>)	./unison-core/src/Unison/Names2.hs	/^instance Ord n => Semigroup (Names' n) where (<>) = mappend$/;"	fi	instance:Ord n => Semigroup (Names' n)	line:323	language:Haskell
(<>)	./unison-core/src/Unison/Util/Relation.hs	/^  (<>) = union$/;"	fi	instance:(Ord a, Ord b) => Semigroup (Relation a b)	line:477	language:Haskell
(<>)	./unison-core/src/Unison/Util/Relation3.hs	/^  (<>) = mappend$/;"	fi	instance:(Ord a, Ord b, Ord c) => Semigroup (Relation3 a b c)	line:109	language:Haskell
(<>)	./unison-core/src/Unison/Util/Relation4.hs	/^  (<>) = mappend$/;"	fi	instance:(Ord a, Ord b, Ord c, Ord d) => Semigroup (Relation4 a b c d)	line:110	language:Haskell
(<>)	./yaks/haskeline/tests/Unit.hs	/^(<>) :: B.ByteString -> B.ByteString -> B.ByteString$/;"	ft	signature:(B.ByteString -> B.ByteString -> B.ByteString)	line:286	language:Haskell
(<|)	./unison-core/src/Unison/Util/Relation.hs	/^(<|), restrictDom :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Set a -> Relation a b -> Relation a b)	line:347	language:Haskell
(<|>)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  (<|>) = mplus$/;"	fi	instance:Alternative (SubseqExtractor' n)	line:336	language:Haskell
(<||)	./unison-core/src/Unison/Util/Relation.hs	/^(<||), subtractDom :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Set a -> Relation a b -> Relation a b)	line:375	language:Haskell
(==#)	./unison-core/src/Unison/Term.hs	/^instance (Eq a, ABT.Var v) => Eq1 (F v a p) where (==#) = (==)$/;"	fi	instance:(Eq a, ABT-Var v) => Eq1 (F v a p)	line:1034	language:Haskell
(==#)	./unison-core/src/Unison/Type.hs	/^instance Eq1 F where (==#) = (==)$/;"	fi	instance:Eq1 F	line:54	language:Haskell
(>+>)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^(>+>) :: Monad m => KeyCommand m s t -> Command m t u -> KeyCommand m s u$/;"	ft	signature:(Monad m => KeyCommand m s t -> Command m t u -> KeyCommand m s u)	line:120	language:Haskell
(>|>)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^(>|>) :: Monad m => Command m s t -> Command m t u -> Command m s u$/;"	ft	signature:(Monad m => Command m s t -> Command m t u -> Command m s u)	line:116	language:Haskell
(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	./unison-core/src/Unison/Term.hs	/^instance (ABT.Var vt, Eq at, Eq a) => Eq (F vt at p a) where$/;"	i	line:1037	language:Haskell
(Annotated a, Annotated b) => Annotated (MatchCase a b)	./parser-typechecker/src/Unison/Parser.hs	/^instance (Annotated a, Annotated b) => Annotated (MatchCase a b) where$/;"	i	line:191	language:Haskell
(CyclicEq e, CyclicEq cont) => CyclicEq (Req e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (CyclicEq e, CyclicEq cont) => CyclicEq (Req e cont) where$/;"	i	line:1002	language:Haskell
(CyclicEq e, CyclicEq cont) => CyclicEq (UnderapplyStrategy e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (CyclicEq e, CyclicEq cont) => CyclicEq (UnderapplyStrategy e cont) where$/;"	i	line:993	language:Haskell
(CyclicEq e, CyclicEq cont) => CyclicEq (Value e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (CyclicEq e, CyclicEq cont) => CyclicEq (Value e cont) where$/;"	i	line:1010	language:Haskell
(CyclicOrd e, CyclicOrd cont) => CyclicOrd (Req e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (CyclicOrd e, CyclicOrd cont) => CyclicOrd (Req e cont) where$/;"	i	line:1078	language:Haskell
(CyclicOrd e, CyclicOrd cont) => CyclicOrd (UnderapplyStrategy e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (CyclicOrd e, CyclicOrd cont) => CyclicOrd (UnderapplyStrategy e cont) where$/;"	i	line:1070	language:Haskell
(CyclicOrd e, CyclicOrd cont) => CyclicOrd (Value e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (CyclicOrd e, CyclicOrd cont) => CyclicOrd (Value e cont) where$/;"	i	line:1090	language:Haskell
(Eq a, ABT-Var v) => Eq1 (F v a p)	./unison-core/src/Unison/Term.hs	/^instance (Eq a, ABT.Var v) => Eq1 (F v a p) where (==#) = (==)$/;"	i	line:1034	language:Haskell
(Eq cont, Eq e) => Eq (UnderapplyStrategy e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (Eq cont, Eq e) => Eq (UnderapplyStrategy e cont) where$/;"	i	line:110	language:Haskell
(Eq cont, Eq e) => Eq (Value e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (Eq cont, Eq e) => Eq (Value e cont) where$/;"	i	line:91	language:Haskell
(Foldable f, Functor f, Eq1 f, Var v) => Eq (Term f v a)	./unison-core/src/Unison/ABT.hs	/^instance (Foldable f, Functor f, Eq1 f, Var v) => Eq (Term f v a) where$/;"	i	line:530	language:Haskell
(Foldable f, Functor f, Ord1 f, Var v) => Ord (Term f v a)	./unison-core/src/Unison/ABT.hs	/^instance (Foldable f, Functor f, Ord1 f, Var v) => Ord (Term f v a) where$/;"	i	line:542	language:Haskell
(H-Hashable a, H-Hashable b) => H-Hashable (Relation a b)	./unison-core/src/Unison/Util/Relation.hs	/^instance (H.Hashable a, H.Hashable b) => H.Hashable (Relation a b) where$/;"	i	line:479	language:Haskell
(H-Hashable d1, H-Hashable d2, H-Hashable d3) => H-Hashable (Relation3 d1 d2 d3)	./unison-core/src/Unison/Util/Relation3.hs	/^instance (H.Hashable d1, H.Hashable d2, H.Hashable d3)$/;"	i	line:118	language:Haskell
(H-Hashable d1, H-Hashable d2, H-Hashable d3, H-Hashable d4) => H-Hashable (Relation4 d1 d2 d3 d4)	./unison-core/src/Unison/Util/Relation4.hs	/^instance (H.Hashable d1, H.Hashable d2, H.Hashable d3, H.Hashable d4)$/;"	i	line:120	language:Haskell
(H-Hashable fact, H-Hashable d1, H-Hashable d2, H-Hashable d3) => H-Hashable (Star3 fact d1 d2 d3)	./parser-typechecker/src/Unison/Util/Star3.hs	/^instance (H.Hashable fact, H.Hashable d1, H.Hashable d2, H.Hashable d3)$/;"	i	line:198	language:Haskell
(Hashable a) => Hashable (Set-Set a)	./unison-core/src/Unison/Hashable.hs	/^instance (Hashable a) => Hashable (Set.Set a) where$/;"	i	line:39	language:Haskell
(Hashable a, Hashable b) => Hashable (a, b)	./unison-core/src/Unison/Hashable.hs	/^instance (Hashable a, Hashable b) => Hashable (a,b) where$/;"	i	line:36	language:Haskell
(Hashable k, Hashable v) => Hashable (Map-Map k v)	./unison-core/src/Unison/Hashable.hs	/^instance (Hashable k, Hashable v) => Hashable (Map.Map k v) where$/;"	i	line:42	language:Haskell
(Hashable1 f, Functor f) => Hashable1 (Component f)	./unison-core/src/Unison/ABT.hs	/^instance (Hashable1 f, Functor f) => Hashable1 (Component f) where$/;"	i	line:643	language:Haskell
(MonadException m, Error e) => MonadException (ErrorT e m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance (MonadException m, Error e) => MonadException (ErrorT e m) where$/;"	i	line:159	language:Haskell
(MonadException m, MonadReader Layout m) => Term (Draw m)	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^instance (MonadException m, MonadReader Layout m) => Term (Draw m) where$/;"	i	line:353	language:Haskell
(MonadException m, MonadReader Layout m) => Term (Draw m)	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^instance (MonadException m, MonadReader Layout m) => Term (Draw m) where$/;"	i	line:349	language:Haskell
(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^instance (MonadException m, MonadReader Layout m) => Term (DumbTerm m) where$/;"	i	line:38	language:Haskell
(MonadFix m) => MonadFix (InputT m)	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^instance ( MonadFix m ) => MonadFix (InputT m) where$/;"	i	line:58	language:Haskell
(MonadReader r m, MonadTrans t, Monad (t m)) => MonadReader r (t m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance {-# OVERLAPPABLE #-} (MonadReader r m, MonadTrans t, Monad (t m))$/;"	i	line:44	language:Haskell
(MonadState s m, MonadTrans t, Monad (t m)) => MonadState s (t m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance {-# OVERLAPPABLE #-} (MonadState s m, MonadTrans t, Monad (t m))$/;"	i	line:112	language:Haskell
(MonadTrans t, CommandMonad m, MonadReader Prefs (t m), MonadException (t m), MonadReader Layout (t m)) => CommandMonad (t m)	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^instance {-# OVERLAPPABLE #-} (MonadTrans t, CommandMonad m, MonadReader Prefs (t m),$/;"	i	line:107	language:Haskell
(Monoid w, MonadException m) => MonadException (RWST r w s m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance (Monoid w, MonadException m) => MonadException (RWST r w s m) where$/;"	i	line:174	language:Haskell
(Monoid w, MonadException m) => MonadException (WriterT w m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance (Monoid w, MonadException m) => MonadException (WriterT w m) where$/;"	i	line:169	language:Haskell
(Ord a, Ord b) => Monoid (Relation a b)	./unison-core/src/Unison/Util/Relation.hs	/^instance (Ord a, Ord b) => Monoid (Relation a b) where$/;"	i	line:472	language:Haskell
(Ord a, Ord b) => Semigroup (Relation a b)	./unison-core/src/Unison/Util/Relation.hs	/^instance (Ord a, Ord b) => Semigroup (Relation a b) where$/;"	i	line:476	language:Haskell
(Ord a, Ord b, Ord c) => Monoid (Relation3 a b c)	./unison-core/src/Unison/Util/Relation3.hs	/^instance (Ord a, Ord b, Ord c) => Monoid (Relation3 a b c) where$/;"	i	line:111	language:Haskell
(Ord a, Ord b, Ord c) => Semigroup (Relation3 a b c)	./unison-core/src/Unison/Util/Relation3.hs	/^instance (Ord a, Ord b, Ord c) => Semigroup (Relation3 a b c) where$/;"	i	line:108	language:Haskell
(Ord a, Ord b, Ord c, Ord d) => Monoid (Relation4 a b c d)	./unison-core/src/Unison/Util/Relation4.hs	/^instance (Ord a, Ord b, Ord c, Ord d) => Monoid (Relation4 a b c d) where$/;"	i	line:112	language:Haskell
(Ord a, Ord b, Ord c, Ord d) => Semigroup (Relation4 a b c d)	./unison-core/src/Unison/Util/Relation4.hs	/^instance (Ord a, Ord b, Ord c, Ord d) => Semigroup (Relation4 a b c d) where$/;"	i	line:109	language:Haskell
(Ord fact, Ord d1, Ord d2, Ord d3) => Monoid (Star3 fact d1 d2 d3)	./parser-typechecker/src/Unison/Util/Star3.hs	/^instance (Ord fact, Ord d1, Ord d2, Ord d3) => Monoid (Star3 fact d1 d2 d3) where$/;"	i	line:190	language:Haskell
(Ord fact, Ord d1, Ord d2, Ord d3) => Semigroup (Star3 fact d1 d2 d3)	./parser-typechecker/src/Unison/Util/Star3.hs	/^instance (Ord fact, Ord d1, Ord d2, Ord d3) => Semigroup (Star3 fact d1 d2 d3) where$/;"	i	line:187	language:Haskell
(Ord loc, Var v) => Eq (Element v loc)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance (Ord loc, Var v) => Eq (Element v loc) where$/;"	i	line:116	language:Haskell
(Ord loc, Var v) => Show (Context v loc)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance (Ord loc, Var v) => Show (Context v loc) where$/;"	i	line:1783	language:Haskell
(Ord v, Functor m) => Functor (CodeLookup v m)	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^instance (Ord v, Functor m) => Functor (CodeLookup v m) where$/;"	i	line:39	language:Haskell
(PrintAnnotation{usages=a})	./parser-typechecker/src/Unison/TermPrinter.hs	/^  (PrintAnnotation { usages = a } ) <> (PrintAnnotation { usages = b } ) =$/;"	fi	instance:Semigroup PrintAnnotation	line:761	language:Haskell
(PutTf)	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  (PutT f) <*> (PutT a) = PutT $ (<*>) <$> f <*> a$/;"	fi	instance:Applicative m => Applicative (PutT m)	line:47	language:Haskell
(PutTm)	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  (PutT m) >>= f = PutT $ do$/;"	fi	instance:Monad m => Monad (PutT m)	line:50	language:Haskell
(Rangestartend)	./parser-typechecker/src/Unison/Util/Range.hs	/^  (Range start end) <> (Range start2 end2) =$/;"	fi	instance:Semigroup Range	line:26	language:Haskell
(Show a, Show b) => Show (Relation a b)	./unison-core/src/Unison/Util/Relation.hs	/^instance (Show a, Show b) => Show (Relation a b) where$/;"	i	line:38	language:Haskell
(Show a, Show b, Show c) => Show (Relation3 a b c)	./unison-core/src/Unison/Util/Relation3.hs	/^instance (Show a, Show b, Show c) => Show (Relation3 a b c) where$/;"	i	line:21	language:Haskell
(Show a, Show b, Show c, Show d) => Show (Relation4 a b c d)	./unison-core/src/Unison/Util/Relation4.hs	/^instance (Show a, Show b, Show c, Show d) => Show (Relation4 a b c d) where$/;"	i	line:26	language:Haskell
(Show e, Show cont) => Show (Value e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (Show e, Show cont) => Show (Value e cont) where$/;"	i	line:962	language:Haskell
(Show e, Show cont) => Show (Z e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance (Show e, Show cont) => Show (Z e cont) where$/;"	i	line:821	language:Haskell
(Show v) => Show (Monotype v a)	./unison-core/src/Unison/Type.hs	/^instance (Show v) => Show (Monotype v a) where$/;"	i	line:86	language:Haskell
(Show v) => Show1 (F v a p)	./unison-core/src/Unison/Term.hs	/^instance (Show v) => Show1 (F v a p) where showsPrec1 = showsPrec$/;"	i	line:1035	language:Haskell
(Show v, Show a) => Show (F v a0 p a)	./unison-core/src/Unison/Term.hs	/^instance (Show v, Show a) => Show (F v a0 p a) where$/;"	i	line:1065	language:Haskell
(Show1 f, Show v) => Show (Term f v a)	./unison-core/src/Unison/ABT.hs	/^instance (Show1 f, Show v) => Show (Term f v a) where$/;"	i	line:698	language:Haskell
(Var v) => Show (Element v loc)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance (Var v) => Show (Element v loc) where$/;"	i	line:1774	language:Haskell
(as<$|bs)	./unison-core/src/Unison/Util/Relation.hs	/^(as <$| bs) r = as `S.intersection` generarAS bs$/;"	fi	line:330	language:Haskell
(as|$>bs)	./unison-core/src/Unison/Util/Relation.hs	/^(as |$> bs) r = bs `S.intersection` generarBS as$/;"	fi	line:341	language:Haskell
(atError,atWarn,atInfo,atDebug,atTrace)	./parser-typechecker/src/Unison/Util/Logger.hs	/^(atError, atWarn, atInfo, atDebug, atTrace) =$/;"	fi	line:102	language:Haskell
(cons,merge)	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^(cons, merge) = (cons'' pure, merge'' pure)$/;"	fi	line:257	language:Haskell
(errorLevel,warnLevel,infoLevel,debugLevel,traceLevel)	./parser-typechecker/src/Unison/Util/Logger.hs	/^(errorLevel, warnLevel, infoLevel, debugLevel, traceLevel) = (1,2,3,4,5)$/;"	fi	line:96	language:Haskell
(f.||.g)	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^(f .||. g) x = f x || g x$/;"	fi	line:299	language:Haskell
(result,result2)	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^(result, result2) =$/;"	fi	line:242	language:Haskell
(unitRef,pairRef,optionalRef,testResultRef,linkRef,docRef)	./unison-core/src/Unison/DataDeclaration.hs	/^(unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef) =$/;"	fi	line:410	language:Haskell
(|$>)	./unison-core/src/Unison/Util/Relation.hs	/^(|$>) :: (Ord a, Ord b) => Set a -> Set b -> Relation a b -> Set b$/;"	ft	signature:((Ord a, Ord b) => Set a -> Set b -> Relation a b -> Set b)	line:340	language:Haskell
(|>)	./parser-typechecker/src/Unison/TermPrinter.hs	/^(|>) :: a -> (a -> b) -> b$/;"	ft	signature:(a -> (a -> b) -> b)	line:855	language:Haskell
(|>)	./unison-core/src/Unison/Util/Relation.hs	/^(|>), restrictRan :: (Ord a, Ord b) => Relation a b -> Set b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Set b -> Relation a b)	line:357	language:Haskell
(||>)	./unison-core/src/Unison/Util/Relation.hs	/^(||>) :: (Ord a, Ord b) => Relation a b -> Set b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Set b -> Relation a b)	line:368	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocRef <- ((== docRef) -> True)$/;"	fi	line:533	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocSignatureId <- ((== docSignatureId) -> True)$/;"	fi	line:541	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocBlobId <- ((== docBlobId) -> True)$/;"	fi	line:542	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocLinkId <- ((== docLinkId) -> True)$/;"	fi	line:543	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocSourceId <- ((== docSourceId) -> True)$/;"	fi	line:544	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocEvaluateId <- ((== docEvaluateId) -> True)$/;"	fi	line:545	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocJoinId <- ((== docJoinId) -> True)$/;"	fi	line:546	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkTermId <- ((== linkTermId) -> True)$/;"	fi	line:547	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkTypeId <- ((== linkTypeId) -> True)$/;"	fi	line:548	language:Haskell
<-	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkRef <- ((== linkRef) -> True)$/;"	fi	line:549	language:Haskell
ABT	./unison-core/src/Unison/ABT.hs	/^data ABT f v r$/;"	d	line:30	language:Haskell
ABT-Var Symbol	./unison-core/src/Unison/Symbol.hs	/^instance ABT.Var Symbol where$/;"	i	line:15	language:Haskell
ABT-Var SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance ABT.Var SymbolC where$/;"	i	line:952	language:Haskell
ABT-Var v => ABT-Var (TypeVar b v)	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^instance ABT.Var v => ABT.Var (TypeVar b v) where$/;"	i	line:35	language:Haskell
ANF	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^newtype ANF v a = ANF_ { term :: Term v a }$/;"	nt	line:29	language:Haskell
ANF_	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^newtype ANF v a = ANF_ { term :: Term v a }$/;"	cons	newtype:ANF	line:29	language:Haskell
ATree	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type ATree a = Tree a (List (ATree a)) | Leaf (Option a)$/;"	t	line:51	language:Haskell
Ability	./unison-core/src/Unison/Var.hs	/^  Ability | Input | Output |$/;"	cons	data:InferenceType	line:109	language:Haskell
AbilityBraces	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | AbilityBraces$/;"	cons	data:Element	line:19	language:Haskell
AbilityCheckFailure	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | AbilityCheckFailure [Type v loc] [Type v loc] (Context v loc) -- ambient, requested$/;"	cons	data:Cause	line:281	language:Haskell
AbilityCheckFailure	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | AbilityCheckFailure { ambient                 :: [C.Type v loc]$/;"	cons	data:TypeError	line:59	language:Haskell
AbilityKeyword	./parser-typechecker/src/Unison/PrintError.hs	/^pattern AbilityKeyword = Color.Green$/;"	pi	line:68	language:Haskell
Abs	./unison-core/src/Unison/ABT.hs	/^  | Abs v r$/;"	cons	data:ABT	line:33	language:Haskell
Abs'	./unison-core/src/Unison/ABT.hs	/^pattern Abs' subst <- (unabs1 -> Just subst)$/;"	pi	line:171	language:Haskell
Abs'	./unison-core/src/Unison/Term.hs	/^pattern Abs' subst <- ABT.Abs' subst$/;"	pi	line:410	language:Haskell
Abs'	./unison-core/src/Unison/Type.hs	/^pattern Abs' subst <- ABT.Abs' subst$/;"	pi	line:124	language:Haskell
Abs1NA'	./unison-core/src/Unison/ABT.hs	/^pattern Abs1NA' avs body <- (unabs1A -> Just (avs, body))$/;"	pi	line:176	language:Haskell
AbsN'	./unison-core/src/Unison/ABT.hs	/^pattern AbsN' vs body <- (unabs -> (vs, body))$/;"	pi	line:172	language:Haskell
AbsNA'	./unison-core/src/Unison/ABT.hs	/^pattern AbsNA' avs body <- (unabsA -> (avs, body))$/;"	pi	line:175	language:Haskell
Absolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Absolute = Absolute { unabsolute :: Path } deriving (Eq,Ord)$/;"	nt	line:32	language:Haskell
Accessors	./parser-typechecker/src/Unison/FileParser.hs	/^type Accessors v = [(L.Token v, [(L.Token v, Type v Ann)])]$/;"	t	line:150	language:Haskell
Accumulate	./unison-core/src/Unison/Hashable.hs	/^class Accumulate h where$/;"	c	line:19	language:Haskell
Action	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^type Action m i v = MaybeT (StateT (LoopState m v) (F m i v))$/;"	t	line:136	language:Haskell
Action	./parser-typechecker/src/Unison/TermParser.hs	/^  | Action (Term v Ann)$/;"	cons	data:BlockElement	line:752	language:Haskell
Action'	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^type Action' m v = Action m (Either Event Input) v$/;"	t	line:178	language:Haskell
ActionM	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^type ActionM a = forall m . (MonadReader Layout m, MonadIO m) => ActionT (Draw m) a$/;"	t	line:187	language:Haskell
ActionT	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^type ActionT = Writer.WriterT TermAction$/;"	t	line:185	language:Haskell
Actions	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data Actions = Actions {leftA, rightA, upA :: Int -> TermOutput,$/;"	d	line:35	language:Haskell
Actions	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data Actions = Actions {leftA, rightA, upA :: Int -> TermOutput,$/;"	cons	data:Actions	line:35	language:Haskell
ActualArgCount	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type ActualArgCount = Int$/;"	t	line:246	language:Haskell
Add	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  Add | Update | Duplicate | Collision | Conflicted |$/;"	cons	data:Status	line:128	language:Haskell
AddAliases	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  = AddAliases (Set Name)$/;"	cons	data:Aliases	line:36	language:Haskell
AddDefsToCodebase	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  AddDefsToCodebase :: UF.TypecheckedUnisonFile v Ann -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:70	language:Haskell
AddF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddF z z | SubF z z | MultF z z | DivF z z$/;"	cons	data:IR'	line:217	language:Haskell
AddI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | AddI [HQ'.HashQualified]$/;"	cons	data:Input	line:88	language:Haskell
AddI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddI z z | SubI z z | MultI z z | DivI z z$/;"	cons	data:IR'	line:209	language:Haskell
AddN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddN z z | DropN z z | SubN z z | MultN z z | DivN z z$/;"	cons	data:IR'	line:213	language:Haskell
AddTermReplacementI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | AddTermReplacementI PatchPath Reference Reference$/;"	cons	data:Input	line:98	language:Haskell
AddTypeReplacementI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | AddTypeReplacementI PatchPath Reference Reference$/;"	cons	data:Input	line:99	language:Haskell
AddedTermDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type AddedTermDisplay v a = ([(HashQualified, [MetadataDisplay v a])], Referent, Maybe (Type v a))$/;"	t	line:82	language:Haskell
AddedTypeDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type AddedTypeDisplay v a = ([(HashQualified, [MetadataDisplay v a])], Reference, Maybe (DeclOrBuiltin v a))$/;"	t	line:83	language:Haskell
Alias	./parser-typechecker/src/Unison/Builtin.hs	/^  | Alias Text Text$/;"	cons	data:BuiltinDSL	line:195	language:Haskell
Alias'	./parser-typechecker/src/Unison/Builtin.hs	/^data BuiltinTypeDSL = B' Text CT.ConstructorType | D' Text | Rename' Text Text | Alias' Text Text$/;"	cons	data:BuiltinTypeDSL	line:180	language:Haskell
AliasManyI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | AliasManyI [Path.HQSplit] Path'$/;"	cons	data:Input	line:68	language:Haskell
AliasTermI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | AliasTermI HashOrHQSplit' Path.Split'$/;"	cons	data:Input	line:66	language:Haskell
AliasTypeI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | AliasTypeI HashOrHQSplit' Path.Split'$/;"	cons	data:Input	line:67	language:Haskell
Aliases	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^data Aliases$/;"	d	line:35	language:Haskell
Alternative (SubseqExtractor' n)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Alternative (SubseqExtractor' n) where$/;"	i	line:334	language:Haskell
Alternative Test	./yaks/easytest/src/EasyTest.hs	/^instance Alternative Test where$/;"	i	line:406	language:Haskell
AlwaysAdd	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data HistoryDuplicates = AlwaysAdd | IgnoreConsecutive | IgnoreAll$/;"	cons	data:HistoryDuplicates	line:64	language:Haskell
AmbientAbilities	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^type AmbientAbilities v = [Type v Ann]$/;"	t	line:45	language:Haskell
AmbientContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^data AmbientContext = AmbientContext$/;"	d	line:59	language:Haskell
AmbientContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^data AmbientContext = AmbientContext$/;"	cons	data:AmbientContext	line:59	language:Haskell
AmbiguouslyTypeAndTerm	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^  | AmbiguouslyTypeAndTerm Reference.Id$/;"	cons	data:Err	line:120	language:Haskell
And	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | And z (IR' ann z)$/;"	cons	data:IR'	line:237	language:Haskell
And	./unison-core/src/Unison/Term.hs	/^  | And a a$/;"	cons	data:F	line:79	language:Haskell
And	./unison-core/src/Unison/Term.hs	/^  And a b == And a2 b2 = a == a2 && b == b2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1055	language:Haskell
And'	./unison-core/src/Unison/Term.hs	/^pattern And' x y <- (ABT.out -> ABT.Tm (And x y))$/;"	pi	line:428	language:Haskell
AndMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data BooleanMismatch = CondMismatch | AndMismatch | OrMismatch | GuardMismatch$/;"	cons	data:BooleanMismatch	line:19	language:Haskell
Ann	./parser-typechecker/src/Unison/Parser.hs	/^data Ann$/;"	d	line:109	language:Haskell
Ann	./parser-typechecker/src/Unison/Parser.hs	/^  | Ann { start :: L.Pos, end :: L.Pos }$/;"	cons	data:Ann	line:112	language:Haskell
Ann	./parser-typechecker/src/Unison/Parser.hs	/^  Ann s1 _ <> Ann _ e2 = Ann s1 e2$/;"	fi	instance:Semigroup Ann	line:124	language:Haskell
Ann	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | Ann v (Type v loc)                     -- `v` has type `a`, maybe quantified$/;"	cons	data:Element	line:113	language:Haskell
Ann	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Ann v t == Ann v2 t2           = v == v2 && t == t2$/;"	fi	instance:(Ord loc, Var v) => Eq (Element v loc)	line:119	language:Haskell
Ann	./unison-core/src/Unison/Term.hs	/^  | Ann a (Type typeVar typeAnn)$/;"	cons	data:F	line:76	language:Haskell
Ann	./unison-core/src/Unison/Term.hs	/^  Ann e t == Ann e2 t2 = e == e2 && t == t2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1052	language:Haskell
Ann	./unison-core/src/Unison/Type.hs	/^  | Ann a K.Kind$/;"	cons	data:F	line:44	language:Haskell
Ann'	./unison-core/src/Unison/Term.hs	/^pattern Ann' x t <- (ABT.out -> ABT.Tm (Ann x t))$/;"	pi	line:438	language:Haskell
Ann'	./unison-core/src/Unison/Type.hs	/^pattern Ann' t k <- ABT.Tm' (Ann t k)$/;"	pi	line:106	language:Haskell
Annotated	./parser-typechecker/src/Unison/Parser.hs	/^class Annotated a where$/;"	c	line:176	language:Haskell
Annotated (L-Token a)	./parser-typechecker/src/Unison/Parser.hs	/^instance Annotated (L.Token a) where$/;"	i	line:182	language:Haskell
Annotated Ann	./parser-typechecker/src/Unison/Parser.hs	/^instance Annotated Ann where$/;"	i	line:179	language:Haskell
Annotated a => Annotated (ABT-Term f v a)	./parser-typechecker/src/Unison/Parser.hs	/^instance Annotated a => Annotated (ABT.Term f v a) where$/;"	i	line:185	language:Haskell
Annotated a => Annotated (PatternP a)	./parser-typechecker/src/Unison/Parser.hs	/^instance Annotated a => Annotated (PatternP a) where$/;"	i	line:188	language:Haskell
AnnotatedExcerpt	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^data AnnotatedExcerpt a = AnnotatedExcerpt$/;"	d	line:78	language:Haskell
AnnotatedExcerpt	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^data AnnotatedExcerpt a = AnnotatedExcerpt$/;"	cons	data:AnnotatedExcerpt	line:78	language:Haskell
AnnotatedText	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^newtype AnnotatedText a = AnnotatedText (Seq (String, Maybe a))$/;"	nt	line:26	language:Haskell
AnnotatedText	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  AnnotatedText (as :|> ("", _)) <> bs = AnnotatedText as <> bs$/;"	fi	instance:Semigroup (AnnotatedText a)	line:30	language:Haskell
AnnotatedText	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  AnnotatedText as <> AnnotatedText bs = AnnotatedText (as <> bs)$/;"	fi	instance:Semigroup (AnnotatedText a)	line:32	language:Haskell
Annotation	./unison-core/src/Unison/Paths.hs	/^  | Annotation -- ^ Points into the annotation$/;"	cons	data:PathElement	line:39	language:Haskell
App	./unison-core/src/Unison/Term.hs	/^  | App a a$/;"	cons	data:F	line:75	language:Haskell
App	./unison-core/src/Unison/Term.hs	/^  App f a == App f2 a2 = f == f2 && a == a2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1051	language:Haskell
App	./unison-core/src/Unison/Type.hs	/^  | App a a$/;"	cons	data:F	line:45	language:Haskell
App'	./unison-core/src/Unison/Term.hs	/^pattern App' f x <- (ABT.out -> ABT.Tm (App f x))$/;"	pi	line:422	language:Haskell
App'	./unison-core/src/Unison/Type.hs	/^pattern App' f x <- ABT.Tm' (App f x)$/;"	pi	line:107	language:Haskell
Append	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  = Empty | Group r | Lit s | Wrap (Seq r) | OrElse r r | Append (Seq r)$/;"	cons	data:F	line:131	language:Haskell
AppendToReflog	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  AppendToReflog :: Text -> Branch m -> Branch m -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:152	language:Haskell
Applicative (Free f)	./parser-typechecker/src/Unison/Util/Free.hs	/^instance Applicative (Free f) where$/;"	i	line:64	language:Haskell
Applicative (Result v loc)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Applicative (Result v loc) where$/;"	i	line:135	language:Haskell
Applicative (SubseqExtractor' n)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Applicative (SubseqExtractor' n) where$/;"	i	line:311	language:Haskell
Applicative Test	./yaks/easytest/src/EasyTest.hs	/^instance Applicative Test where$/;"	i	line:395	language:Haskell
Applicative Token	./parser-typechecker/src/Unison/Lexer.hs	/^instance Applicative Token where$/;"	i	line:116	language:Haskell
Applicative m => Applicative (PutT m)	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^instance Applicative m => Applicative (PutT m) where$/;"	i	line:45	language:Haskell
Apply	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Apply (IR' ann z) [z]$/;"	cons	data:IR'	line:232	language:Haskell
Apps'	./unison-core/src/Unison/Term.hs	/^pattern Apps' f args <- (unApps -> Just (f, args))$/;"	pi	line:431	language:Haskell
Apps'	./unison-core/src/Unison/Type.hs	/^pattern Apps' f args <- (unApps -> Just (f, args))$/;"	pi	line:108	language:Haskell
AppsPred'	./unison-core/src/Unison/Term.hs	/^pattern AppsPred' f args <- (unAppsPred -> Just (f, args))$/;"	pi	line:433	language:Haskell
Arg	./unison-core/src/Unison/Paths.hs	/^  | Arg -- ^ Points at the argument of a function\/type application$/;"	cons	data:PathElement	line:34	language:Haskell
ArgMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data ArgMode s = ArgMode {arg :: Int, argState :: s}$/;"	d	line:341	language:Haskell
ArgMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data ArgMode s = ArgMode {arg :: Int, argState :: s}$/;"	cons	data:ArgMode	line:341	language:Haskell
ArgumentType	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^data ArgumentType = ArgumentType$/;"	d	line:36	language:Haskell
ArgumentType	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^data ArgumentType = ArgumentType$/;"	cons	data:ArgumentType	line:36	language:Haskell
Arity	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type Arity = Int$/;"	t	line:47	language:Haskell
Arrow	./unison-core/src/Unison/Kind.hs	/^data Kind = Star | Arrow Kind Kind deriving (Eq,Ord,Read,Show,Generic)$/;"	cons	data:Kind	line:10	language:Haskell
Arrow	./unison-core/src/Unison/Type.hs	/^  | Arrow a a$/;"	cons	data:F	line:43	language:Haskell
Arrow'	./unison-core/src/Unison/Type.hs	/^pattern Arrow' i o <- ABT.Tm' (Arrow i o)$/;"	pi	line:103	language:Haskell
Arrows'	./unison-core/src/Unison/Type.hs	/^pattern Arrows' spine <- (unArrows -> Just spine)$/;"	pi	line:104	language:Haskell
As	./unison-core/src/Unison/Pattern.hs	/^pattern As p = AsP () p$/;"	pi	line:107	language:Haskell
As	./unison-core/src/Unison/PatternP.hs	/^pattern As loc p = P.AsP loc p$/;"	pi	line:22	language:Haskell
AsP	./unison-core/src/Unison/Pattern.hs	/^  | AsP loc (PatternP loc)$/;"	cons	data:PatternP	line:46	language:Haskell
AsP	./unison-core/src/Unison/Pattern.hs	/^  AsP _ p == AsP _ q = p == q$/;"	fi	instance:Eq (PatternP loc)	line:141	language:Haskell
AudibleBell	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data BellStyle = NoBell | VisualBell | AudibleBell$/;"	cons	data:BellStyle	line:58	language:Haskell
B	./parser-typechecker/src/Unison/Builtin.hs	/^  = B Text (Type v)$/;"	cons	data:BuiltinDSL	line:185	language:Haskell
B	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
B	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  B x == B y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:95	language:Haskell
B'	./parser-typechecker/src/Unison/Builtin.hs	/^data BuiltinTypeDSL = B' Text CT.ConstructorType | D' Text | Rename' Text Text | Alias' Text Text$/;"	cons	data:BuiltinTypeDSL	line:180	language:Haskell
Backspace	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | Backspace | Delete$/;"	cons	data:BaseKey	line:41	language:Haskell
Backticks	./parser-typechecker/src/Unison/Lexer.hs	/^  | Backticks String (Maybe ShortHash) -- an identifier in backticks$/;"	cons	data:Lexeme	line:52	language:Haskell
BadDestinationBranch	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | BadDestinationBranch Path'$/;"	cons	data:Output	line:110	language:Haskell
BadType	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^  | BadType String$/;"	cons	data:MainTerm	line:31	language:Haskell
BaseKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data BaseKey = KeyChar Char$/;"	d	line:36	language:Haskell
Behavior	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^data Behavior = Behavior (IO RunTerm)$/;"	d	line:124	language:Haskell
Behavior	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^data Behavior = Behavior (IO RunTerm)$/;"	cons	data:Behavior	line:124	language:Haskell
BellStyle	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data BellStyle = NoBell | VisualBell | AudibleBell$/;"	d	line:58	language:Haskell
BinaryApp'	./unison-core/src/Unison/Term.hs	/^pattern BinaryApp' f arg1 arg2 <- (unBinaryApp -> Just (f, arg1, arg2))$/;"	pi	line:434	language:Haskell
BinaryApps'	./unison-core/src/Unison/Term.hs	/^pattern BinaryApps' apps lastArg <- (unBinaryApps -> Just (apps, lastArg))$/;"	pi	line:435	language:Haskell
BinaryAppsPred'	./unison-core/src/Unison/Term.hs	/^pattern BinaryAppsPred' apps lastArg <- (unBinaryAppsPred -> Just (apps, lastArg))$/;"	pi	line:436	language:Haskell
Bind	./parser-typechecker/src/Unison/Util/Free.hs	/^  Bind fx f >>= g = Bind fx (f >=> g)$/;"	fi	instance:Monad (Free f)	line:61	language:Haskell
Binding	./parser-typechecker/src/Unison/FileParser.hs	/^  | Binding ((Ann, v), term)$/;"	cons	data:Stanza	line:100	language:Haskell
Binding	./parser-typechecker/src/Unison/TermParser.hs	/^  = Binding ((Ann, v), Term v Ann)$/;"	cons	data:BlockElement	line:751	language:Haskell
Binding	./unison-core/src/Unison/Paths.hs	/^  | Binding !Int -- ^ Points at a particular binding in a let$/;"	cons	data:PathElement	line:37	language:Haskell
BindingEquals	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | BindingEquals$/;"	cons	data:Element	line:24	language:Haskell
Bindings	./parser-typechecker/src/Unison/FileParser.hs	/^  | Bindings [((Ann, v), term)] deriving (Foldable, Traversable, Functor)$/;"	cons	data:Stanza	line:101	language:Haskell
Black	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Blank	./parser-typechecker/src/Unison/Lexer.hs	/^  | Blank String     -- a typed hole or placeholder$/;"	cons	data:Lexeme	line:55	language:Haskell
Blank	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | Blank$/;"	cons	data:Element	line:14	language:Haskell
Blank	./unison-core/src/Unison/Blank.hs	/^data Blank loc = Blank | Recorded (Recorded loc)$/;"	d	line:21	language:Haskell
Blank	./unison-core/src/Unison/Blank.hs	/^data Blank loc = Blank | Recorded (Recorded loc)$/;"	cons	data:Blank	line:21	language:Haskell
Blank	./unison-core/src/Unison/Term.hs	/^  | Blank (B.Blank typeAnn)$/;"	cons	data:F	line:68	language:Haskell
Blank	./unison-core/src/Unison/Term.hs	/^  Blank b == Blank q = b == q$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1044	language:Haskell
Blank	./unison-core/src/Unison/Var.hs	/^  | Blank$/;"	cons	data:Type	line:93	language:Haskell
Blank'	./unison-core/src/Unison/Term.hs	/^pattern Blank' b <- (ABT.out -> ABT.Tm (Blank b))$/;"	pi	line:417	language:Haskell
Block	./parser-typechecker/src/Unison/TermPrinter.hs	/^  = Block$/;"	cons	data:BlockContext	line:75	language:Haskell
BlockContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^data BlockContext$/;"	d	line:73	language:Haskell
BlockElement	./parser-typechecker/src/Unison/TermParser.hs	/^data BlockElement v$/;"	d	line:750	language:Haskell
BlockName	./parser-typechecker/src/Unison/Lexer.hs	/^type BlockName = String$/;"	t	line:144	language:Haskell
BlockedDependency	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  ExtraDefinition | BlockedDependency$/;"	cons	data:Status	line:130	language:Haskell
Blue	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Body	./unison-core/src/Unison/Paths.hs	/^  | Body -- ^ Points at the body of a lambda, let, binding, forall, or annotation$/;"	cons	data:PathElement	line:35	language:Haskell
Bold	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | Bold | Underline$/;"	cons	data:Color	line:21	language:Haskell
Bool	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Bool = True | False$/;"	t	line:41	language:Haskell
Bool'	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Bool' = False | True$/;"	t	line:42	language:Haskell
Boolean	./unison-core/src/Unison/Pattern.hs	/^pattern Boolean b = BooleanP () b$/;"	pi	line:100	language:Haskell
Boolean	./unison-core/src/Unison/PatternP.hs	/^pattern Boolean loc b = P.BooleanP loc b$/;"	pi	line:15	language:Haskell
Boolean	./unison-core/src/Unison/Term.hs	/^  | Boolean Bool$/;"	cons	data:F	line:65	language:Haskell
Boolean	./unison-core/src/Unison/Term.hs	/^  Boolean x == Boolean y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1041	language:Haskell
Boolean'	./unison-core/src/Unison/Term.hs	/^pattern Boolean' b <- (ABT.out -> ABT.Tm (Boolean b))$/;"	pi	line:414	language:Haskell
BooleanLiteral	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | BooleanLiteral$/;"	cons	data:Element	line:13	language:Haskell
BooleanMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data BooleanMismatch = CondMismatch | AndMismatch | OrMismatch | GuardMismatch$/;"	d	line:19	language:Haskell
BooleanMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | BooleanMismatch { getBooleanMismatch :: BooleanMismatch$/;"	cons	data:TypeError	line:33	language:Haskell
BooleanP	./unison-core/src/Unison/Pattern.hs	/^  | BooleanP loc !Bool$/;"	cons	data:PatternP	line:39	language:Haskell
BooleanP	./unison-core/src/Unison/Pattern.hs	/^  BooleanP _ b == BooleanP _ b2 = b == b2$/;"	fi	instance:Eq (PatternP loc)	line:134	language:Haskell
Both	./parser-typechecker/src/Unison/Lexer.hs	/^  | Both Err Err$/;"	cons	data:Err	line:31	language:Haskell
Bound	./unison-core/src/Unison/ABT.hs	/^data V v = Free v | Bound v deriving (Eq,Ord,Show,Functor)$/;"	cons	data:V	line:47	language:Haskell
Bound	./unison-core/src/Unison/Paths.hs	/^  | Bound -- ^ Points at the symbol bound by a `let`, `lambda` or `forall` binder$/;"	cons	data:PathElement	line:36	language:Haskell
BoxStyle	./parser-typechecker/src/Unison/Util/Pretty.hs	/^type BoxStyle s =$/;"	t	line:717	language:Haskell
Branch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^newtype Branch m = Branch { _history :: Causal m Raw (Branch0 m) }$/;"	nt	line:152	language:Haskell
Branch0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Branch0 m = Branch0$/;"	d	line:161	language:Haskell
Branch0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Branch0 m = Branch0$/;"	cons	data:Branch0	line:161	language:Haskell
BranchAlreadyExists	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | BranchAlreadyExists Path'$/;"	cons	data:Output	line:96	language:Haskell
BranchAttentions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data BranchAttentions = BranchAttentions$/;"	d	line:815	language:Haskell
BranchAttentions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data BranchAttentions = BranchAttentions$/;"	cons	data:BranchAttentions	line:815	language:Haskell
BranchAttentions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  BranchAttentions edited1 removed1 <> BranchAttentions edited2 removed2$/;"	fi	instance:Semigroup BranchAttentions	line:823	language:Haskell
BranchDiff	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data BranchDiff = BranchDiff$/;"	d	line:179	language:Haskell
BranchDiff	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data BranchDiff = BranchDiff$/;"	cons	data:BranchDiff	line:179	language:Haskell
BranchDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data BranchDiff = BranchDiff$/;"	d	line:41	language:Haskell
BranchDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data BranchDiff = BranchDiff$/;"	cons	data:BranchDiff	line:41	language:Haskell
BranchDiffOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^data BranchDiffOutput v a = BranchDiffOutput {$/;"	d	line:47	language:Haskell
BranchDiffOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^data BranchDiffOutput v a = BranchDiffOutput {$/;"	cons	data:BranchDiffOutput	line:47	language:Haskell
BranchHashAmbiguous	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | BranchHashAmbiguous ShortBranchHash (Set ShortBranchHash)$/;"	cons	data:Output	line:109	language:Haskell
BranchHashLength	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  BranchHashLength :: Command m i v Int$/;"	c_gadt	d_gadt:Command	line:80	language:Haskell
BranchHashesByPrefix	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  BranchHashesByPrefix :: ShortBranchHash -> Command m i v (Set Branch.Hash)$/;"	c_gadt	d_gadt:Command	line:82	language:Haskell
BranchId	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^type BranchId = Either ShortBranchHash Path'$/;"	t	line:31	language:Haskell
BranchLoadMode	./parser-typechecker/src/Unison/Codebase/BranchLoadMode.hs	/^data BranchLoadMode = FailIfMissing | EmptyIfMissing deriving (Eq, Show)$/;"	d	line:9	language:Haskell
BranchNotEmpty	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | BranchNotEmpty Path'$/;"	cons	data:Output	line:93	language:Haskell
BranchNotFound	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | BranchNotFound Path'$/;"	cons	data:Output	line:111	language:Haskell
Bs	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
Bs	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Bs x == Bs y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:98	language:Haskell
Bug	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Bug z$/;"	cons	data:IR'	line:224	language:Haskell
Builtin	./unison-core/src/Unison/DataDeclaration.hs	/^  Builtin CT.ConstructorType | Decl (Decl v a)$/;"	cons	data:DeclOrBuiltin	line:57	language:Haskell
Builtin	./unison-core/src/Unison/Reference.hs	/^  = Builtin Text.Text$/;"	cons	data:Reference	line:42	language:Haskell
Builtin	./unison-core/src/Unison/ShortHash.hs	/^  = Builtin Text$/;"	cons	data:ShortHash	line:13	language:Haskell
Builtin'	./unison-core/src/Unison/Term.hs	/^pattern Builtin' r <- (ABT.out -> ABT.Tm (Ref (Builtin r)))$/;"	pi	line:421	language:Haskell
BuiltinAnnotation	./parser-typechecker/src/Unison/Codebase.hs	/^class BuiltinAnnotation a where$/;"	c	line:282	language:Haskell
BuiltinAnnotation Parser-Ann	./parser-typechecker/src/Unison/Codebase.hs	/^instance BuiltinAnnotation Parser.Ann where$/;"	i	line:285	language:Haskell
BuiltinDSL	./parser-typechecker/src/Unison/Builtin.hs	/^data BuiltinDSL v$/;"	d	line:183	language:Haskell
BuiltinThing	./parser-typechecker/src/Unison/Codebase/Editor/DisplayThing.hs	/^data DisplayThing a = BuiltinThing | MissingThing Reference.Id | RegularThing a$/;"	cons	data:DisplayThing	line:5	language:Haskell
BuiltinTypeDSL	./parser-typechecker/src/Unison/Builtin.hs	/^data BuiltinTypeDSL = B' Text CT.ConstructorType | D' Text | Rename' Text Text | Alias' Text Text$/;"	d	line:180	language:Haskell
BustedBuiltins	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | BustedBuiltins (Set Reference) (Set Reference)$/;"	cons	data:Output	line:169	language:Haskell
Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^newtype Bytes = Bytes (T.FingerTree (Sum Int) B.ByteString)$/;"	nt	line:19	language:Haskell
Bytes	./unison-core/src/Unison/Hashable.hs	/^  | Bytes !ByteString$/;"	cons	data:Token	line:12	language:Haskell
C	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
C	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  C x == C y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:97	language:Haskell
CEmpty	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data CommandMode = CMode [Grapheme] Grapheme [Grapheme] | CEmpty$/;"	cons	data:CommandMode	line:265	language:Haskell
CMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data CommandMode = CMode [Grapheme] Grapheme [Grapheme] | CEmpty$/;"	cons	data:CommandMode	line:265	language:Haskell
CachedCount	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type CachedCount = Int -- number of tests found in the cache$/;"	t	line:237	language:Haskell
CachedTests	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  = CachedTests TotalCount CachedCount$/;"	cons	data:TestReportStats	line:233	language:Haskell
CantDelete	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | CantDelete PPE.PrettyPrintEnv [SearchResult' v Ann] [SearchResult' v Ann]$/;"	cons	data:Output	line:126	language:Haskell
CantParseBranchHead	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^  | CantParseBranchHead FilePath$/;"	cons	data:Err	line:119	language:Haskell
CantUndo	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | CantUndo UndoFailureReason$/;"	cons	data:Output	line:163	language:Haskell
CantUndoPastMerge	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data UndoFailureReason = CantUndoPastStart | CantUndoPastMerge deriving Show$/;"	cons	data:UndoFailureReason	line:241	language:Haskell
CantUndoPastStart	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data UndoFailureReason = CantUndoPastStart | CantUndoPastMerge deriving Show$/;"	cons	data:UndoFailureReason	line:241	language:Haskell
Caption	./parser-typechecker/src/Unison/Util/Menu.hs	/^type Caption = ColorText$/;"	t	line:19	language:Haskell
CaseBody	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data ExistentialMismatch = IfBody | VectorBody | CaseBody$/;"	cons	data:ExistentialMismatch	line:22	language:Haskell
Causal	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^data Causal m h e$/;"	d	line:60	language:Haskell
Cause	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Cause v loc$/;"	d	line:276	language:Haskell
Chain	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  | Chain Symbol Continuation Continuation$/;"	cons	data:Continuation	line:57	language:Haskell
Char	./unison-core/src/Unison/Pattern.hs	/^pattern Char c = CharP () c$/;"	pi	line:105	language:Haskell
Char	./unison-core/src/Unison/PatternP.hs	/^pattern Char loc c = P.CharP loc c$/;"	pi	line:20	language:Haskell
Char	./unison-core/src/Unison/Term.hs	/^  | Char Char$/;"	cons	data:F	line:67	language:Haskell
Char	./unison-core/src/Unison/Term.hs	/^  Char x == Char y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1043	language:Haskell
Char'	./unison-core/src/Unison/Term.hs	/^pattern Char' c <- (ABT.out -> ABT.Tm (Char c))$/;"	pi	line:416	language:Haskell
CharLiteral	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | CharLiteral$/;"	cons	data:Element	line:12	language:Haskell
CharP	./unison-core/src/Unison/Pattern.hs	/^  | CharP loc !Char$/;"	cons	data:PatternP	line:44	language:Haskell
Character	./parser-typechecker/src/Unison/Lexer.hs	/^  | Character Char   -- character literals, `?X`$/;"	cons	data:Lexeme	line:51	language:Haskell
CheckoutFailed	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | CheckoutFailed Text$/;"	cons	data:GitError	line:12	language:Haskell
Choose	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^  Choose :: Vec Bool -> Vec a -> Vec a -> Vec a$/;"	c_gadt	d_gadt:Vec	line:15	language:Haskell
ClearScreen	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^              | ClearScreen$/;"	cons	data:Effect	line:40	language:Haskell
Close	./parser-typechecker/src/Unison/Lexer.hs	/^  | Close            -- end of a block$/;"	cons	data:Lexeme	line:48	language:Haskell
CloseWithoutMatchingOpen	./parser-typechecker/src/Unison/Lexer.hs	/^  | CloseWithoutMatchingOpen String String -- open, close$/;"	cons	data:Err	line:38	language:Haskell
CmdM	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data CmdM m a   = GetKey (KeyMap (CmdM m a))$/;"	d	line:58	language:Haskell
CmdM	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^                | CmdM (m (CmdM m a))$/;"	cons	data:CmdM	line:60	language:Haskell
CmdM	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    CmdM f >>= g = CmdM $ liftM (>>= g) f$/;"	fi	instance:Monad m => Monad (CmdM m)	line:77	language:Haskell
Code	./parser-typechecker/src/Unison/PrintError.hs	/^pattern Code = Color.Blue$/;"	pi	line:63	language:Haskell
CodeLookup	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^data CodeLookup v m a$/;"	d	line:30	language:Haskell
CodeLookup	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^  = CodeLookup {$/;"	cons	data:CodeLookup	line:31	language:Haskell
Codebase	./parser-typechecker/src/Unison/Codebase.hs	/^data Codebase m v a =$/;"	d	line:47	language:Haskell
Codebase	./parser-typechecker/src/Unison/Codebase.hs	/^  Codebase { getTerm            :: Reference.Id -> m (Maybe (Term v a))$/;"	cons	data:Codebase	line:48	language:Haskell
CodebaseHashLength	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  CodebaseHashLength :: Command m i v Int$/;"	c_gadt	d_gadt:Command	line:73	language:Haskell
CodebasePath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^type CodebasePath = FilePath$/;"	t	line:113	language:Haskell
CodingMode	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^data ExternalMode = CodingMode | OtherMode$/;"	cons	data:ExternalMode	line:37	language:Haskell
Collision	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  Add | Update | Duplicate | Collision | Conflicted |$/;"	cons	data:Status	line:128	language:Haskell
Color	./parser-typechecker/src/Unison/Util/ColorText.hs	/^data Color$/;"	d	line:18	language:Haskell
ColorText	./parser-typechecker/src/Unison/Util/ColorText.hs	/^type ColorText = AnnotatedText Color$/;"	t	line:16	language:Haskell
ColorText	./parser-typechecker/src/Unison/Util/Pretty.hs	/^type ColorText = CT.ColorText$/;"	t	line:123	language:Haskell
Column	./parser-typechecker/src/Unison/Lexer.hs	/^type Column = Int$/;"	t	line:121	language:Haskell
Command	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^data Command m i v a where$/;"	d_gadt	line:58	language:Haskell
Command	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^type Command m s t = s -> CmdM m t$/;"	t	line:63	language:Haskell
CommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data CommandMode = CMode [Grapheme] Grapheme [Grapheme] | CEmpty$/;"	d	line:265	language:Haskell
CommandMonad	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^        => CommandMonad m where$/;"	c	line:104	language:Haskell
CompareU	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | CompareU z z -- universal ordering$/;"	cons	data:IR'	line:221	language:Haskell
CompilationEnv	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data CompilationEnv e cont$/;"	d	line:51	language:Haskell
CompilationEnv	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = CompilationEnv { toIR' :: Map R.Reference (IR e cont)$/;"	cons	data:CompilationEnv	line:52	language:Haskell
CompilationEnv	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type CompilationEnv = IR.CompilationEnv ExternalFunction Continuation$/;"	t	line:43	language:Haskell
CompilerBug	./parser-typechecker/src/Unison/Result.hs	/^  | CompilerBug (CompilerBug v loc)$/;"	cons	data:Note	line:38	language:Haskell
CompilerBug	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^                    | CompilerBug (CompilerBug v loc)$/;"	cons	data:Result	line:130	language:Haskell
CompilerBug	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  CompilerBug bug es is <*> _                       = CompilerBug bug es is$/;"	fi	instance:Applicative (Result v loc)	line:137	language:Haskell
CompilerBug	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  CompilerBug bug es is >>= _ = CompilerBug bug es is$/;"	fi	instance:Monad (Result v loc)	line:146	language:Haskell
CompilerBug	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data CompilerBug v loc$/;"	d	line:208	language:Haskell
Completion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^data Completion = Completion {replacement  :: String, -- ^ Text to insert in line.$/;"	d	line:35	language:Haskell
Completion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^data Completion = Completion {replacement  :: String, -- ^ Text to insert in line.$/;"	cons	data:Completion	line:35	language:Haskell
CompletionFunc	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^type CompletionFunc m = (String,String) -> m (String, [Completion])$/;"	t	line:32	language:Haskell
CompletionType	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data CompletionType = ListCompletion | MenuCompletion$/;"	d	line:54	language:Haskell
Component	./unison-core/src/Unison/ABT.hs	/^data Component f a = Component [a] a | Embed (f a) deriving (Functor, Traversable, Foldable)$/;"	d	line:641	language:Haskell
Component	./unison-core/src/Unison/ABT.hs	/^data Component f a = Component [a] a | Embed (f a) deriving (Functor, Traversable, Foldable)$/;"	cons	data:Component	line:641	language:Haskell
Component	./unison-core/src/Unison/Reference.hs	/^newtype Component = Component { members :: Set Reference }$/;"	nt	line:113	language:Haskell
Con	./unison-core/src/Unison/Referent.hs	/^pattern Con :: Reference -> Int -> ConstructorType -> Referent$/;"	pt	signature:(Reference -> Int -> ConstructorType -> Referent)	line:25	language:Haskell
Con'	./unison-core/src/Unison/Referent.hs	/^data Referent' r = Ref' r | Con' r Int ConstructorType$/;"	cons	data:Referent'	line:29	language:Haskell
Concat	./parser-typechecker/src/Unison/Runtime/IR.hs	/^pattern Concat = Pattern.Concat$/;"	pi	line:174	language:Haskell
Concat	./unison-core/src/Unison/Pattern.hs	/^           | Concat$/;"	cons	data:SeqOp	line:55	language:Haskell
Concat	./unison-core/src/Unison/PatternP.hs	/^pattern Concat = P.Concat$/;"	pi	line:31	language:Haskell
ConcatPatternWithoutConstantLength	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | ConcatPatternWithoutConstantLength loc (Type v loc)$/;"	cons	data:Cause	line:290	language:Haskell
CondMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data BooleanMismatch = CondMismatch | AndMismatch | OrMismatch | GuardMismatch$/;"	cons	data:BooleanMismatch	line:19	language:Haskell
ConfigLookup	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  ConfigLookup :: Configured a => Text -> Command m i v (Maybe a)$/;"	c_gadt	d_gadt:Command	line:61	language:Haskell
ConfiguredGitUrlIncludesShortBranchHash	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ConfiguredGitUrlIncludesShortBranchHash PushPull RemoteRepo ShortBranchHash Path$/;"	cons	data:Output	line:173	language:Haskell
ConfiguredGitUrlParseError	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ConfiguredGitUrlParseError PushPull Path' Text String$/;"	cons	data:Output	line:172	language:Haskell
Conflicted	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  Add | Update | Duplicate | Collision | Conflicted |$/;"	cons	data:Status	line:128	language:Haskell
Cons	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | Cons { currentHash :: RawHash h$/;"	cons	data:Causal	line:64	language:Haskell
Cons	./parser-typechecker/src/Unison/Runtime/IR.hs	/^pattern Cons = Pattern.Cons$/;"	pi	line:173	language:Haskell
Cons	./unison-core/src/Unison/Pattern.hs	/^data SeqOp = Cons$/;"	cons	data:SeqOp	line:53	language:Haskell
Cons	./unison-core/src/Unison/PatternP.hs	/^pattern Cons = P.Cons$/;"	pi	line:30	language:Haskell
Cons Path Path NameSegment NameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Cons Path Path NameSegment NameSegment where$/;"	i	line:331	language:Haskell
Console	./parser-typechecker/src/Unison/Util/Menu.hs	/^type Console = IO String$/;"	t	line:22	language:Haskell
ConsoleLocation	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  = ConsoleLocation$/;"	cons	data:OutputLocation	line:137	language:Haskell
Construct	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Construct R.Reference ConstructorId [z]$/;"	cons	data:IR'	line:233	language:Haskell
Constructor	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | Constructor$/;"	cons	data:Element	line:17	language:Haskell
Constructor	./unison-core/src/Unison/Pattern.hs	/^pattern Constructor r cid ps = ConstructorP () r cid ps$/;"	pi	line:106	language:Haskell
Constructor	./unison-core/src/Unison/PatternP.hs	/^pattern Constructor loc r cid ps = P.ConstructorP loc r cid ps$/;"	pi	line:21	language:Haskell
Constructor	./unison-core/src/Unison/Term.hs	/^  | Constructor Reference Int$/;"	cons	data:F	line:72	language:Haskell
Constructor	./unison-core/src/Unison/Term.hs	/^  Constructor r cid == Constructor r2 cid2 = r == r2 && cid == cid2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1048	language:Haskell
Constructor'	./unison-core/src/Unison/Term.hs	/^pattern Constructor' ref n <- (ABT.out -> ABT.Tm (Constructor ref n))$/;"	pi	line:424	language:Haskell
ConstructorExistingTermCollision	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  TermExistingConstructorCollision | ConstructorExistingTermCollision |$/;"	cons	data:Status	line:129	language:Haskell
ConstructorId	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type ConstructorId = Int$/;"	t	line:48	language:Haskell
ConstructorId	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type ConstructorId = Int$/;"	t	line:247	language:Haskell
ConstructorId	./unison-core/src/Unison/DataDeclaration.hs	/^type ConstructorId = Term.ConstructorId$/;"	t	line:51	language:Haskell
ConstructorId	./unison-core/src/Unison/Pattern.hs	/^type ConstructorId = Int$/;"	t	line:18	language:Haskell
ConstructorId	./unison-core/src/Unison/PatternP.hs	/^type ConstructorId = P.ConstructorId$/;"	t	line:33	language:Haskell
ConstructorId	./unison-core/src/Unison/Term.hs	/^type ConstructorId = Pattern.ConstructorId$/;"	t	line:54	language:Haskell
ConstructorP	./unison-core/src/Unison/Pattern.hs	/^  | ConstructorP loc !Reference !Int [PatternP loc]$/;"	cons	data:PatternP	line:45	language:Haskell
ConstructorP	./unison-core/src/Unison/Pattern.hs	/^  ConstructorP _ r n args == ConstructorP _ s m brgs = r == s && n == m && args == brgs$/;"	fi	instance:Eq (PatternP loc)	line:138	language:Haskell
ConstructorType	./unison-core/src/Unison/ConstructorType.hs	/^data ConstructorType = Data | Effect deriving (Eq, Ord, Show, Enum)$/;"	d	line:5	language:Haskell
Constructors	./unison-core/src/Unison/DataDeclaration.hs	/^  | Constructors [a]$/;"	cons	data:F	line:276	language:Haskell
Consumed	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data KeyConsumed a = NotConsumed a | Consumed a$/;"	cons	data:KeyConsumed	line:48	language:Haskell
Cont	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Cont cont$/;"	cons	data:Value	line:88	language:Haskell
Cont	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Cont k1 == Cont k2 = k1 == k2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:105	language:Haskell
Context	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^newtype Context v loc = Context [(Element v loc, Info v loc)]$/;"	nt	line:326	language:Haskell
Continuation	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^data Continuation$/;"	d	line:54	language:Haskell
Continue	./unison-core/src/Unison/ABT.hs	/^data FindAction x = Found x | Prune | Continue deriving Show$/;"	cons	data:FindAction	line:509	language:Haskell
ControlKeyword	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | ControlKeyword$/;"	cons	data:Element	line:21	language:Haskell
Coord	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data Coord = Coord {coordX, coordY :: Int}$/;"	d	line:166	language:Haskell
Coord	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data Coord = Coord {coordX, coordY :: Int}$/;"	cons	data:Coord	line:166	language:Haskell
CopyPatchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | CopyPatchI Path.Split' Path.Split'$/;"	cons	data:Input	line:74	language:Haskell
Create	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data DiffType a = Create a | Delete a | Modify a deriving Show$/;"	cons	data:DiffType	line:23	language:Haskell
CreatePullRequestI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | CreatePullRequestI RemoteNamespace RemoteNamespace$/;"	cons	data:Input	line:52	language:Haskell
CreatedNewBranch	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | CreatedNewBranch Path.Absolute$/;"	cons	data:Output	line:95	language:Haskell
CtorLookup	./parser-typechecker/src/Unison/UnisonFile.hs	/^type CtorLookup = Map String (Reference, Int)$/;"	t	line:224	language:Haskell
Cyan	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Cycle	./unison-core/src/Unison/ABT.hs	/^  | Cycle r$/;"	cons	data:ABT	line:32	language:Haskell
Cycle'	./unison-core/src/Unison/ABT.hs	/^pattern Cycle' vs t <- Term _ _ (Cycle (AbsN' vs t))$/;"	pi	line:169	language:Haskell
Cycle'	./unison-core/src/Unison/Term.hs	/^pattern Cycle' xs t <- ABT.Cycle' xs t$/;"	pi	line:409	language:Haskell
Cycle'	./unison-core/src/Unison/Type.hs	/^pattern Cycle' xs t <- ABT.Cycle' xs t$/;"	pi	line:123	language:Haskell
CycleA'	./unison-core/src/Unison/ABT.hs	/^pattern CycleA' a avs t <- Term _ a (Cycle (AbsNA' avs t))$/;"	pi	line:174	language:Haskell
CycleTable	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^data CycleTable k v =$/;"	d	line:12	language:Haskell
CycleTable	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^  CycleTable {$/;"	cons	data:CycleTable	line:13	language:Haskell
CyclicEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^class CyclicEq a where$/;"	c	line:23	language:Haskell
CyclicEq Continuation	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance CyclicEq Continuation where$/;"	i	line:808	language:Haskell
CyclicEq ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance CyclicEq ExternalFunction where$/;"	i	line:802	language:Haskell
CyclicEq a => CyclicEq (S-Seq a)	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^instance CyclicEq a => CyclicEq (S.Seq a) where$/;"	i	line:46	language:Haskell
CyclicEq a => CyclicEq (Vector a)	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^instance CyclicEq a => CyclicEq (Vector a) where$/;"	i	line:51	language:Haskell
CyclicEq a => CyclicEq [a]	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^instance CyclicEq a => CyclicEq [a] where$/;"	i	line:41	language:Haskell
CyclicOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^class CyclicOrd a where$/;"	c	line:17	language:Haskell
CyclicOrd Continuation	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance CyclicOrd Continuation where$/;"	i	line:826	language:Haskell
CyclicOrd ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance CyclicOrd ExternalFunction where$/;"	i	line:805	language:Haskell
CyclicOrd a => CyclicOrd (S-Seq a)	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^instance CyclicOrd a => CyclicOrd (S.Seq a) where$/;"	i	line:42	language:Haskell
CyclicOrd a => CyclicOrd (Vector a)	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^instance CyclicOrd a => CyclicOrd (Vector a) where$/;"	i	line:45	language:Haskell
CyclicOrd a => CyclicOrd [a]	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^instance CyclicOrd a => CyclicOrd [a] where$/;"	i	line:36	language:Haskell
D	./parser-typechecker/src/Unison/Builtin.hs	/^  | D Text (Type v)$/;"	cons	data:BuiltinDSL	line:187	language:Haskell
D'	./parser-typechecker/src/Unison/Builtin.hs	/^data BuiltinTypeDSL = B' Text CT.ConstructorType | D' Text | Rename' Text Text | Alias' Text Text$/;"	cons	data:BuiltinTypeDSL	line:180	language:Haskell
DS	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type DS = StateT (Map Symbol (Term Symbol), Set RefID) IO$/;"	t	line:586	language:Haskell
Data	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Data R.Reference ConstructorId [Value e cont]$/;"	cons	data:Value	line:83	language:Haskell
Data	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Data r1 cid1 vs1 == Data r2 cid2 vs2 = r1 == r2 && cid1 == cid2 && vs1 == vs2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:100	language:Haskell
Data	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Unknown = Data | Effect deriving Show$/;"	cons	data:Unknown	line:206	language:Haskell
Data	./unison-core/src/Unison/ConstructorType.hs	/^data ConstructorType = Data | Effect deriving (Eq, Ord, Show, Enum)$/;"	cons	data:ConstructorType	line:5	language:Haskell
DataCtor	./unison-core/src/Unison/Referent.hs	/^pattern DataCtor = "d"$/;"	pi	line:61	language:Haskell
DataDeclaration	./parser-typechecker/src/Unison/Builtin.hs	/^type DataDeclaration v = DataDeclaration' v Ann$/;"	t	line:51	language:Haskell
DataDeclaration	./parser-typechecker/src/Unison/Codebase.hs	/^type DataDeclaration v a = DD.DataDeclaration' v a$/;"	t	line:44	language:Haskell
DataDeclaration	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^type DataDeclaration v a = DD.DataDeclaration' v a$/;"	t	line:13	language:Haskell
DataDeclaration	./unison-core/src/Unison/DataDeclaration.hs	/^type DataDeclaration v = DataDeclaration' v ()$/;"	t	line:53	language:Haskell
DataDeclaration	./unison-core/src/Unison/DataDeclaration.hs	/^data DataDeclaration' v a = DataDeclaration {$/;"	cons	data:DataDeclaration'	line:74	language:Haskell
DataDeclaration'	./unison-core/src/Unison/DataDeclaration.hs	/^data DataDeclaration' v a = DataDeclaration {$/;"	d	line:74	language:Haskell
DataDeclarations	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type DataDeclarations v loc = Map Reference (DataDeclaration' v loc)$/;"	t	line:125	language:Haskell
DataType	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DataType$/;"	cons	data:Element	line:29	language:Haskell
DataTypeKeyword	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DataTypeKeyword$/;"	cons	data:Element	line:27	language:Haskell
DataTypeModifier	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DataTypeModifier$/;"	cons	data:Element	line:31	language:Haskell
DataTypeParams	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DataTypeParams$/;"	cons	data:Element	line:28	language:Haskell
DebugBranchHistoryI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | DebugBranchHistoryI$/;"	cons	data:Input	line:131	language:Haskell
DebugNumberedArgsI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | DebugNumberedArgsI$/;"	cons	data:Input	line:130	language:Haskell
Decision	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | Decision v loc (Term.Term v loc)$/;"	cons	data:InfoNote	line:272	language:Haskell
Decl	./unison-core/src/Unison/DataDeclaration.hs	/^type Decl v a = Either (EffectDeclaration' v a) (DataDeclaration' v a)$/;"	t	line:54	language:Haskell
Decl	./unison-core/src/Unison/DataDeclaration.hs	/^  Builtin CT.ConstructorType | Decl (Decl v a)$/;"	cons	data:DeclOrBuiltin	line:57	language:Haskell
DeclOrBuiltin	./unison-core/src/Unison/DataDeclaration.hs	/^data DeclOrBuiltin v a =$/;"	d	line:56	language:Haskell
Declaration	./unison-core/src/Unison/Paths.hs	/^  | Declaration v (Term v) deriving Generic$/;"	cons	data:Target	line:23	language:Haskell
DefaultTTY	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^  | DefaultTTY Bool$/;"	cons	data:EchoState	line:111	language:Haskell
DelayForceChar	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DelayForceChar$/;"	cons	data:Element	line:37	language:Haskell
Delete	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data DiffType a = Create a | Delete a | Modify a deriving Show$/;"	cons	data:DiffType	line:23	language:Haskell
Delete	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | Backspace | Delete$/;"	cons	data:BaseKey	line:41	language:Haskell
DeleteBranchConfirmation	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DeleteBranchConfirmation$/;"	cons	data:Output	line:123	language:Haskell
DeleteBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeleteBranchI (Maybe Path.Split')$/;"	cons	data:Input	line:79	language:Haskell
DeleteEditI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeleteEditI HashOrHQSplit' (Maybe PatchPath)$/;"	cons	data:Input	line:104	language:Haskell
DeleteEverythingConfirmation	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DeleteEverythingConfirmation$/;"	cons	data:Output	line:127	language:Haskell
DeleteI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeleteI Path.HQSplit'$/;"	cons	data:Input	line:76	language:Haskell
DeletePatchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeletePatchI Path.Split'$/;"	cons	data:Input	line:80	language:Haskell
DeleteTermI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeleteTermI Path.HQSplit'$/;"	cons	data:Input	line:77	language:Haskell
DeleteTypeI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeleteTypeI Path.HQSplit'$/;"	cons	data:Input	line:78	language:Haskell
DeletedEverything	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DeletedEverything$/;"	cons	data:Output	line:128	language:Haskell
DelimiterChar	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DelimiterChar$/;"	cons	data:Element	line:41	language:Haskell
Delta	./parser-typechecker/src/Unison/Util/Pretty.hs	/^data Delta =$/;"	d	line:645	language:Haskell
Delta	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  Delta { line :: !Int, col :: !Int, maxCol :: !Int }$/;"	cons	data:Delta	line:646	language:Haskell
Deprecate	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data TermEdit = Replace Reference Typing | Deprecate$/;"	cons	data:TermEdit	line:10	language:Haskell
Deprecate	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^data TypeEdit = Replace Reference | Deprecate$/;"	cons	data:TypeEdit	line:7	language:Haskell
DeprecateTermI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeprecateTermI PatchPath Path.HQSplit'$/;"	cons	data:Input	line:96	language:Haskell
DeprecateTypeI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DeprecateTypeI PatchPath Path.HQSplit'$/;"	cons	data:Input	line:97	language:Haskell
Derived	./unison-core/src/Unison/Reference.hs	/^pattern Derived h i n = DerivedId (Id h i n)$/;"	pi	line:49	language:Haskell
DerivedId	./unison-core/src/Unison/Reference.hs	/^  | DerivedId Id deriving (Eq,Ord,Generic)$/;"	cons	data:Reference	line:47	language:Haskell
Deserialize	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^type Deserialize m h e = RawHash h -> m (Raw h e)$/;"	t	line:113	language:Haskell
DestExists	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data ForkFailure = SrcNotFound | DestExists$/;"	cons	data:ForkFailure	line:438	language:Haskell
DidntExpectExpression	./parser-typechecker/src/Unison/Parser.hs	/^  | DidntExpectExpression (L.Token L.Lexeme) (Maybe (L.Token L.Lexeme))$/;"	cons	data:Error	line:102	language:Haskell
Diff	./unison-core/src/Unison/Names3.hs	/^data Diff =$/;"	d	line:71	language:Haskell
Diff	./unison-core/src/Unison/Names3.hs	/^  Diff { originalNames :: Names0$/;"	cons	data:Diff	line:72	language:Haskell
DiffNamespaceI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | DiffNamespaceI Path' Path' -- old new$/;"	cons	data:Input	line:49	language:Haskell
DiffSlice	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data DiffSlice r = DiffSlice {$/;"	d	line:31	language:Haskell
DiffSlice	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data DiffSlice r = DiffSlice {$/;"	cons	data:DiffSlice	line:31	language:Haskell
DiffType	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data DiffType a = Create a | Delete a | Modify a deriving Show$/;"	d	line:23	language:Haskell
Different	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data Typing = Same | Subtype | Different$/;"	cons	data:Typing	line:20	language:Haskell
Direction	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data Direction = Forward | Reverse$/;"	d	line:83	language:Haskell
DisallowedAbsoluteName	./parser-typechecker/src/Unison/Parser.hs	/^  | DisallowedAbsoluteName (L.Token Name)$/;"	cons	data:Error	line:91	language:Haskell
DisplayConflicts	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DisplayConflicts (Relation Name Referent) (Relation Name Reference)$/;"	cons	data:Output	line:142	language:Haskell
DisplayDefinitions	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DisplayDefinitions (Maybe FilePath)$/;"	cons	data:Output	line:151	language:Haskell
DisplayI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | DisplayI OutputLocation String$/;"	cons	data:Input	line:119	language:Haskell
DisplayLinks	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DisplayLinks PPE.PrettyPrintEnvDecl Metadata.Metadata$/;"	cons	data:Output	line:174	language:Haskell
DisplayRendered	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DisplayRendered (Maybe FilePath) (P.Pretty P.ColorText)$/;"	cons	data:Output	line:149	language:Haskell
DisplayThing	./parser-typechecker/src/Unison/Codebase/Editor/DisplayThing.hs	/^data DisplayThing a = BuiltinThing | MissingThing Reference.Id | RegularThing a$/;"	d	line:5	language:Haskell
DistinctRanged	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^data DistinctRanged a = DistinctRanged a Int Int$/;"	d	line:111	language:Haskell
DistinctRanged	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^data DistinctRanged a = DistinctRanged a Int Int$/;"	cons	data:DistinctRanged	line:111	language:Haskell
DistinctRanged	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  DistinctRanged _ l r == DistinctRanged _ l' r' = l == l' && r == r'$/;"	fi	instance:Eq (DistinctRanged a)	line:113	language:Haskell
DistinctRanged	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  DistinctRanged _ l r <= DistinctRanged _ l' r' =$/;"	fi	instance:Ord (DistinctRanged a)	line:115	language:Haskell
DivF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddF z z | SubF z z | MultF z z | DivF z z$/;"	cons	data:IR'	line:217	language:Haskell
DivI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddI z z | SubI z z | MultI z z | DivI z z$/;"	cons	data:IR'	line:209	language:Haskell
DivN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddN z z | DropN z z | SubN z z | MultN z z | DivN z z$/;"	cons	data:IR'	line:213	language:Haskell
DoEffect	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^                | DoEffect Effect (CmdM m a)$/;"	cons	data:CmdM	line:59	language:Haskell
DoEffect	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    DoEffect e f >>= g = DoEffect e (f >>= g)$/;"	fi	instance:Monad m => Monad (CmdM m)	line:76	language:Haskell
Doc	./unison-core/src/Unison/DataDeclaration.hs	/^pattern Doc <- Term.App' (Term.Constructor' DocRef _) _$/;"	pi	line:540	language:Haskell
DocBlob	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocBlob txt <- Term.App' (Term.Constructor' DocRef DocBlobId) (Term.Text' txt)$/;"	pi	line:535	language:Haskell
DocBlobId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocBlobId <- ((== docBlobId) -> True)$/;"	pi	line:542	language:Haskell
DocDelimiter	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DocDelimiter$/;"	cons	data:Element	line:46	language:Haskell
DocEvaluate	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocEvaluate link <- Term.App' (Term.Constructor' DocRef DocEvaluateId) link$/;"	pi	line:539	language:Haskell
DocEvaluateId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocEvaluateId <- ((== docEvaluateId) -> True)$/;"	pi	line:545	language:Haskell
DocJoin	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocJoin segs <- Term.App' (Term.Constructor' DocRef DocJoinId) (Term.Sequence' segs)$/;"	pi	line:534	language:Haskell
DocJoinId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocJoinId <- ((== docJoinId) -> True)$/;"	pi	line:546	language:Haskell
DocKeyword	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | DocKeyword$/;"	cons	data:Element	line:48	language:Haskell
DocLink	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocLink link <- Term.App' (Term.Constructor' DocRef DocLinkId) link$/;"	pi	line:536	language:Haskell
DocLinkId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocLinkId <- ((== docLinkId) -> True)$/;"	pi	line:543	language:Haskell
DocLiteralContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^data DocLiteralContext$/;"	d	line:85	language:Haskell
DocRef	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocRef <- ((== docRef) -> True)$/;"	pi	line:533	language:Haskell
DocSignature	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocSignature link <- Term.App' (Term.Constructor' DocRef DocSignatureId) link$/;"	pi	line:538	language:Haskell
DocSignatureId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocSignatureId <- ((== docSignatureId) -> True)$/;"	pi	line:541	language:Haskell
DocSource	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocSource link <- Term.App' (Term.Constructor' DocRef DocSourceId) link$/;"	pi	line:537	language:Haskell
DocSourceId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern DocSourceId <- ((== docSourceId) -> True)$/;"	pi	line:544	language:Haskell
DocsI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | DocsI Path.HQSplit'$/;"	cons	data:Input	line:120	language:Haskell
Double	./unison-core/src/Unison/Hashable.hs	/^  | Double !Double$/;"	cons	data:Token	line:15	language:Haskell
DownKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | LeftKey | RightKey | DownKey | UpKey$/;"	cons	data:BaseKey	line:38	language:Haskell
Draw	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^newtype Draw m a = Draw {unDraw :: (ReaderT Actions$/;"	nt	line:104	language:Haskell
Draw	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^newtype Draw m a = Draw {runDraw :: ReaderT Handles m a}$/;"	nt	line:262	language:Haskell
DrawM	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^type DrawM a = forall m . (MonadIO m, MonadReader Layout m) => Draw m a$/;"	t	line:265	language:Haskell
DropN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddN z z | DropN z z | SubN z z | MultN z z | DivN z z$/;"	cons	data:IR'	line:213	language:Haskell
DumbTerm	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^newtype DumbTerm m a = DumbTerm {unDumbTerm :: StateT Window (PosixT m) a}$/;"	nt	line:23	language:Haskell
DumbTermM	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^type DumbTermM a = forall m . (MonadIO m, MonadReader Layout m) => DumbTerm m a$/;"	t	line:27	language:Haskell
DumpBitBooster	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DumpBitBooster Branch.Hash (Map Branch.Hash [Branch.Hash])$/;"	cons	data:Output	line:194	language:Haskell
DumpNumberedArgs	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | DumpNumberedArgs NumberedArgs$/;"	cons	data:Output	line:193	language:Haskell
DupDataAndAbility	./parser-typechecker/src/Unison/UnisonFile.hs	/^  | DupDataAndAbility v a a$/;"	cons	data:Error	line:266	language:Haskell
Duplicate	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  Add | Update | Duplicate | Collision | Conflicted |$/;"	cons	data:Status	line:128	language:Haskell
DuplicateDefinitions	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | DuplicateDefinitions (NonEmpty (v, [loc]))$/;"	cons	data:Cause	line:287	language:Haskell
DuplicateDefinitions	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | DuplicateDefinitions { defns :: NonEmpty (v, [loc])$/;"	cons	data:TypeError	line:77	language:Haskell
DuplicateTermNames	./parser-typechecker/src/Unison/Parser.hs	/^  | DuplicateTermNames [(v, [Ann])]$/;"	cons	data:Error	line:106	language:Haskell
DuplicateTypeNames	./parser-typechecker/src/Unison/Parser.hs	/^  | DuplicateTypeNames [(v, [Ann])]$/;"	cons	data:Error	line:105	language:Haskell
EasyTest	./yaks/easytest/src/EasyTest.hs	/^module EasyTest where$/;"	m	line:5	language:Haskell
EchoState	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^data EchoState$/;"	d	line:100	language:Haskell
EditHash	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^type EditHash = Hash.Hash$/;"	t	line:156	language:Haskell
EditMode	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data EditMode = Vi | Emacs$/;"	d	line:61	language:Haskell
Edits	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^data Edits v = Edits$/;"	d	line:53	language:Haskell
Edits	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^data Edits v = Edits$/;"	cons	data:Edits	line:53	language:Haskell
Effect	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Unknown = Data | Effect deriving Show$/;"	cons	data:Unknown	line:206	language:Haskell
Effect	./unison-core/src/Unison/ConstructorType.hs	/^data ConstructorType = Data | Effect deriving (Eq, Ord, Show, Enum)$/;"	cons	data:ConstructorType	line:5	language:Haskell
Effect	./unison-core/src/Unison/Type.hs	/^  | Effect a a$/;"	cons	data:F	line:46	language:Haskell
Effect	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data Effect = LineChange (Prefix -> LineChars)$/;"	d	line:38	language:Haskell
Effect'	./unison-core/src/Unison/Type.hs	/^pattern Effect' es t <- (unEffects1 -> Just (es, t))$/;"	pi	line:113	language:Haskell
Effect''	./unison-core/src/Unison/Type.hs	/^pattern Effect'' es t <- (unEffect0 -> (es, t))$/;"	pi	line:114	language:Haskell
Effect0'	./unison-core/src/Unison/Type.hs	/^pattern Effect0' es t <- (unEffect0 -> (es, t))$/;"	pi	line:116	language:Haskell
Effect1'	./unison-core/src/Unison/Type.hs	/^pattern Effect1' e t <- ABT.Tm' (Effect e t)$/;"	pi	line:112	language:Haskell
EffectBind	./unison-core/src/Unison/Pattern.hs	/^pattern EffectBind r cid ps k = EffectBindP () r cid ps k$/;"	pi	line:109	language:Haskell
EffectBind	./unison-core/src/Unison/PatternP.hs	/^pattern EffectBind loc r c args k = P.EffectBindP loc r c args k$/;"	pi	line:24	language:Haskell
EffectBindP	./unison-core/src/Unison/Pattern.hs	/^  | EffectBindP loc !Reference !Int [PatternP loc] (PatternP loc)$/;"	cons	data:PatternP	line:48	language:Haskell
EffectBindP	./unison-core/src/Unison/Pattern.hs	/^  EffectBindP _ r ctor ps k == EffectBindP _ r2 ctor2 ps2 k2 = r == r2 && ctor == ctor2 && ps == ps2 && k == k2$/;"	fi	instance:Eq (PatternP loc)	line:140	language:Haskell
EffectConstructorHadMultipleEffects	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | EffectConstructorHadMultipleEffects (Type v loc)$/;"	cons	data:CompilerBug	line:215	language:Haskell
EffectConstructorWrongArgCount	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | EffectConstructorWrongArgCount ExpectedArgCount ActualArgCount Reference ConstructorId$/;"	cons	data:Cause	line:282	language:Haskell
EffectCtor	./unison-core/src/Unison/Referent.hs	/^pattern EffectCtor = "a"$/;"	pi	line:60	language:Haskell
EffectDeclaration	./parser-typechecker/src/Unison/Builtin.hs	/^type EffectDeclaration v = EffectDeclaration' v Ann$/;"	t	line:52	language:Haskell
EffectDeclaration	./parser-typechecker/src/Unison/Codebase.hs	/^type EffectDeclaration v a = DD.EffectDeclaration' v a$/;"	t	line:45	language:Haskell
EffectDeclaration	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^type EffectDeclaration v a = DD.EffectDeclaration' v a$/;"	t	line:14	language:Haskell
EffectDeclaration	./unison-core/src/Unison/DataDeclaration.hs	/^type EffectDeclaration v = EffectDeclaration' v ()$/;"	t	line:238	language:Haskell
EffectDeclaration	./unison-core/src/Unison/DataDeclaration.hs	/^newtype EffectDeclaration' v a = EffectDeclaration {$/;"	cons	newtype:EffectDeclaration'	line:240	language:Haskell
EffectDeclaration'	./unison-core/src/Unison/DataDeclaration.hs	/^newtype EffectDeclaration' v a = EffectDeclaration {$/;"	nt	line:240	language:Haskell
EffectDeclarations	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type EffectDeclarations v loc = Map Reference (EffectDeclaration' v loc)$/;"	t	line:126	language:Haskell
EffectPure	./unison-core/src/Unison/Pattern.hs	/^pattern EffectPure p = EffectPureP () p$/;"	pi	line:108	language:Haskell
EffectPure	./unison-core/src/Unison/PatternP.hs	/^pattern EffectPure loc p = P.EffectPureP loc p$/;"	pi	line:23	language:Haskell
EffectPureP	./unison-core/src/Unison/Pattern.hs	/^  | EffectPureP loc (PatternP loc)$/;"	cons	data:PatternP	line:47	language:Haskell
EffectPureP	./unison-core/src/Unison/Pattern.hs	/^  EffectPureP _ p == EffectPureP _ q = p == q$/;"	fi	instance:Eq (PatternP loc)	line:139	language:Haskell
EffectfulArrows'	./unison-core/src/Unison/Type.hs	/^pattern EffectfulArrows' fst rest <- (unEffectfulArrows -> Just (fst, rest))$/;"	pi	line:105	language:Haskell
Effects	./unison-core/src/Unison/Type.hs	/^  | Effects [a]$/;"	cons	data:F	line:47	language:Haskell
Effects'	./unison-core/src/Unison/Type.hs	/^pattern Effects' es <- ABT.Tm' (Effects es)$/;"	pi	line:110	language:Haskell
Either	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^type Either a b = Left a | Right b$/;"	t	line:153	language:Haskell
EitherMode	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^type EitherMode = Either CommandMode InsertMode$/;"	t	line:16	language:Haskell
EitherResult	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^type EitherResult = Either String TFile$/;"	t	line:55	language:Haskell
Element	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Element v loc$/;"	d	line:110	language:Haskell
Element	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^data Element = NumericLiteral$/;"	d	line:10	language:Haskell
Emacs	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data EditMode = Vi | Emacs$/;"	cons	data:EditMode	line:61	language:Haskell
Embed	./unison-core/src/Unison/ABT.hs	/^data Component f a = Component [a] a | Embed (f a) deriving (Functor, Traversable, Foldable)$/;"	cons	data:Component	line:641	language:Haskell
Empty	./parser-typechecker/src/Unison/Codebase/Path.hs	/^pattern Empty = Path Seq.Empty$/;"	pi	line:315	language:Haskell
Empty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  = Empty | Group r | Lit s | Wrap (Seq r) | OrElse r r | Append (Seq r)$/;"	cons	data:F	line:131	language:Haskell
EmptyBlock	./parser-typechecker/src/Unison/Parser.hs	/^  | EmptyBlock (L.Token String)$/;"	cons	data:Error	line:92	language:Haskell
EmptyIfMissing	./parser-typechecker/src/Unison/Codebase/BranchLoadMode.hs	/^data BranchLoadMode = FailIfMissing | EmptyIfMissing deriving (Eq, Show)$/;"	cons	data:BranchLoadMode	line:9	language:Haskell
EmptyLetRec	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | EmptyLetRec (Term v loc) -- the body of the empty let rec$/;"	cons	data:CompilerBug	line:213	language:Haskell
EmptyWatch	./parser-typechecker/src/Unison/Parser.hs	/^  | EmptyWatch$/;"	cons	data:Error	line:99	language:Haskell
End	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | KillLine | Home | End | PageDown | PageUp$/;"	cons	data:BaseKey	line:40	language:Haskell
EndOfLog	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  EndOfLog ShortBranchHash |$/;"	cons	data:HistoryTail	line:227	language:Haskell
Entry	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^data Entry =$/;"	d	line:11	language:Haskell
Entry	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^  Entry$/;"	cons	data:Entry	line:12	language:Haskell
Env	./parser-typechecker/src/Unison/PrintError.hs	/^type Env = PPE.PrettyPrintEnv$/;"	t	line:61	language:Haskell
Env	./parser-typechecker/src/Unison/Typechecker.hs	/^data Env v loc = Env$/;"	d	line:67	language:Haskell
Env	./parser-typechecker/src/Unison/Typechecker.hs	/^data Env v loc = Env$/;"	cons	data:Env	line:67	language:Haskell
Env	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Env v loc = Env { freshId :: Word64, ctx :: Context v loc }$/;"	d	line:123	language:Haskell
Env	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Env v loc = Env { freshId :: Word64, ctx :: Context v loc }$/;"	cons	data:Env	line:123	language:Haskell
Env	./parser-typechecker/src/Unison/UnisonFile.hs	/^data Env v a = Env$/;"	d	line:253	language:Haskell
Env	./parser-typechecker/src/Unison/UnisonFile.hs	/^data Env v a = Env$/;"	cons	data:Env	line:253	language:Haskell
Env	./yaks/easytest/src/EasyTest.hs	/^data Env =$/;"	d	line:36	language:Haskell
Env	./yaks/easytest/src/EasyTest.hs	/^  Env { rng :: TVar Random.StdGen$/;"	cons	data:Env	line:37	language:Haskell
Eq (Branch0 m)	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Eq (Branch0 m) where$/;"	i	line:432	language:Haskell
Eq (Causal m h a)	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^instance Eq (Causal m h a) where$/;"	i	line:156	language:Haskell
Eq (DistinctRanged a)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Eq (DistinctRanged a) where$/;"	i	line:112	language:Haskell
Eq (PatternP loc)	./unison-core/src/Unison/Pattern.hs	/^instance Eq (PatternP loc) where$/;"	i	line:131	language:Haskell
Eq Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance Eq Bytes where$/;"	i	line:89	language:Haskell
Eq ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance Eq ExternalFunction where$/;"	i	line:100	language:Haskell
Eq Symbol	./unison-core/src/Unison/Symbol.hs	/^instance Eq Symbol where$/;"	i	line:26	language:Haskell
Eq SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Eq SymbolC where$/;"	i	line:946	language:Haskell
Eq a => Path (Maybe a)	./parser-typechecker/src/Unison/Path.hs	/^instance Eq a => Path (Maybe a) where$/;"	i	line:35	language:Haskell
Eq a => Path [a]	./parser-typechecker/src/Unison/Path.hs	/^instance Eq a => Path [a] where$/;"	i	line:42	language:Haskell
Eq v => Eq (TypeVar b v)	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^instance Eq v => Eq (TypeVar b v) where$/;"	i	line:16	language:Haskell
Eq1 F	./unison-core/src/Unison/Type.hs	/^instance Eq1 F where (==#) = (==)$/;"	i	line:54	language:Haskell
EqF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtF z z | LtF z z | GtEqF z z | LtEqF z z | EqF z z$/;"	cons	data:IR'	line:218	language:Haskell
EqI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtI z z | LtI z z | GtEqI z z | LtEqI z z | EqI z z$/;"	cons	data:IR'	line:210	language:Haskell
EqN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtN z z | LtN z z | GtEqN z z | LtEqN z z | EqN z z$/;"	cons	data:IR'	line:214	language:Haskell
EqU	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | EqU z z -- universal equality$/;"	cons	data:IR'	line:220	language:Haskell
Err	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^data Err$/;"	d	line:115	language:Haskell
Err	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^type Err = String$/;"	t	line:51	language:Haskell
Err	./parser-typechecker/src/Unison/Lexer.hs	/^data Err$/;"	d	line:27	language:Haskell
Err	./parser-typechecker/src/Unison/Lexer.hs	/^  | Err Err$/;"	cons	data:Lexeme	line:58	language:Haskell
Err	./parser-typechecker/src/Unison/Parser.hs	/^type Err v = P.ParseError (Token Input) (Error v)$/;"	t	line:48	language:Haskell
Error	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^type Error = P.Pretty P.ColorText$/;"	t	line:25	language:Haskell
Error	./parser-typechecker/src/Unison/Parser.hs	/^data Error v$/;"	d	line:89	language:Haskell
Error	./parser-typechecker/src/Unison/UnisonFile.hs	/^data Error v a$/;"	d	line:262	language:Haskell
ErrorEvent	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^  | ErrorEvent SomeException$/;"	cons	data:Event	line:121	language:Haskell
ErrorExtractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^type ErrorExtractor v loc a = Extractor (C.ErrorNote v loc) a$/;"	t	line:27	language:Haskell
ErrorNote	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data ErrorNote v loc = ErrorNote {$/;"	d	line:263	language:Haskell
ErrorNote	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data ErrorNote v loc = ErrorNote {$/;"	cons	data:ErrorNote	line:263	language:Haskell
ErrorSite	./parser-typechecker/src/Unison/PrintError.hs	/^pattern ErrorSite = Color.HiRed$/;"	pi	line:66	language:Haskell
ErrorType	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^data ErrorType = ErrorTypeTodo | ErrorTypeBug deriving Show$/;"	d	line:207	language:Haskell
ErrorTypeBug	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^data ErrorType = ErrorTypeTodo | ErrorTypeBug deriving Show$/;"	cons	data:ErrorType	line:207	language:Haskell
ErrorTypeTodo	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^data ErrorType = ErrorTypeTodo | ErrorTypeBug deriving Show$/;"	cons	data:ErrorType	line:207	language:Haskell
Eval	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Eval :: m a -> Command m i v a$/;"	c_gadt	d_gadt:Command	line:59	language:Haskell
EvalTerm	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data EvalTerm m$/;"	d	line:87	language:Haskell
Evaluate	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Evaluate :: PPE.PrettyPrintEnv$/;"	c_gadt	d_gadt:Command	line:116	language:Haskell
Evaluate1	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Evaluate1 :: PPE.PrettyPrintEnv -> Term v Ann -> Command m i v (Either Runtime.Error (Term v Ann))$/;"	c_gadt	d_gadt:Command	line:123	language:Haskell
Evaluated	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | Evaluated SourceFileContents$/;"	cons	data:Output	line:144	language:Haskell
EvaluationFailure	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | EvaluationFailure Runtime.Error$/;"	cons	data:Output	line:143	language:Haskell
Event	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^data Event$/;"	d	line:24	language:Haskell
Event	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data Event$/;"	d	line:118	language:Haskell
Exact	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data SuggestionMatch = Exact | WrongType | WrongName$/;"	cons	data:SuggestionMatch	line:249	language:Haskell
Exception Interrupt	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^instance Exception Interrupt where$/;"	i	line:99	language:Haskell
Exception UnisonRuntimeException	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^instance Exception UnisonRuntimeException$/;"	i	line:107	language:Haskell
Execute	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Execute :: PPE.PrettyPrintEnv -> UF.TypecheckedUnisonFile v Ann -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:190	language:Haskell
ExecuteI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | ExecuteI String$/;"	cons	data:Input	line:110	language:Haskell
Existential	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^pattern Existential b v = Var (TypeVar.Existential b v)$/;"	pi	line:95	language:Haskell
Existential	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^data TypeVar b v = Universal v | Existential b v deriving (Functor)$/;"	cons	data:TypeVar	line:14	language:Haskell
Existential	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  Existential _ v == Existential _ v2 = v == v2$/;"	fi	instance:Eq v => Eq (TypeVar b v)	line:18	language:Haskell
ExistentialMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data ExistentialMismatch = IfBody | VectorBody | CaseBody$/;"	d	line:22	language:Haskell
ExistentialMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | ExistentialMismatch { getExistentialMismatch :: ExistentialMismatch$/;"	cons	data:TypeError	line:38	language:Haskell
ExpectedArgCount	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type ExpectedArgCount = Int$/;"	t	line:245	language:Haskell
ExpectedBlockOpen	./parser-typechecker/src/Unison/Parser.hs	/^  | ExpectedBlockOpen String (L.Token L.Lexeme)$/;"	cons	data:Error	line:98	language:Haskell
ExpectingError	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^type ExpectingError = Bool$/;"	t	line:49	language:Haskell
External	./parser-typechecker/src/Unison/Parser.hs	/^  | External$/;"	cons	data:Ann	line:111	language:Haskell
External	./parser-typechecker/src/Unison/Parser.hs	/^  External <> a = a$/;"	fi	instance:Semigroup Ann	line:126	language:Haskell
External	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | External e$/;"	cons	data:Z	line:198	language:Haskell
External	./parser-typechecker/src/Unison/Runtime/IR.hs	/^class External e where$/;"	c	line:706	language:Haskell
External Continuation	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance External Continuation where$/;"	i	line:68	language:Haskell
External ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance External ExternalFunction where$/;"	i	line:102	language:Haskell
ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^data ExternalFunction =$/;"	d	line:98	language:Haskell
ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  ExternalFunction R.Reference (Size -> Stack -> IO Value)$/;"	cons	data:ExternalFunction	line:99	language:Haskell
ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  ExternalFunction r _ == ExternalFunction r2 _ = r == r2$/;"	fi	instance:Eq ExternalFunction	line:101	language:Haskell
ExternalHandle	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^data ExternalHandle = ExternalHandle$/;"	d	line:32	language:Haskell
ExternalHandle	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^data ExternalHandle = ExternalHandle$/;"	cons	data:ExternalHandle	line:32	language:Haskell
ExternalMode	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^data ExternalMode = CodingMode | OtherMode$/;"	d	line:37	language:Haskell
ExternalPrint	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^  | ExternalPrint String$/;"	cons	data:Event	line:122	language:Haskell
ExtraDefinition	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  ExtraDefinition | BlockedDependency$/;"	cons	data:Status	line:130	language:Haskell
Extractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^type Extractor e a = MaybeT (Reader e) a$/;"	t	line:25	language:Haskell
F	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^type F m i v = Free (Command m i v)$/;"	t	line:133	language:Haskell
F	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^type F m i v = Free (Command m i v)$/;"	t	line:51	language:Haskell
F	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
F	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  F x == F y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:93	language:Haskell
F	./parser-typechecker/src/Unison/Util/Pretty.hs	/^data F s r$/;"	d	line:130	language:Haskell
F	./unison-core/src/Unison/DataDeclaration.hs	/^data F a$/;"	d	line:273	language:Haskell
F	./unison-core/src/Unison/Term.hs	/^data F typeVar typeAnn patternAnn a$/;"	d	line:61	language:Haskell
F	./unison-core/src/Unison/Type.hs	/^data F a$/;"	d	line:41	language:Haskell
FailIfMissing	./parser-typechecker/src/Unison/Codebase/BranchLoadMode.hs	/^data BranchLoadMode = FailIfMissing | EmptyIfMissing deriving (Eq, Show)$/;"	cons	data:BranchLoadMode	line:9	language:Haskell
Failed	./yaks/easytest/src/EasyTest.hs	/^data Status = Failed | Passed !Int | Skipped | Pending$/;"	cons	data:Status	line:25	language:Haskell
FenceType	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^type FenceType = Text$/;"	t	line:54	language:Haskell
FileLocation	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | FileLocation FilePath$/;"	cons	data:OutputLocation	line:139	language:Haskell
FileOps	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data FileOps = FileOps {$/;"	d	line:70	language:Haskell
FileOps	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data FileOps = FileOps {$/;"	cons	data:FileOps	line:70	language:Haskell
FileProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^  | FileProtocol UrlPath$/;"	cons	data:GitProtocol	line:55	language:Haskell
FindAction	./unison-core/src/Unison/ABT.hs	/^data FindAction x = Found x | Prune | Continue deriving Show$/;"	d	line:509	language:Haskell
FindPatchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | FindPatchI$/;"	cons	data:Input	line:124	language:Haskell
FindShallowI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | FindShallowI Path'$/;"	cons	data:Input	line:123	language:Haskell
Float	./unison-core/src/Unison/Pattern.hs	/^pattern Float n = FloatP () n$/;"	pi	line:103	language:Haskell
Float	./unison-core/src/Unison/PatternP.hs	/^pattern Float loc n = P.FloatP loc n$/;"	pi	line:18	language:Haskell
Float	./unison-core/src/Unison/Term.hs	/^  | Float Double$/;"	cons	data:F	line:64	language:Haskell
Float	./unison-core/src/Unison/Term.hs	/^  Float x == Float y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1040	language:Haskell
Float'	./unison-core/src/Unison/Term.hs	/^pattern Float' n <- (ABT.out -> ABT.Tm (Float n))$/;"	pi	line:413	language:Haskell
FloatP	./unison-core/src/Unison/Pattern.hs	/^  | FloatP loc !Double$/;"	cons	data:PatternP	line:42	language:Haskell
FloatP	./unison-core/src/Unison/Pattern.hs	/^  FloatP _ f == FloatP _ g = f == g$/;"	fi	instance:Eq (PatternP loc)	line:137	language:Haskell
Fn	./unison-core/src/Unison/Paths.hs	/^  = Fn -- ^ Points at function in a function\/type application$/;"	cons	data:PathElement	line:33	language:Haskell
FoldHistoryResult	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^data FoldHistoryResult a = Satisfied a | Unsatisfied a deriving (Eq,Ord,Show)$/;"	d	line:341	language:Haskell
Forall	./unison-core/src/Unison/Type.hs	/^  | Forall a$/;"	cons	data:F	line:48	language:Haskell
Forall'	./unison-core/src/Unison/Type.hs	/^pattern Forall' subst <- ABT.Tm' (Forall (ABT.Abs' subst))$/;"	pi	line:117	language:Haskell
ForallNamed'	./unison-core/src/Unison/Type.hs	/^pattern ForallNamed' v body <- ABT.Tm' (Forall (ABT.out -> ABT.Abs v body))$/;"	pi	line:121	language:Haskell
ForallsNamed'	./unison-core/src/Unison/Type.hs	/^pattern ForallsNamed' vs body <- (unForalls -> Just (vs, body))$/;"	pi	line:120	language:Haskell
ForkFailure	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data ForkFailure = SrcNotFound | DestExists$/;"	d	line:438	language:Haskell
ForkLocalBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    = ForkLocalBranchI (Either ShortBranchHash Path') Path'$/;"	cons	data:Input	line:45	language:Haskell
FormClosure	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  FormClosure h _ vs == FormClosure h2 _ vs2 = h == h2 && vs == vs2$/;"	fi	instance:(Eq cont, Eq e) => Eq (UnderapplyStrategy e cont)	line:111	language:Haskell
FormClosure	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = FormClosure Hash (Term SymbolC) [Value e cont] -- head is the latest argument$/;"	cons	data:UnderapplyStrategy	line:157	language:Haskell
Format	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^data Format a = Format {$/;"	d	line:17	language:Haskell
Format	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^data Format a = Format {$/;"	cons	data:Format	line:17	language:Haskell
Forward	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data Direction = Forward | Reverse$/;"	cons	data:Direction	line:83	language:Haskell
Found	./unison-core/src/Unison/ABT.hs	/^data FindAction x = Found x | Prune | Continue deriving Show$/;"	cons	data:FindAction	line:509	language:Haskell
Free	./parser-typechecker/src/Unison/Util/Free.hs	/^data Free f a = Pure a | forall x . Bind (f x) (x -> Free f a)$/;"	d	line:13	language:Haskell
Free	./unison-core/src/Unison/ABT.hs	/^data V v = Free v | Bound v deriving (Eq,Ord,Show,Functor)$/;"	cons	data:V	line:47	language:Haskell
FreeVarsInTypeAnnotation	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | FreeVarsInTypeAnnotation (Set (TypeVar v loc))$/;"	cons	data:CompilerBug	line:216	language:Haskell
FunKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | FunKey Int$/;"	cons	data:BaseKey	line:37	language:Haskell
FunctionApplication	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | FunctionApplication { f            :: C.Term v loc$/;"	cons	data:TypeError	line:45	language:Haskell
Functor (Free f)	./parser-typechecker/src/Unison/Util/Free.hs	/^instance Functor (Free f) where$/;"	i	line:55	language:Haskell
Functor (SubseqExtractor' n)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Functor (SubseqExtractor' n) where$/;"	i	line:308	language:Haskell
Functor (TypeLookup v)	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^instance Functor (TypeLookup v) where$/;"	i	line:63	language:Haskell
Functor ArgMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Functor ArgMode where$/;"	i	line:343	language:Haskell
Functor KeyConsumed	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^instance Functor KeyConsumed where$/;"	i	line:53	language:Haskell
Functor KeyMap	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^instance Functor KeyMap where$/;"	i	line:50	language:Haskell
Functor Pretty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Functor Pretty where$/;"	i	line:127	language:Haskell
Functor Test	./yaks/easytest/src/EasyTest.hs	/^instance Functor Test where$/;"	i	line:392	language:Haskell
Functor f => Functor (MT v loc f)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Functor f => Functor (MT v loc f) where$/;"	i	line:1808	language:Haskell
Functor f => Functor (Term f v)	./unison-core/src/Unison/ABT.hs	/^instance Functor f => Functor (Term f v) where$/;"	i	line:156	language:Haskell
Functor m => Functor (PutT m)	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^instance Functor m => Functor (PutT m) where$/;"	i	line:42	language:Haskell
GUID	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^type GUID = Text$/;"	t	line:109	language:Haskell
GenerateErrors	./unison-src/parser-tests/GenerateErrors.hs	/^module GenerateErrors where$/;"	m	line:2	language:Haskell
GenericKill	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^                 | GenericKill (InsertMode -> ([Grapheme],InsertMode))$/;"	cons	data:KillHelper	line:79	language:Haskell
Get	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^type Get a = forall m . MonadGet m => m a$/;"	t	line:13	language:Haskell
GetDependents	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  GetDependents :: Reference -> Command m i v (Set Reference)$/;"	c_gadt	d_gadt:Command	line:183	language:Haskell
GetKey	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data CmdM m a   = GetKey (KeyMap (CmdM m a))$/;"	cons	data:CmdM	line:58	language:Haskell
GetKey	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    GetKey km >>= g = GetKey $ fmap (>>= g) km$/;"	fi	instance:Monad m => Monad (CmdM m)	line:75	language:Haskell
GetTermsMentioningType	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  GetTermsMentioningType :: Type v Ann -> Command m i v (Set Referent)$/;"	c_gadt	d_gadt:Command	line:186	language:Haskell
GetTermsOfType	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  GetTermsOfType :: Type v Ann -> Command m i v (Set Referent)$/;"	c_gadt	d_gadt:Command	line:185	language:Haskell
GitError	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | GitError Input GitError$/;"	cons	data:Output	line:170	language:Haskell
GitError	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^data GitError = NoGit$/;"	d	line:9	language:Haskell
GitProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data GitProtocol$/;"	d	line:51	language:Haskell
GitRepo	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^data RemoteRepo = GitRepo { url :: Text, commit :: Maybe Text }$/;"	cons	data:RemoteRepo	line:13	language:Haskell
Grapheme	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data Grapheme = Grapheme {gBaseChar :: Char,$/;"	d	line:76	language:Haskell
Grapheme	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data Grapheme = Grapheme {gBaseChar :: Char,$/;"	cons	data:Grapheme	line:76	language:Haskell
Green	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Group	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  = Empty | Group r | Lit s | Wrap (Seq r) | OrElse r r | Append (Seq r)$/;"	cons	data:F	line:131	language:Haskell
GtEqF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtF z z | LtF z z | GtEqF z z | LtEqF z z | EqF z z$/;"	cons	data:IR'	line:218	language:Haskell
GtEqI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtI z z | LtI z z | GtEqI z z | LtEqI z z | EqI z z$/;"	cons	data:IR'	line:210	language:Haskell
GtEqN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtN z z | LtN z z | GtEqN z z | LtEqN z z | EqN z z$/;"	cons	data:IR'	line:214	language:Haskell
GtF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtF z z | LtF z z | GtEqF z z | LtEqF z z | EqF z z$/;"	cons	data:IR'	line:218	language:Haskell
GtI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtI z z | LtI z z | GtEqI z z | LtEqI z z | EqI z z$/;"	cons	data:IR'	line:210	language:Haskell
GtN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtN z z | LtN z z | GtEqN z z | LtEqN z z | EqN z z$/;"	cons	data:IR'	line:214	language:Haskell
GuardMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data BooleanMismatch = CondMismatch | AndMismatch | OrMismatch | GuardMismatch$/;"	cons	data:BooleanMismatch	line:19	language:Haskell
H-Accumulate Hash	./unison-core/src/Unison/Hash.hs	/^instance H.Accumulate Hash where$/;"	i	line:36	language:Haskell
H-Hashable (PatternP p)	./unison-core/src/Unison/Pattern.hs	/^instance H.Hashable (PatternP p) where$/;"	i	line:113	language:Haskell
H-Hashable Hash	./unison-core/src/Unison/Hash.hs	/^instance H.Hashable Hash where$/;"	i	line:27	language:Haskell
H-Hashable Name	./unison-core/src/Unison/Name.hs	/^instance H.Hashable Name where$/;"	i	line:137	language:Haskell
H-Hashable NameSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^instance H.Hashable NameSegment where$/;"	i	line:21	language:Haskell
H-Hashable SeqOp	./unison-core/src/Unison/Pattern.hs	/^instance H.Hashable SeqOp where$/;"	i	line:58	language:Haskell
HD	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^data InputState = HD {forkedThread :: ThreadId,$/;"	cons	data:InputState	line:53	language:Haskell
HQSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^type HQSegment = HQ'.HashQualified' NameSegment$/;"	t	line:19	language:Haskell
HQSplit	./parser-typechecker/src/Unison/Codebase/Path.hs	/^type HQSplit = (Path, HQSegment)$/;"	t	line:76	language:Haskell
HQSplit'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^type HQSplit' = (Path', HQSegment)$/;"	t	line:79	language:Haskell
HQSplitAbsolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^type HQSplitAbsolute = (Absolute, HQSegment)$/;"	t	line:82	language:Haskell
Handle	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Handle z (IR' ann z)$/;"	cons	data:IR'	line:235	language:Haskell
Handle	./unison-core/src/Unison/Term.hs	/^  | Handle a a$/;"	cons	data:F	line:74	language:Haskell
Handle	./unison-core/src/Unison/Term.hs	/^  Handle h b == Handle h2 b2 = h == h2 && b == b2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1050	language:Haskell
Handle'	./unison-core/src/Unison/Term.hs	/^pattern Handle' h body <- (ABT.out -> ABT.Tm (Handle h body))$/;"	pi	line:430	language:Haskell
HandleMap	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^type HandleMap = Map GUID Handle$/;"	t	line:118	language:Haskell
Handler	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^type Handler = DWORD -> IO BOOL$/;"	t	line:433	language:Haskell
Handler	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^data Handler m a = forall e . Exception e => Handler (e -> m a)$/;"	d	line:114	language:Haskell
HandlerOfUnexpectedType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | HandlerOfUnexpectedType loc (Type v loc)$/;"	cons	data:Cause	line:291	language:Haskell
Handles	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^data Handles = Handles {hIn, hOut :: ExternalHandle$/;"	d	line:52	language:Haskell
Handles	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^data Handles = Handles {hIn, hOut :: ExternalHandle$/;"	cons	data:Handles	line:52	language:Haskell
Handles	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data Handles = Handles { hIn, hOut :: HANDLE }$/;"	d	line:257	language:Haskell
Handles	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data Handles = Handles { hIn, hOut :: HANDLE }$/;"	cons	data:Handles	line:257	language:Haskell
Hash	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^type Hash = Causal.RawHash Raw$/;"	t	line:155	language:Haskell
Hash	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^pattern Hash h = Causal.RawHash h$/;"	pi	line:414	language:Haskell
Hash	./parser-typechecker/src/Unison/Lexer.hs	/^  | Hash ShortHash   -- hash literals$/;"	cons	data:Lexeme	line:57	language:Haskell
Hash	./unison-core/src/Unison/Hash.hs	/^newtype Hash = Hash { toBytes :: ByteString } deriving (Eq,Ord,Generic)$/;"	nt	line:22	language:Haskell
HashAmbiguous	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | HashAmbiguous ShortHash (Set Referent)$/;"	cons	data:Output	line:108	language:Haskell
HashOnly	./unison-core/src/Unison/HashQualified.hs	/^  = NameOnly n | HashOnly ShortHash | HashQualified n ShortHash$/;"	cons	data:HashQualified'	line:24	language:Haskell
HashOrHQSplit'	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^type HashOrHQSplit' = Either ShortHash Path.HQSplit'$/;"	t	line:32	language:Haskell
HashQualified	./unison-core/src/Unison/HashQualified'.hs	/^data HashQualified' n = NameOnly n | HashQualified n ShortHash$/;"	cons	data:HashQualified'	line:20	language:Haskell
HashQualified	./unison-core/src/Unison/HashQualified.hs	/^  = NameOnly n | HashOnly ShortHash | HashQualified n ShortHash$/;"	cons	data:HashQualified'	line:24	language:Haskell
HashQualified'	./unison-core/src/Unison/HashQualified'.hs	/^data HashQualified' n = NameOnly n | HashQualified n ShortHash$/;"	d	line:20	language:Haskell
HashQualified'	./unison-core/src/Unison/HashQualified.hs	/^data HashQualified' n$/;"	d	line:23	language:Haskell
HashQualifier	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | HashQualifier$/;"	cons	data:Element	line:36	language:Haskell
Hashable	./unison-core/src/Unison/Hashable.hs	/^class Hashable t where$/;"	c	line:30	language:Haskell
Hashable ()	./unison-core/src/Unison/Hashable.hs	/^instance Hashable () where$/;"	i	line:74	language:Haskell
Hashable (Branch0 m)	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Hashable (Branch0 m) where$/;"	i	line:757	language:Haskell
Hashable (RawHash h)	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^instance Hashable (RawHash h) where$/;"	i	line:162	language:Haskell
Hashable Bool	./unison-core/src/Unison/Hashable.hs	/^instance Hashable Bool where$/;"	i	line:95	language:Haskell
Hashable ByteString	./unison-core/src/Unison/Hashable.hs	/^instance Hashable ByteString where$/;"	i	line:86	language:Haskell
Hashable Char	./unison-core/src/Unison/Hashable.hs	/^instance Hashable Char where$/;"	i	line:83	language:Haskell
Hashable ConstructorType	./unison-core/src/Unison/ConstructorType.hs	/^instance Hashable ConstructorType where$/;"	i	line:7	language:Haskell
Hashable Double	./unison-core/src/Unison/Hashable.hs	/^instance Hashable Double where$/;"	i	line:77	language:Haskell
Hashable Int64	./unison-core/src/Unison/Hashable.hs	/^instance Hashable Int64 where$/;"	i	line:92	language:Haskell
Hashable Kind	./unison-core/src/Unison/Kind.hs	/^instance Hashable Kind where$/;"	i	line:12	language:Haskell
Hashable NameEdit	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^instance Hashable NameEdit where$/;"	i	line:14	language:Haskell
Hashable Patch	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^instance Hashable Patch where$/;"	i	line:123	language:Haskell
Hashable Referent	./unison-core/src/Unison/Referent.hs	/^instance Hashable Referent where$/;"	i	line:115	language:Haskell
Hashable TermEdit	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^instance Hashable TermEdit where$/;"	i	line:28	language:Haskell
Hashable Text	./unison-core/src/Unison/Hashable.hs	/^instance Hashable Text where$/;"	i	line:80	language:Haskell
Hashable TypeEdit	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^instance Hashable TypeEdit where$/;"	i	line:14	language:Haskell
Hashable Typing	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^instance Hashable Typing where$/;"	i	line:23	language:Haskell
Hashable Word64	./unison-core/src/Unison/Hashable.hs	/^instance Hashable Word64 where$/;"	i	line:89	language:Haskell
Hashable a => Hashable [a]	./unison-core/src/Unison/Hashable.hs	/^instance Hashable a => Hashable [a] where$/;"	i	line:33	language:Haskell
Hashable-Hashable Modifier	./unison-core/src/Unison/DataDeclaration.hs	/^instance Hashable.Hashable Modifier where$/;"	i	line:296	language:Haskell
Hashable-Hashable Reference	./unison-core/src/Unison/Reference.hs	/^instance Hashable.Hashable Reference where$/;"	i	line:172	language:Haskell
Hashable1	./unison-core/src/Unison/Hashable.hs	/^class Functor f => Hashable1 f where$/;"	c	line:45	language:Haskell
Hashable1 F	./unison-core/src/Unison/DataDeclaration.hs	/^instance Hashable1 F where$/;"	i	line:280	language:Haskell
Hashable1 F	./unison-core/src/Unison/Type.hs	/^instance Hashable1 F where$/;"	i	line:586	language:Haskell
Hashed	./unison-core/src/Unison/Hashable.hs	/^  | Hashed !h$/;"	cons	data:Token	line:16	language:Haskell
HaskelineExport	./yaks/haskeline/examples/export/HaskelineExport.hs	/^module HaskelineExport where$/;"	m	line:1	language:Haskell
HiBlack|	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
HiBlue	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
HiCyan	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
HiGreen	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
HiPurple	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
HiWhite	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
HiYellow	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | HiBlack| HiRed | HiGreen | HiYellow | HiBlue | HiPurple | HiCyan | HiWhite$/;"	cons	data:Color	line:20	language:Haskell
Hidden	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data Hidden = Shown | HideOutput | HideAll$/;"	d	line:50	language:Haskell
HideAll	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data Hidden = Shown | HideOutput | HideAll$/;"	cons	data:Hidden	line:50	language:Haskell
HideNumbers	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^data ShowNumbers = ShowNumbers | HideNumbers$/;"	cons	data:ShowNumbers	line:1299	language:Haskell
HideOutput	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data Hidden = Shown | HideOutput | HideAll$/;"	cons	data:Hidden	line:50	language:Haskell
HistLog	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data HistLog = HistLog {pastHistory, futureHistory :: [[Grapheme]]}$/;"	d	line:13	language:Haskell
HistLog	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data HistLog = HistLog {pastHistory, futureHistory :: [[Grapheme]]}$/;"	cons	data:HistLog	line:13	language:Haskell
History	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | History (Maybe Int) [(ShortBranchHash, Names.Diff)] HistoryTail$/;"	cons	data:Output	line:184	language:Haskell
History	./yaks/haskeline/System/Console/Haskeline/History.hs	/^data History = History {histLines :: Seq String,$/;"	d	line:38	language:Haskell
History	./yaks/haskeline/System/Console/Haskeline/History.hs	/^data History = History {histLines :: Seq String,$/;"	cons	data:History	line:38	language:Haskell
HistoryDuplicates	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data HistoryDuplicates = AlwaysAdd | IgnoreConsecutive | IgnoreAll$/;"	d	line:64	language:Haskell
HistoryI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | HistoryI (Maybe Int) (Maybe Int) BranchId$/;"	cons	data:Input	line:108	language:Haskell
HistoryTail	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data HistoryTail =$/;"	d	line:226	language:Haskell
Home	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | KillLine | Home | End | PageDown | PageUp$/;"	cons	data:BaseKey	line:40	language:Haskell
Host	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^type Host = Text -- no port$/;"	t	line:90	language:Haskell
HostInfo	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data HostInfo = HostInfo Text (Maybe Text)$/;"	d	line:87	language:Haskell
HostInfo	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data HostInfo = HostInfo Text (Maybe Text)$/;"	cons	data:HostInfo	line:87	language:Haskell
Https	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data Scheme = Ssh | Https$/;"	cons	data:Scheme	line:79	language:Haskell
HttpsProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^  = HttpsProtocol (Maybe User) HostInfo UrlPath$/;"	cons	data:GitProtocol	line:52	language:Haskell
I	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
I	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  I x == I y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:92	language:Haskell
IMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data InsertMode = IMode [Grapheme] [Grapheme]$/;"	cons	data:InsertMode	line:188	language:Haskell
IOState	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^data IOState = IOState$/;"	d	line:111	language:Haskell
IOState	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^data IOState = IOState$/;"	cons	data:IOState	line:111	language:Haskell
IR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type IR e cont = IR' (Set Int) (Z e cont)$/;"	t	line:203	language:Haskell
IR	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type IR = IR.IR ExternalFunction Continuation$/;"	t	line:44	language:Haskell
IR'	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data IR' ann z$/;"	d	line:206	language:Haskell
Id	./unison-core/src/Unison/Reference.hs	/^data Id = Id H.Hash Pos Size deriving (Eq,Ord,Generic)$/;"	d	line:54	language:Haskell
Id	./unison-core/src/Unison/Reference.hs	/^data Id = Id H.Hash Pos Size deriving (Eq,Ord,Generic)$/;"	cons	data:Id	line:54	language:Haskell
Identifier	./parser-typechecker/src/Unison/PrintError.hs	/^pattern Identifier = Color.Bold$/;"	pi	line:69	language:Haskell
If	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | If z (IR' ann z) (IR' ann z)$/;"	cons	data:IR'	line:236	language:Haskell
If	./unison-core/src/Unison/Term.hs	/^  | If a a a$/;"	cons	data:F	line:78	language:Haskell
If	./unison-core/src/Unison/Term.hs	/^  If a b c == If a2 b2 c2 = a == a2 && b == b2 && c == c2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1054	language:Haskell
If'	./unison-core/src/Unison/Term.hs	/^pattern If' cond t f <- (ABT.out -> ABT.Tm (If cond t f))$/;"	pi	line:427	language:Haskell
IfBody	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data ExistentialMismatch = IfBody | VectorBody | CaseBody$/;"	cons	data:ExistentialMismatch	line:22	language:Haskell
IgnoreAll	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data HistoryDuplicates = AlwaysAdd | IgnoreConsecutive | IgnoreAll$/;"	cons	data:HistoryDuplicates	line:64	language:Haskell
IgnoreConsecutive	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data HistoryDuplicates = AlwaysAdd | IgnoreConsecutive | IgnoreAll$/;"	cons	data:HistoryDuplicates	line:64	language:Haskell
IllFormedType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | IllFormedType (Context v loc)$/;"	cons	data:Cause	line:278	language:Haskell
IllegalContextExtension	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | IllegalContextExtension (Context v loc) (Element v loc) String$/;"	cons	data:CompilerBug	line:223	language:Haskell
Imports	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^type Imports = Map Name Suffix$/;"	t	line:130	language:Haskell
InAndApp	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InAndApp$/;"	cons	data:PathElement	line:235	language:Haskell
InCheck	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InCheck (Term v loc) (Type v loc)$/;"	cons	data:PathElement	line:230	language:Haskell
InFunctionCall	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InFunctionCall [v] (Term v loc) (Type v loc) [Term v loc]$/;"	cons	data:PathElement	line:234	language:Haskell
InIfBody	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InIfBody loc -- location of `then` expression$/;"	cons	data:PathElement	line:238	language:Haskell
InIfCond	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InIfCond$/;"	cons	data:PathElement	line:237	language:Haskell
InInstantiateL	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InInstantiateL v (Type v loc)$/;"	cons	data:PathElement	line:231	language:Haskell
InInstantiateR	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InInstantiateR (Type v loc) v$/;"	cons	data:PathElement	line:232	language:Haskell
InMatch	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InMatch loc -- location of 1st case body$/;"	cons	data:PathElement	line:240	language:Haskell
InMatchBody	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InMatchBody$/;"	cons	data:PathElement	line:242	language:Haskell
InMatchGuard	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InMatchGuard$/;"	cons	data:PathElement	line:241	language:Haskell
InOrApp	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InOrApp$/;"	cons	data:PathElement	line:236	language:Haskell
InSubtype	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InSubtype (Type v loc) (Type v loc)$/;"	cons	data:PathElement	line:229	language:Haskell
InSynthesize	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  = InSynthesize (Term v loc)$/;"	cons	data:PathElement	line:228	language:Haskell
InSynthesizeApp	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InSynthesizeApp (Type v loc) (Term v loc) Int$/;"	cons	data:PathElement	line:233	language:Haskell
InVectorApp	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | InVectorApp loc -- location of 1st vector element$/;"	cons	data:PathElement	line:239	language:Haskell
IncomingRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | IncomingRootBranch (Set Branch.Hash)$/;"	cons	data:Event	line:26	language:Haskell
Index	./unison-core/src/Unison/Paths.hs	/^  | Index !Int -- ^ Points at the index of a vector$/;"	cons	data:PathElement	line:38	language:Haskell
Inference	./unison-core/src/Unison/Var.hs	/^  | Inference InferenceType$/;"	cons	data:Type	line:89	language:Haskell
InferenceType	./unison-core/src/Unison/Var.hs	/^data InferenceType =$/;"	d	line:108	language:Haskell
Infix	./parser-typechecker/src/Unison/TermPrinter.hs	/^  = Infix$/;"	cons	data:InfixContext	line:81	language:Haskell
InfixContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^data InfixContext$/;"	d	line:79	language:Haskell
Info	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Info v loc =$/;"	d	line:328	language:Haskell
Info	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Info { existentialVars :: Set v -- set of existentials seen so far$/;"	cons	data:Info	line:329	language:Haskell
InfoExtractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^type InfoExtractor v loc a = Extractor (C.InfoNote v loc) a$/;"	t	line:29	language:Haskell
InfoNote	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data InfoNote v loc$/;"	d	line:270	language:Haskell
Input	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Input :: Command m i v i$/;"	c_gadt	d_gadt:Command	line:63	language:Haskell
Input	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^data Input$/;"	d	line:40	language:Haskell
Input	./parser-typechecker/src/Unison/Parser.hs	/^newtype Input = Input { inputStream :: [L.Token L.Lexeme] }$/;"	nt	line:134	language:Haskell
Input	./unison-core/src/Unison/Paths.hs	/^  | Input -- ^ Points at the left of an `Arrow`$/;"	cons	data:PathElement	line:40	language:Haskell
Input	./unison-core/src/Unison/Var.hs	/^  Ability | Input | Output |$/;"	cons	data:InferenceType	line:109	language:Haskell
InputCmd	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^type InputCmd s t = forall m . MonadException m => Command (InputCmdT m) s t$/;"	t	line:15	language:Haskell
InputCmd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^type InputCmd s t = forall m . MonadException m => Command (ViT m) s t$/;"	t	line:33	language:Haskell
InputCmdT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^type InputCmdT m = StateT Layout (UndoT (StateT HistLog (ReaderT (IORef KillRing)$/;"	t	line:74	language:Haskell
InputDescription	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^type InputDescription = Text$/;"	t	line:167	language:Haskell
InputEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data InputEvent = KeyEvent {keyDown :: BOOL,$/;"	d	line:119	language:Haskell
InputKeyCmd	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^type InputKeyCmd s t = forall m . MonadException m => KeyCommand (InputCmdT m) s t$/;"	t	line:16	language:Haskell
InputKeyCmd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^type InputKeyCmd s t = forall m . MonadException m => KeyCommand (ViT m) s t$/;"	t	line:34	language:Haskell
InputPattern	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^data InputPattern = InputPattern$/;"	d	line:28	language:Haskell
InputPattern	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^data InputPattern = InputPattern$/;"	cons	data:InputPattern	line:28	language:Haskell
InputState	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^data InputState = HD {forkedThread :: ThreadId,$/;"	d	line:53	language:Haskell
InputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^newtype InputT m a = InputT {unInputT :: $/;"	nt	line:41	language:Haskell
InsertMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data InsertMode = IMode [Grapheme] [Grapheme]$/;"	d	line:188	language:Haskell
Int	./unison-core/src/Unison/Hashable.hs	/^  | Int !Int64$/;"	cons	data:Token	line:13	language:Haskell
Int	./unison-core/src/Unison/Pattern.hs	/^pattern Int n = IntP () n$/;"	pi	line:101	language:Haskell
Int	./unison-core/src/Unison/PatternP.hs	/^pattern Int loc n = P.IntP loc n$/;"	pi	line:16	language:Haskell
Int	./unison-core/src/Unison/Term.hs	/^  = Int Int64$/;"	cons	data:F	line:62	language:Haskell
Int	./unison-core/src/Unison/Term.hs	/^  Int x == Int y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1038	language:Haskell
Int'	./unison-core/src/Unison/Term.hs	/^pattern Int' n <- (ABT.out -> ABT.Tm (Int n))$/;"	pi	line:411	language:Haskell
IntP	./unison-core/src/Unison/Pattern.hs	/^  | IntP loc !Int64$/;"	cons	data:PatternP	line:40	language:Haskell
IntP	./unison-core/src/Unison/Pattern.hs	/^  IntP _ n == IntP _ m = n == m$/;"	fi	instance:Eq (PatternP loc)	line:135	language:Haskell
Interrupt	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data Interrupt = Interrupt$/;"	d	line:96	language:Haskell
Interrupt	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data Interrupt = Interrupt$/;"	cons	data:Interrupt	line:96	language:Haskell
Intrinsic	./parser-typechecker/src/Unison/Parser.hs	/^  = Intrinsic -- { sig :: String, start :: L.Pos, end :: L.Pos }$/;"	cons	data:Ann	line:110	language:Haskell
Intrinsic	./parser-typechecker/src/Unison/Parser.hs	/^  Intrinsic <> a = a$/;"	fi	instance:Semigroup Ann	line:128	language:Haskell
IntroOuter	./unison-core/src/Unison/Type.hs	/^  | IntroOuter a -- binder like â, used to introduce variables that are$/;"	cons	data:F	line:49	language:Haskell
IntroOuter'	./unison-core/src/Unison/Type.hs	/^pattern IntroOuter' subst <- ABT.Tm' (IntroOuter (ABT.Abs' subst))$/;"	pi	line:118	language:Haskell
IntroOuterNamed'	./unison-core/src/Unison/Type.hs	/^pattern IntroOuterNamed' v body <- ABT.Tm' (IntroOuter (ABT.out -> ABT.Abs v body))$/;"	pi	line:119	language:Haskell
InvalidBranchFile	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^  = InvalidBranchFile FilePath String$/;"	cons	data:Err	line:116	language:Haskell
InvalidEditsFile	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^  | InvalidEditsFile FilePath String$/;"	cons	data:Err	line:117	language:Haskell
InvalidEscapeCharacter	./parser-typechecker/src/Unison/Lexer.hs	/^  | InvalidEscapeCharacter Char$/;"	cons	data:Err	line:36	language:Haskell
InvalidPath	./parser-typechecker/src/Unison/Result.hs	/^  | InvalidPath Path (Term v loc) -- todo: move me!$/;"	cons	data:Note	line:34	language:Haskell
InvalidShortHash	./parser-typechecker/src/Unison/Lexer.hs	/^  | InvalidShortHash String$/;"	cons	data:Err	line:30	language:Haskell
InvalidSourceName	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | InvalidSourceName String$/;"	cons	data:Output	line:89	language:Haskell
InvalidSourceNameError	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^data LoadSourceResult = InvalidSourceNameError$/;"	cons	data:LoadSourceResult	line:50	language:Haskell
InvalidSymbolyId	./parser-typechecker/src/Unison/Lexer.hs	/^  | InvalidSymbolyId String$/;"	cons	data:Err	line:29	language:Haskell
InvalidWordyId	./parser-typechecker/src/Unison/Lexer.hs	/^  = InvalidWordyId String$/;"	cons	data:Err	line:28	language:Haskell
Invocation	./yaks/haskeline/tests/RunTTY.hs	/^data Invocation = Invocation {$/;"	d	line:26	language:Haskell
Invocation	./yaks/haskeline/tests/RunTTY.hs	/^data Invocation = Invocation {$/;"	cons	data:Invocation	line:26	language:Haskell
IsCacheHit	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^type IsCacheHit = Bool$/;"	t	line:37	language:Haskell
IsOptional	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^data IsOptional$/;"	d	line:21	language:Haskell
IsPastTense	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^type IsPastTense = Bool$/;"	t	line:154	language:Haskell
IsString (AnnotatedExcerpt a)	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^instance IsString (AnnotatedExcerpt a) where$/;"	i	line:199	language:Haskell
IsString (AnnotatedText a)	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^instance IsString (AnnotatedText a) where$/;"	i	line:196	language:Haskell
IsString HashQualified	./unison-core/src/Unison/HashQualified'.hs	/^instance IsString HashQualified where$/;"	i	line:114	language:Haskell
IsString Name	./unison-core/src/Unison/Name.hs	/^instance IsString Name where$/;"	i	line:134	language:Haskell
IsString NameSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^instance IsString NameSegment where$/;"	i	line:42	language:Haskell
IsString s => IsString (Pretty s)	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance IsString s => IsString (Pretty s) where$/;"	i	line:632	language:Haskell
IsTerm	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  IsTerm :: Reference -> Command m i v Bool$/;"	c_gadt	d_gadt:Command	line:177	language:Haskell
IsTop	./unison-core/src/Unison/Term.hs	/^type IsTop = Bool$/;"	t	line:103	language:Haskell
IsType	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  IsType :: Reference -> Command m i v Bool$/;"	c_gadt	d_gadt:Command	line:178	language:Haskell
IsVirtual	./parser-typechecker/src/Unison/Lexer.hs	/^type IsVirtual = Bool -- is it a virtual semi or an actual semi?$/;"	t	line:61	language:Haskell
Just	./unison-core/src/Unison/DataDeclaration.hs	/^Just okConstructorId = constructorId testResultRef "Test.Result.Ok"$/;"	fi	line:431	language:Haskell
Key	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data Key = Key Modifier BaseKey$/;"	d	line:19	language:Haskell
Key	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data Key = Key Modifier BaseKey$/;"	cons	data:Key	line:19	language:Haskell
KeyChar	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data BaseKey = KeyChar Char$/;"	cons	data:BaseKey	line:36	language:Haskell
KeyCommand	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^type KeyCommand m s t = KeyMap (Command m s t)$/;"	t	line:80	language:Haskell
KeyConsumed	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data KeyConsumed a = NotConsumed a | Consumed a$/;"	d	line:48	language:Haskell
KeyEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data InputEvent = KeyEvent {keyDown :: BOOL,$/;"	cons	data:InputEvent	line:119	language:Haskell
KeyInput	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^  | KeyInput [Key]$/;"	cons	data:Event	line:120	language:Haskell
KeyMap	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data KeyMap a = KeyMap {lookupKM :: Key -> Maybe (KeyConsumed a)}$/;"	d	line:46	language:Haskell
KeyMap	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data KeyMap a = KeyMap {lookupKM :: Key -> Maybe (KeyConsumed a)}$/;"	cons	data:KeyMap	line:46	language:Haskell
Keyword	./parser-typechecker/src/Unison/Util/Menu.hs	/^type Keyword = String$/;"	t	line:21	language:Haskell
KillHelper	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^data KillHelper = SimpleMove (InsertMode -> InsertMode)$/;"	d	line:78	language:Haskell
KillLine	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | KillLine | Home | End | PageDown | PageUp$/;"	cons	data:BaseKey	line:40	language:Haskell
KillRing	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^type KillRing = Stack [Grapheme]$/;"	t	line:30	language:Haskell
Kind	./unison-core/src/Unison/Kind.hs	/^data Kind = Star | Arrow Kind Kind deriving (Eq,Ord,Read,Show,Generic)$/;"	d	line:10	language:Haskell
L	./parser-typechecker/src/Unison/Lexer.hs	/^data T a = T a [T a] [a] | L a deriving (Functor, Foldable, Traversable)$/;"	cons	data:T	line:172	language:Haskell
LL-FoldableLL (AnnotatedText a) Char	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^instance LL.FoldableLL (AnnotatedText a) Char where$/;"	i	line:37	language:Haskell
LL-ListLike (AnnotatedText a) Char	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^instance LL.ListLike (AnnotatedText a) Char where$/;"	i	line:44	language:Haskell
LabeledDependency	./unison-core/src/Unison/LabeledDependency.hs	/^newtype LabeledDependency = X (Either Reference Referent) deriving (Eq, Ord, Show)$/;"	nt	line:13	language:Haskell
Lam	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Lam Arity (UnderapplyStrategy e cont) (IR e cont)$/;"	cons	data:Value	line:82	language:Haskell
Lam	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Lam n us _ == Lam n2 us2 _ = n == n2 && us == us2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:99	language:Haskell
Lam	./unison-core/src/Unison/Term.hs	/^  | Lam a$/;"	cons	data:F	line:81	language:Haskell
Lam	./unison-core/src/Unison/Term.hs	/^  Lam a == Lam b = a == b$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1057	language:Haskell
Lam'	./unison-core/src/Unison/Term.hs	/^pattern Lam' subst <- ABT.Tm' (Lam (ABT.Abs' subst))$/;"	pi	line:440	language:Haskell
LamNamed'	./unison-core/src/Unison/Term.hs	/^pattern LamNamed' v body <- (ABT.out -> ABT.Tm (Lam (ABT.Term _ _ (ABT.Abs v body))))$/;"	pi	line:441	language:Haskell
LamsNamed'	./unison-core/src/Unison/Term.hs	/^pattern LamsNamed' vs body <- (unLams' -> Just (vs, body))$/;"	pi	line:442	language:Haskell
LamsNamedMatch'	./unison-core/src/Unison/Term.hs	/^pattern LamsNamedMatch' vs branches <- (unLamsMatch' -> Just (vs, branches))$/;"	pi	line:446	language:Haskell
LamsNamedOpt'	./unison-core/src/Unison/Term.hs	/^pattern LamsNamedOpt' vs body <- (unLamsOpt' -> Just (vs, body))$/;"	pi	line:443	language:Haskell
LamsNamedOrDelay'	./unison-core/src/Unison/Term.hs	/^pattern LamsNamedOrDelay' vs body <- (unLamsUntilDelay' -> Just (vs, body))$/;"	pi	line:445	language:Haskell
LamsNamedPred'	./unison-core/src/Unison/Term.hs	/^pattern LamsNamedPred' vs body <- (unLamsPred' -> Just (vs, body))$/;"	pi	line:444	language:Haskell
LatestFileLocation	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | LatestFileLocation$/;"	cons	data:OutputLocation	line:138	language:Haskell
Layout	./parser-typechecker/src/Unison/Lexer.hs	/^type Layout = [(BlockName,Column)]$/;"	t	line:145	language:Haskell
Layout	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data Layout = Layout {width, height :: Int}$/;"	d	line:149	language:Haskell
Layout	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data Layout = Layout {width, height :: Int}$/;"	cons	data:Layout	line:149	language:Haskell
LayoutError	./parser-typechecker/src/Unison/Lexer.hs	/^  | LayoutError$/;"	cons	data:Err	line:37	language:Haskell
LazySlot	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | LazySlot Pos$/;"	cons	data:Z	line:196	language:Haskell
Leaf	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = Leaf z$/;"	cons	data:IR'	line:207	language:Haskell
LeftKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | LeftKey | RightKey | DownKey | UpKey$/;"	cons	data:BaseKey	line:38	language:Haskell
Len	./parser-typechecker/src/Unison/Util/Find.hs	/^type Len = Int$/;"	t	line:161	language:Haskell
Lens-Snoc Name Name NameSegment NameSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^instance Lens.Snoc Name Name NameSegment NameSegment where$/;"	i	line:45	language:Haskell
Let	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Let Symbol (IR' ann z) (IR' ann z) ann$/;"	cons	data:IR'	line:229	language:Haskell
Let	./unison-core/src/Unison/Term.hs	/^  | Let IsTop a a$/;"	cons	data:F	line:87	language:Haskell
Let	./unison-core/src/Unison/Term.hs	/^  Let _ binding body == Let _ binding2 body2 =$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1059	language:Haskell
Let1'	./unison-core/src/Unison/Term.hs	/^pattern Let1' b subst <- (unLet1 -> Just (_, b, subst))$/;"	pi	line:447	language:Haskell
Let1Named'	./unison-core/src/Unison/Term.hs	/^pattern Let1Named' v b e <- (ABT.Tm' (Let _ b (ABT.out -> ABT.Abs v e)))$/;"	pi	line:449	language:Haskell
Let1NamedTop'	./unison-core/src/Unison/Term.hs	/^pattern Let1NamedTop' top v b e <- (ABT.Tm' (Let top b (ABT.out -> ABT.Abs v e)))$/;"	pi	line:450	language:Haskell
Let1Top'	./unison-core/src/Unison/Term.hs	/^pattern Let1Top' top b subst <- (unLet1 -> Just (top, b, subst))$/;"	pi	line:448	language:Haskell
LetBlock	./parser-typechecker/src/Unison/TermPrinter.hs	/^pattern LetBlock bindings body <- (unLetBlock -> Just (bindings, body))$/;"	pi	line:1002	language:Haskell
LetRec	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | LetRec [(Symbol, IR' ann z)] (IR' ann z)$/;"	cons	data:IR'	line:230	language:Haskell
LetRec	./unison-core/src/Unison/DataDeclaration.hs	/^  | LetRec [a] a$/;"	cons	data:F	line:275	language:Haskell
LetRec	./unison-core/src/Unison/Term.hs	/^  | LetRec IsTop [a] a$/;"	cons	data:F	line:84	language:Haskell
LetRec	./unison-core/src/Unison/Term.hs	/^  LetRec _ bs body == LetRec _ bs2 body2 = bs == bs2 && body == body2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1058	language:Haskell
LetRec'	./unison-core/src/Unison/Term.hs	/^pattern LetRec' subst <- (unLetRec -> Just (_, subst))$/;"	pi	line:453	language:Haskell
LetRecNamed'	./unison-core/src/Unison/Term.hs	/^pattern LetRecNamed' bs e <- (unLetRecNamed -> Just (_,bs,e))$/;"	pi	line:452	language:Haskell
LetRecNamedAnnotated'	./unison-core/src/Unison/Term.hs	/^pattern LetRecNamedAnnotated' ann bs e <- (unLetRecNamedAnnotated -> Just (_, ann, bs,e))$/;"	pi	line:455	language:Haskell
LetRecNamedAnnotatedTop'	./unison-core/src/Unison/Term.hs	/^pattern LetRecNamedAnnotatedTop' top ann bs e <-$/;"	pi	line:456	language:Haskell
LetRecTop'	./unison-core/src/Unison/Term.hs	/^pattern LetRecTop' top subst <- (unLetRec -> Just (top, subst))$/;"	pi	line:454	language:Haskell
Lets'	./unison-core/src/Unison/Term.hs	/^pattern Lets' bs e <- (unLet -> Just (bs, e))$/;"	pi	line:451	language:Haskell
Level	./parser-typechecker/src/Unison/Util/Logger.hs	/^type Level = Int$/;"	t	line:24	language:Haskell
LexedSource	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^type LexedSource = (Text, [L.Token L.Lexeme])$/;"	t	line:48	language:Haskell
Lexeme	./parser-typechecker/src/Unison/Lexer.hs	/^data Lexeme$/;"	d	line:45	language:Haskell
LexerError	./parser-typechecker/src/Unison/PrintError.hs	/^pattern LexerError ts e <- Just (P.Tokens (firstLexerError -> Just (ts, e)))$/;"	pi	line:892	language:Haskell
Line	./parser-typechecker/src/Unison/Lexer.hs	/^type Line = Int$/;"	t	line:120	language:Haskell
LineChange	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data Effect = LineChange (Prefix -> LineChars)$/;"	cons	data:Effect	line:38	language:Haskell
LineChars	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^type LineChars = ([Grapheme],[Grapheme])$/;"	t	line:160	language:Haskell
LineEnds	./parser-typechecker/src/Unison/TermParser.hs	/^      LineEnds$/;"	cons	data:UnbreakCase	line:369	language:Haskell
LineState	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^class LineState s where$/;"	c	line:149	language:Haskell
LineState CommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance LineState CommandMode where$/;"	i	line:268	language:Haskell
LineState InsertMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance LineState InsertMode where$/;"	i	line:191	language:Haskell
LineState Message	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance LineState Message where$/;"	i	line:380	language:Haskell
LineState Password	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance LineState Password where$/;"	i	line:389	language:Haskell
LineState SearchEntry	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^instance LineState SearchEntry where$/;"	i	line:408	language:Haskell
LineState SearchMode	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^instance LineState SearchMode where$/;"	i	line:90	language:Haskell
LineState s => LineState (ArgMode s)	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance LineState s => LineState (ArgMode s) where$/;"	i	line:346	language:Haskell
Ling'	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Ling' a = Ling' a (Long' a)$/;"	t	line:57	language:Haskell
LinkFailure	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | LinkFailure Input$/;"	cons	data:Output	line:177	language:Haskell
LinkI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | LinkI [Path.HQSplit'] Path.HQSplit'$/;"	cons	data:Input	line:114	language:Haskell
LinkKeyword	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | LinkKeyword -- `typeLink` and `termLink`$/;"	cons	data:Element	line:44	language:Haskell
LinkRef	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkRef <- ((== linkRef) -> True)$/;"	pi	line:549	language:Haskell
LinkTerm	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkTerm tm <- Term.App' (Term.Constructor' LinkRef LinkTermId) tm$/;"	pi	line:550	language:Haskell
LinkTermId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkTermId <- ((== linkTermId) -> True)$/;"	pi	line:547	language:Haskell
LinkType	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkType ty <- Term.App' (Term.Constructor' LinkRef LinkTypeId) ty$/;"	pi	line:551	language:Haskell
LinkTypeId	./unison-core/src/Unison/DataDeclaration.hs	/^pattern LinkTypeId <- ((== linkTypeId) -> True)$/;"	pi	line:548	language:Haskell
LinksI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | LinksI Path.HQSplit' (Maybe String)$/;"	cons	data:Input	line:118	language:Haskell
List	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type List a = Nil | Cons a (List a)$/;"	t	line:47	language:Haskell
List'	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type List' b = Prepend b (List' b) | Empty$/;"	t	line:48	language:Haskell
List.isPrefixOf	./parser-typechecker/src/Unison/Util/Find.hs	/^  | query `List.isPrefixOf` s = Just (bonus s 2)$/;"	fi	line:66	language:Haskell
ListCompletion	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data CompletionType = ListCompletion | MenuCompletion$/;"	cons	data:CompletionType	line:54	language:Haskell
ListDetailed	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type ListDetailed = Bool$/;"	t	line:59	language:Haskell
ListEdits	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ListEdits Patch PPE.PrettyPrintEnv$/;"	cons	data:Output	line:164	language:Haskell
ListEditsI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | ListEditsI (Maybe PatchPath)$/;"	cons	data:Input	line:94	language:Haskell
ListNames	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ListNames Int -- hq length to print References$/;"	cons	data:Output	line:129	language:Haskell
ListOfDefinitions	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ListOfDefinitions PPE.PrettyPrintEnv ListDetailed [SearchResult' v Ann]$/;"	cons	data:Output	line:133	language:Haskell
ListOfLinks	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ListOfLinks PPE.PrettyPrintEnv [(HQ.HashQualified, Reference, Maybe (Type v Ann))]$/;"	cons	data:Output	line:134	language:Haskell
ListOfPatches	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ListOfPatches (Set Name)$/;"	cons	data:Output	line:136	language:Haskell
ListShallow	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ListShallow PPE.PrettyPrintEnv [ShallowListEntry v Ann]$/;"	cons	data:Output	line:135	language:Haskell
Lit	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  = Empty | Group r | Lit s | Wrap (Seq r) | OrElse r r | Append (Seq r)$/;"	cons	data:F	line:131	language:Haskell
LoadError	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^                      | LoadError$/;"	cons	data:LoadSourceResult	line:51	language:Haskell
LoadI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | LoadI (Maybe FilePath)$/;"	cons	data:Input	line:87	language:Haskell
LoadLocalBranch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadLocalBranch :: Branch.Hash -> Command m i v (Branch m)$/;"	c_gadt	d_gadt:Command	line:137	language:Haskell
LoadLocalRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadLocalRootBranch :: Command m i v (Branch m)$/;"	c_gadt	d_gadt:Command	line:134	language:Haskell
LoadPullRequest	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | LoadPullRequest RemoteNamespace RemoteNamespace Path' Path' Path'$/;"	cons	data:Output	line:94	language:Haskell
LoadPullRequestI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | LoadPullRequestI RemoteNamespace RemoteNamespace Path'$/;"	cons	data:Input	line:53	language:Haskell
LoadReflog	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadReflog :: Command m i v [Reflog.Entry]$/;"	c_gadt	d_gadt:Command	line:155	language:Haskell
LoadRemoteRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadRemoteRootBranch ::$/;"	c_gadt	d_gadt:Command	line:139	language:Haskell
LoadRemoteShortBranch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadRemoteShortBranch ::$/;"	c_gadt	d_gadt:Command	line:144	language:Haskell
LoadSource	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadSource :: SourceName -> Command m i v LoadSourceResult$/;"	c_gadt	d_gadt:Command	line:87	language:Haskell
LoadSourceResult	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^data LoadSourceResult = InvalidSourceNameError$/;"	d	line:50	language:Haskell
LoadSuccess	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^                      | LoadSuccess Text$/;"	cons	data:LoadSourceResult	line:52	language:Haskell
LoadTerm	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadTerm :: Reference.Id -> Command m i v (Maybe (Term v Ann))$/;"	c_gadt	d_gadt:Command	line:164	language:Haskell
LoadType	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadType :: Reference.Id -> Command m i v (Maybe (Decl v Ann))$/;"	c_gadt	d_gadt:Command	line:167	language:Haskell
LoadTypeOfTerm	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadTypeOfTerm :: Reference -> Command m i v (Maybe (Type v Ann))$/;"	c_gadt	d_gadt:Command	line:169	language:Haskell
LoadWatches	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  LoadWatches :: UF.WatchKind -> Set Reference -> Command m i v [(Reference, Term v Ann)]$/;"	c_gadt	d_gadt:Command	line:129	language:Haskell
LocalProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^  | LocalProtocol UrlPath$/;"	cons	data:GitProtocol	line:56	language:Haskell
Logger	./parser-typechecker/src/Unison/Util/Logger.hs	/^data Logger =$/;"	d	line:27	language:Haskell
Logger	./parser-typechecker/src/Unison/Util/Logger.hs	/^  Logger { getScope :: !Scope$/;"	cons	data:Logger	line:28	language:Haskell
Long'	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Long' a = Long' (Ling' a) | Lnong$/;"	t	line:56	language:Haskell
LoopState	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^data LoopState m v$/;"	d	line:141	language:Haskell
LoopState	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^  = LoopState$/;"	cons	data:LoopState	line:142	language:Haskell
LtEqF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtF z z | LtF z z | GtEqF z z | LtEqF z z | EqF z z$/;"	cons	data:IR'	line:218	language:Haskell
LtEqI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtI z z | LtI z z | GtEqI z z | LtEqI z z | EqI z z$/;"	cons	data:IR'	line:210	language:Haskell
LtEqN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtN z z | LtN z z | GtEqN z z | LtEqN z z | EqN z z$/;"	cons	data:IR'	line:214	language:Haskell
LtF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtF z z | LtF z z | GtEqF z z | LtEqF z z | EqF z z$/;"	cons	data:IR'	line:218	language:Haskell
LtI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtI z z | LtI z z | GtEqI z z | LtEqI z z | EqI z z$/;"	cons	data:IR'	line:210	language:Haskell
LtN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | GtN z z | LtN z z | GtEqN z z | LtEqN z z | EqN z z$/;"	cons	data:IR'	line:214	language:Haskell
M	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type M v loc = MT v loc (Result v loc)$/;"	t	line:180	language:Haskell
M	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^type M = State [[Int64]]$/;"	t	line:248	language:Haskell
MEnv	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data MEnv v loc = MEnv {$/;"	d	line:316	language:Haskell
MEnv	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data MEnv v loc = MEnv {$/;"	cons	data:MEnv	line:316	language:Haskell
MFunctor (CodeLookup v)	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^instance MFunctor (CodeLookup v) where$/;"	i	line:36	language:Haskell
MT	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^newtype MT v loc f a = MT {$/;"	nt	line:175	language:Haskell
Main	./parser-typechecker/prettyprintdemo/Main.hs	/^module Main where$/;"	m	line:3	language:Haskell
Main	./parser-typechecker/tests/Suite.hs	/^module Main where$/;"	m	line:3	language:Haskell
Main	./parser-typechecker/tests/Unison/Test/Transcripts.hs	/^module Main where$/;"	m	line:3	language:Haskell
Main	./parser-typechecker/unison/Main.hs	/^module Main where$/;"	m	line:5	language:Haskell
Main	./yaks/easytest/tests/Suite.hs	/^module Main where$/;"	m	line:1	language:Haskell
Main	./yaks/haskeline/examples/Test.hs	/^module Main where$/;"	m	line:1	language:Haskell
Main	./yaks/haskeline/tests/Unit.hs	/^module Main where$/;"	m	line:15	language:Haskell
MainTerm	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^data MainTerm v$/;"	d	line:28	language:Haskell
MakeSequence	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | MakeSequence [z]$/;"	cons	data:IR'	line:231	language:Haskell
MalformedEffectBind	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | MalformedEffectBind (Type v loc) (Type v loc) [Type v loc] -- type of ctor, type of ctor result$/;"	cons	data:Cause	line:283	language:Haskell
MalformedPattern	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | MalformedPattern (Pattern loc)$/;"	cons	data:CompilerBug	line:218	language:Haskell
Marker	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | Marker v                               -- used for scoping$/;"	cons	data:Element	line:114	language:Haskell
Marker	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Marker v == Marker v2          = v == v2$/;"	fi	instance:(Ord loc, Var v) => Eq (Element v loc)	line:120	language:Haskell
Match	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Match z [(Pattern, [Symbol], Maybe (IR' ann z), IR' ann z)]$/;"	cons	data:IR'	line:241	language:Haskell
Match	./unison-core/src/Unison/Term.hs	/^  | Match a [MatchCase patternAnn a]$/;"	cons	data:F	line:98	language:Haskell
Match	./unison-core/src/Unison/Term.hs	/^  Match scrutinee cases == Match s2 cs2 = scrutinee == s2 && cases == cs2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1061	language:Haskell
Match'	./unison-core/src/Unison/Term.hs	/^pattern Match' scrutinee branches <- (ABT.out -> ABT.Tm (Match scrutinee branches))$/;"	pi	line:423	language:Haskell
MatchCase	./unison-core/src/Unison/Term.hs	/^data MatchCase loc a = MatchCase (Pattern loc) (Maybe a) a$/;"	d	line:56	language:Haskell
MatchCase	./unison-core/src/Unison/Term.hs	/^data MatchCase loc a = MatchCase (Pattern loc) (Maybe a) a$/;"	cons	data:MatchCase	line:56	language:Haskell
MaybeDoc	./parser-typechecker/src/Unison/TermPrinter.hs	/^  | MaybeDoc$/;"	cons	data:DocLiteralContext	line:89	language:Haskell
MenuCompletion	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data CompletionType = ListCompletion | MenuCompletion$/;"	cons	data:CompletionType	line:54	language:Haskell
Merge	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | Merge { currentHash :: RawHash h$/;"	cons	data:Causal	line:69	language:Haskell
MergeAlreadyUpToDate	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | MergeAlreadyUpToDate Path' Path'$/;"	cons	data:Output	line:187	language:Haskell
MergeBuiltinsI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | MergeBuiltinsI$/;"	cons	data:Input	line:129	language:Haskell
MergeLocalBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | MergeLocalBranchI Path' Path'$/;"	cons	data:Input	line:47	language:Haskell
MergeTail	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  MergeTail ShortBranchHash [ShortBranchHash] |$/;"	cons	data:HistoryTail	line:228	language:Haskell
Message	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^newtype Message = Message {messageText :: String}$/;"	nt	line:378	language:Haskell
Metadata	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^type Metadata = Map Type (Set Value)$/;"	t	line:19	language:Haskell
MetadataDiff	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^data MetadataDiff tm =$/;"	d	line:34	language:Haskell
MetadataDiff	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  MetadataDiff { addedMetadata :: [tm]$/;"	cons	data:MetadataDiff	line:35	language:Haskell
MetadataDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type MetadataDisplay v a = SimpleTermDisplay v a$/;"	t	line:94	language:Haskell
MinTTY	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^  = MinTTY STTYSettings$/;"	cons	data:EchoState	line:101	language:Haskell
Mismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  = Mismatch { foundType    :: C.Type v loc -- overallType1$/;"	cons	data:TypeError	line:26	language:Haskell
MissingExponent	./parser-typechecker/src/Unison/Lexer.hs	/^  | MissingExponent String -- ex `1e` rather than `1e3`$/;"	cons	data:Err	line:33	language:Haskell
MissingFractional	./parser-typechecker/src/Unison/Lexer.hs	/^  | MissingFractional String -- ex `1.` rather than `1.04`$/;"	cons	data:Err	line:32	language:Haskell
MissingResult	./unison-core/src/Unison/Var.hs	/^  | MissingResult$/;"	cons	data:Type	line:91	language:Haskell
MissingThing	./parser-typechecker/src/Unison/Codebase/Editor/DisplayThing.hs	/^data DisplayThing a = BuiltinThing | MissingThing Reference.Id | RegularThing a$/;"	cons	data:DisplayThing	line:5	language:Haskell
ModI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | SignumI z | NegateI z | Truncate0I z | ModI z z$/;"	cons	data:IR'	line:211	language:Haskell
ModN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | ModN z z | ToIntN z$/;"	cons	data:IR'	line:215	language:Haskell
Modified	./unison-core/src/Unison/DataDeclaration.hs	/^  | Modified Modifier a$/;"	cons	data:F	line:277	language:Haskell
Modifier	./unison-core/src/Unison/DataDeclaration.hs	/^data Modifier = Structural | Unique Text -- | Opaque (Set Reference)$/;"	d	line:71	language:Haskell
Modifier	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data Modifier = Modifier {hasControl, hasMeta, hasShift :: Bool}$/;"	d	line:22	language:Haskell
Modifier	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data Modifier = Modifier {hasControl, hasMeta, hasShift :: Bool}$/;"	cons	data:Modifier	line:22	language:Haskell
Modify	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data DiffType a = Create a | Delete a | Modify a deriving Show$/;"	cons	data:DiffType	line:23	language:Haskell
Monad (Free f)	./parser-typechecker/src/Unison/Util/Free.hs	/^instance Monad (Free f) where$/;"	i	line:58	language:Haskell
Monad (Result v loc)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Monad (Result v loc) where$/;"	i	line:143	language:Haskell
Monad (SubseqExtractor' n)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Monad (SubseqExtractor' n) where$/;"	i	line:318	language:Haskell
Monad Test	./yaks/easytest/src/EasyTest.hs	/^instance Monad Test where$/;"	i	line:376	language:Haskell
Monad f => Applicative (MT v loc f)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Monad f => Applicative (MT v loc f) where$/;"	i	line:1804	language:Haskell
Monad f => Monad (MT v loc f)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Monad f => Monad (MT v loc f) where$/;"	i	line:1794	language:Haskell
Monad f => MonadFail-MonadFail (MT v loc f)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Monad f => MonadFail.MonadFail (MT v loc f) where$/;"	i	line:1801	language:Haskell
Monad f => MonadReader (MEnv v loc) (MT v loc f)	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instance Monad f => MonadReader (MEnv v loc) (MT v loc f) where$/;"	i	line:1811	language:Haskell
Monad m => Applicative (CmdM m)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^instance Monad m => Applicative (CmdM m) where$/;"	i	line:68	language:Haskell
Monad m => Applicative (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance Monad m => Applicative (StateT s m) where$/;"	i	line:77	language:Haskell
Monad m => Functor (CmdM m)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^instance Monad m => Functor (CmdM m) where$/;"	i	line:65	language:Haskell
Monad m => Functor (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance Monad m => Functor (StateT s m) where$/;"	i	line:74	language:Haskell
Monad m => Monad (CmdM m)	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^instance Monad m => Monad (CmdM m) where$/;"	i	line:72	language:Haskell
Monad m => Monad (PutT m)	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^instance Monad m => Monad (PutT m) where$/;"	i	line:49	language:Haskell
Monad m => Monad (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance Monad m => Monad (StateT s m) where$/;"	i	line:81	language:Haskell
Monad m => MonadPut (PutT m)	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^instance Monad m => MonadPut (PutT m) where$/;"	i	line:12	language:Haskell
Monad m => MonadReader r (ReaderT r m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance Monad m => MonadReader r (ReaderT r m) where$/;"	i	line:38	language:Haskell
Monad m => MonadReader s (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance Monad m => MonadReader s (StateT s m) where$/;"	i	line:41	language:Haskell
Monad m => MonadState s (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance Monad m => MonadState s (StateT s m) where$/;"	i	line:108	language:Haskell
Monad m => Monoid (CodeLookup v m a)	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^instance Monad m => Monoid (CodeLookup v m a) where$/;"	i	line:49	language:Haskell
Monad m => Semigroup (CodeLookup v m a)	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^instance Monad m => Semigroup (CodeLookup v m a) where$/;"	i	line:46	language:Haskell
MonadException	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^class MonadIO m => MonadException m where$/;"	c	line:65	language:Haskell
MonadException IO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance MonadException IO where$/;"	i	line:138	language:Haskell
MonadException m => CommandMonad (InputCmdT m)	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^instance MonadException m => CommandMonad (InputCmdT m) where$/;"	i	line:85	language:Haskell
MonadException m => MonadException (ListT m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance MonadException m => MonadException (ListT m) where$/;"	i	line:164	language:Haskell
MonadException m => MonadException (MaybeT m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance MonadException m => MonadException (MaybeT m) where$/;"	i	line:154	language:Haskell
MonadException m => MonadException (ReaderT r m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance MonadException m => MonadException (ReaderT r m) where$/;"	i	line:144	language:Haskell
MonadException m => MonadException (StateT s m)	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^instance MonadException m => MonadException (StateT s m) where$/;"	i	line:149	language:Haskell
MonadException m => MonadException (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance MonadException m => MonadException (StateT s m) where$/;"	i	line:126	language:Haskell
MonadFail (SubseqExtractor' n)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance MonadFail (SubseqExtractor' n) where$/;"	i	line:315	language:Haskell
MonadFail Test	./yaks/easytest/src/EasyTest.hs	/^instance MonadFail Test where$/;"	i	line:389	language:Haskell
MonadIO Test	./yaks/easytest/src/EasyTest.hs	/^instance MonadIO Test where$/;"	i	line:399	language:Haskell
MonadIO m => MonadIO (StateT s m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance MonadIO m => MonadIO (StateT s m) where$/;"	i	line:92	language:Haskell
MonadIO m => MonadState s (ReaderT (IORef s) m)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance MonadIO m => MonadState s (ReaderT (IORef s) m) where$/;"	i	line:119	language:Haskell
MonadPlus (SubseqExtractor' n)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance MonadPlus (SubseqExtractor' n) where$/;"	i	line:338	language:Haskell
MonadPlus Test	./yaks/easytest/src/EasyTest.hs	/^instance MonadPlus Test where$/;"	i	line:418	language:Haskell
MonadReader	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^class Monad m => MonadReader r m where$/;"	c	line:35	language:Haskell
MonadReader Env Test	./yaks/easytest/src/EasyTest.hs	/^instance MonadReader Env Test where$/;"	i	line:367	language:Haskell
MonadState	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^class Monad m => MonadState s m where$/;"	c	line:51	language:Haskell
MonadTrans (StateT s)	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^instance MonadTrans (StateT s) where$/;"	i	line:87	language:Haskell
MonadTrans CmdM	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^instance MonadTrans CmdM where$/;"	i	line:82	language:Haskell
MonadTrans Draw	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^instance MonadTrans Draw where$/;"	i	line:113	language:Haskell
MonadTrans Draw	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^instance MonadTrans Draw where$/;"	i	line:267	language:Haskell
MonadTrans DumbTerm	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^instance MonadTrans DumbTerm where$/;"	i	line:29	language:Haskell
MonadTrans Free	./parser-typechecker/src/Unison/Util/Free.hs	/^instance MonadTrans Free where lift = eval$/;"	i	line:68	language:Haskell
MonadTrans InputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^instance MonadTrans InputT where$/;"	i	line:55	language:Haskell
Monoid (AnnotatedText a)	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^instance Monoid (AnnotatedText a) where$/;"	i	line:34	language:Haskell
Monoid (CompilationEnv e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Monoid (CompilationEnv e cont) where$/;"	i	line:987	language:Haskell
Monoid (MetadataDiff tm)	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^instance Monoid (MetadataDiff tm) where$/;"	i	line:43	language:Haskell
Monoid (Notes v loc)	./parser-typechecker/src/Unison/Typechecker.hs	/^instance Monoid (Notes v loc) where$/;"	i	line:53	language:Haskell
Monoid (Path s t a b m)	./unison-core/src/Unison/ABT.hs	/^instance Monoid (Path s t a b m) where$/;"	i	line:64	language:Haskell
Monoid (Pretty s)	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Monoid (Pretty s) where$/;"	i	line:636	language:Haskell
Monoid (SubseqExtractor' n a)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Monoid (SubseqExtractor' n a) where$/;"	i	line:343	language:Haskell
Monoid (TypeLookup v a)	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^instance Monoid (TypeLookup v a) where$/;"	i	line:58	language:Haskell
Monoid Ann	./parser-typechecker/src/Unison/Parser.hs	/^instance Monoid Ann where$/;"	i	line:119	language:Haskell
Monoid BranchAttentions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Monoid BranchAttentions where$/;"	i	line:826	language:Haskell
Monoid BranchDiff	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Monoid BranchDiff where$/;"	i	line:197	language:Haskell
Monoid Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance Monoid Bytes where$/;"	i	line:77	language:Haskell
Monoid Delta	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Monoid Delta where$/;"	i	line:650	language:Haskell
Monoid Patch	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^instance Monoid Patch where$/;"	i	line:119	language:Haskell
Monoid PatchDiff	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^instance Monoid PatchDiff where$/;"	i	line:135	language:Haskell
Monoid Pos	./parser-typechecker/src/Unison/Lexer.hs	/^instance Monoid Pos where$/;"	i	line:127	language:Haskell
Monoid PrettyPrintEnv	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^instance Monoid PrettyPrintEnv where$/;"	i	line:115	language:Haskell
Monoid PrintAnnotation	./parser-typechecker/src/Unison/TermPrinter.hs	/^instance Monoid PrintAnnotation where$/;"	i	line:765	language:Haskell
Monoid RefCollisions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Monoid RefCollisions where$/;"	i	line:837	language:Haskell
Monoid UniqueName	./parser-typechecker/src/Unison/Parser.hs	/^instance Monoid UniqueName where$/;"	i	line:58	language:Haskell
Monotype	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type Monotype v loc = Type.Monotype (TypeVar v loc) loc$/;"	t	line:91	language:Haskell
Monotype	./unison-core/src/Unison/Type.hs	/^newtype Monotype v a = Monotype { getPolytype :: Type v a } deriving Eq$/;"	nt	line:84	language:Haskell
Move	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^class Move s where$/;"	c	line:183	language:Haskell
Move CommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Move CommandMode where$/;"	i	line:282	language:Haskell
Move InsertMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Move InsertMode where$/;"	i	line:202	language:Haskell
MoveBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | MoveBranchI (Maybe Path.Split') Path.Split'$/;"	cons	data:Input	line:72	language:Haskell
MovePatchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | MovePatchI Path.Split' Path.Split'$/;"	cons	data:Input	line:73	language:Haskell
MoveTermI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | MoveTermI Path.HQSplit' Path.Split'$/;"	cons	data:Input	line:70	language:Haskell
MoveTypeI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | MoveTypeI Path.HQSplit' Path.Split'$/;"	cons	data:Input	line:71	language:Haskell
MultF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddF z z | SubF z z | MultF z z | DivF z z$/;"	cons	data:IR'	line:217	language:Haskell
MultI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddI z z | SubI z z | MultI z z | DivI z z$/;"	cons	data:IR'	line:209	language:Haskell
MultN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddN z z | DropN z z | SubN z z | MultN z z | DivN z z$/;"	cons	data:IR'	line:213	language:Haskell
Mux	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^  Mux :: Vec Nat -> Vec (Vec a) -> Vec a$/;"	c_gadt	d_gadt:Vec	line:16	language:Haskell
N	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
N	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  N x == N y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:94	language:Haskell
Name	./parser-typechecker/src/Unison/Typechecker.hs	/^type Name = Text$/;"	t	line:42	language:Haskell
Name	./unison-core/src/Unison/Name.hs	/^newtype Name = Name { toText :: Text } deriving (Eq, Ord)$/;"	nt	line:37	language:Haskell
NameAmbiguous	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NameAmbiguous$/;"	cons	data:Output	line:104	language:Haskell
NameEdit	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^data NameEdit =$/;"	d	line:8	language:Haskell
NameEdit	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^  NameEdit { added :: Set Reference, removed :: Set Reference }$/;"	cons	data:NameEdit	line:9	language:Haskell
NameEdit	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^  NameEdit add1 del1 <> NameEdit add2 del2 = NameEdit (add1 <> add2) (del1 <> del2)$/;"	fi	instance:Semigroup NameEdit	line:12	language:Haskell
NameNotFound	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NameNotFound Path.HQSplit'$/;"	cons	data:Output	line:112	language:Haskell
NameOnly	./unison-core/src/Unison/HashQualified'.hs	/^data HashQualified' n = NameOnly n | HashQualified n ShortHash$/;"	cons	data:HashQualified'	line:20	language:Haskell
NameOnly	./unison-core/src/Unison/HashQualified.hs	/^  = NameOnly n | HashOnly ShortHash | HashQualified n ShortHash$/;"	cons	data:HashQualified'	line:24	language:Haskell
NameResolutionFailures	./parser-typechecker/src/Unison/Result.hs	/^  | NameResolutionFailures [Names.ResolutionFailure v loc]$/;"	cons	data:Note	line:33	language:Haskell
NameSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^newtype NameSegment = NameSegment { toText :: Text } deriving (Eq, Ord)$/;"	nt	line:18	language:Haskell
NamedReference	./parser-typechecker/src/Unison/Typechecker.hs	/^data NamedReference v loc =$/;"	d	line:62	language:Haskell
NamedReference	./parser-typechecker/src/Unison/Typechecker.hs	/^  NamedReference { fqn :: Name, fqnType :: Type v loc$/;"	cons	data:NamedReference	line:63	language:Haskell
Names	./unison-core/src/Unison/Names2.hs	/^data Names' n = Names$/;"	cons	data:Names'	line:69	language:Haskell
Names	./unison-core/src/Unison/Names2.hs	/^type Names = Names' HashQualified$/;"	t	line:74	language:Haskell
Names	./unison-core/src/Unison/Names3.hs	/^data Names = Names { currentNames :: Names0, oldNames :: Names0 } deriving Show$/;"	d	line:28	language:Haskell
Names	./unison-core/src/Unison/Names3.hs	/^data Names = Names { currentNames :: Names0, oldNames :: Names0 } deriving Show$/;"	cons	data:Names	line:28	language:Haskell
Names'	./unison-core/src/Unison/Names2.hs	/^data Names' n = Names$/;"	d	line:69	language:Haskell
Names0	./unison-core/src/Unison/Names2.hs	/^type Names0 = Names' Name$/;"	t	line:75	language:Haskell
Names0	./unison-core/src/Unison/Names3.hs	/^type Names0 = Unison.Names2.Names0$/;"	t	line:30	language:Haskell
NamesI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | NamesI HQ.HashQualified$/;"	cons	data:Input	line:65	language:Haskell
Namespace	./parser-typechecker/src/Unison/TermParser.hs	/^  | Namespace String [BlockElement v]$/;"	cons	data:BlockElement	line:753	language:Haskell
NamespaceSlice	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data NamespaceSlice r = NamespaceSlice {$/;"	d	line:26	language:Haskell
NamespaceSlice	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^data NamespaceSlice r = NamespaceSlice {$/;"	cons	data:NamespaceSlice	line:26	language:Haskell
Nat	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^type Nat = Word64$/;"	t	line:24	language:Haskell
Nat	./unison-core/src/Unison/Hashable.hs	/^  | Nat !Word64$/;"	cons	data:Token	line:17	language:Haskell
Nat	./unison-core/src/Unison/Pattern.hs	/^pattern Nat n = NatP () n$/;"	pi	line:102	language:Haskell
Nat	./unison-core/src/Unison/PatternP.hs	/^pattern Nat loc n = P.NatP loc n$/;"	pi	line:17	language:Haskell
Nat	./unison-core/src/Unison/Term.hs	/^  | Nat Word64$/;"	cons	data:F	line:63	language:Haskell
Nat	./unison-core/src/Unison/Term.hs	/^  Nat x == Nat y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1039	language:Haskell
Nat'	./unison-core/src/Unison/Term.hs	/^pattern Nat' n <- (ABT.out -> ABT.Tm (Nat n))$/;"	pi	line:412	language:Haskell
NatP	./unison-core/src/Unison/Pattern.hs	/^  | NatP loc !Word64$/;"	cons	data:PatternP	line:41	language:Haskell
NatP	./unison-core/src/Unison/Pattern.hs	/^  NatP _ n == NatP _ m = n == m$/;"	fi	instance:Eq (PatternP loc)	line:136	language:Haskell
NeededStack	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type NeededStack = Int$/;"	t	line:52	language:Haskell
NegateI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | SignumI z | NegateI z | Truncate0I z | ModI z z$/;"	cons	data:IR'	line:211	language:Haskell
NewlyComputed	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NewlyComputed deriving Show$/;"	cons	data:TestReportStats	line:234	language:Haskell
NoBell	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data BellStyle = NoBell | VisualBell | AudibleBell$/;"	cons	data:BellStyle	line:58	language:Haskell
NoBranchHead	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^  | NoBranchHead FilePath$/;"	cons	data:Err	line:118	language:Haskell
NoBranchWithHash	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NoBranchWithHash ShortBranchHash$/;"	cons	data:Output	line:192	language:Haskell
NoConfiguredGitUrl	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NoConfiguredGitUrl PushPull Path'$/;"	cons	data:Output	line:171	language:Haskell
NoConflictsOrEdits	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NoConflictsOrEdits$/;"	cons	data:Output	line:190	language:Haskell
NoDoc	./parser-typechecker/src/Unison/TermPrinter.hs	/^  = NoDoc$/;"	cons	data:DocLiteralContext	line:87	language:Haskell
NoExactTypeMatches	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NoExactTypeMatches$/;"	cons	data:Output	line:98	language:Haskell
NoGit	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^data GitError = NoGit$/;"	cons	data:GitError	line:9	language:Haskell
NoLocalRepoAt	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | NoLocalRepoAt FilePath$/;"	cons	data:GitError	line:11	language:Haskell
NoMainFunction	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NoMainFunction String PPE.PrettyPrintEnv [Type v Ann]$/;"	cons	data:Output	line:92	language:Haskell
NoRemoteNamespaceWithHash	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | NoRemoteNamespaceWithHash Text (Maybe Text) ShortBranchHash$/;"	cons	data:GitError	line:15	language:Haskell
NoRemoteRepoAt	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | NoRemoteRepoAt Text$/;"	cons	data:GitError	line:10	language:Haskell
NoUnisonFile	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NoUnisonFile$/;"	cons	data:Output	line:88	language:Haskell
NonInfix	./parser-typechecker/src/Unison/TermPrinter.hs	/^  | NonInfix$/;"	cons	data:InfixContext	line:82	language:Haskell
Normal	./parser-typechecker/src/Unison/TermPrinter.hs	/^  | Normal$/;"	cons	data:BlockContext	line:76	language:Haskell
Not	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Not z$/;"	cons	data:IR'	line:239	language:Haskell
NotAFunctionName	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^  = NotAFunctionName String$/;"	cons	data:MainTerm	line:29	language:Haskell
NotConsumed	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data KeyConsumed a = NotConsumed a | Consumed a$/;"	cons	data:KeyConsumed	line:48	language:Haskell
NotFound	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^  | NotFound String$/;"	cons	data:MainTerm	line:30	language:Haskell
NotFunctionApplication	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | NotFunctionApplication { f    :: C.Term v loc$/;"	cons	data:TypeError	line:55	language:Haskell
NotImplemented	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NotImplemented$/;"	cons	data:Output	line:191	language:Haskell
Note	./parser-typechecker/src/Unison/Result.hs	/^data Note v loc$/;"	d	line:31	language:Haskell
Note	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^type Note = Result.Note Symbol Parser.Ann$/;"	t	line:48	language:Haskell
Notes	./parser-typechecker/src/Unison/Typechecker.hs	/^data Notes v loc = Notes {$/;"	d	line:44	language:Haskell
Notes	./parser-typechecker/src/Unison/Typechecker.hs	/^data Notes v loc = Notes {$/;"	cons	data:Notes	line:44	language:Haskell
Notes	./parser-typechecker/src/Unison/Typechecker.hs	/^  Notes bs es is <> Notes bs' es' is' = Notes (bs <> bs') (es <> es') (is <> is')$/;"	fi	instance:Semigroup (Notes v loc)	line:51	language:Haskell
NothingToPatch	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | NothingToPatch PatchPath Path'$/;"	cons	data:Output	line:179	language:Haskell
Notify	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Notify :: Output v -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:66	language:Haskell
NotifyNumbered	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  NotifyNumbered :: NumberedOutput v -> Command m i v NumberedArgs$/;"	c_gadt	d_gadt:Command	line:67	language:Haskell
Numbered	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^type Numbered = State.State (Int, Seq.Seq String)$/;"	t	line:1205	language:Haskell
NumberedArgs	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type NumberedArgs = [String]$/;"	t	line:61	language:Haskell
NumberedOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data NumberedOutput v$/;"	d	line:70	language:Haskell
Numeric	./parser-typechecker/src/Unison/Lexer.hs	/^  | Numeric String   -- numeric literals, left unparsed$/;"	cons	data:Lexeme	line:56	language:Haskell
NumericLiteral	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^data Element = NumericLiteral$/;"	cons	data:Element	line:10	language:Haskell
One	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  = One { currentHash :: RawHash h$/;"	cons	data:Causal	line:61	language:Haskell
One	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  | One NeededStack Size Stack IR$/;"	cons	data:Continuation	line:56	language:Haskell
OnePlus	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  | OnePlus -- 1 or more, at the end$/;"	cons	data:IsOptional	line:25	language:Haskell
Open	./parser-typechecker/src/Unison/Lexer.hs	/^  = Open String      -- start of a block$/;"	cons	data:Lexeme	line:46	language:Haskell
Option	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Option a = Some a | None$/;"	t	line:44	language:Haskell
Option'	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Option' b = Nothing | Just b$/;"	t	line:45	language:Haskell
Optional	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  | Optional -- 0 or 1, at the end$/;"	cons	data:IsOptional	line:23	language:Haskell
Optional	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^type Optional a = None | Some a$/;"	t	line:155	language:Haskell
OptionalRef	./unison-core/src/Unison/DataDeclaration.hs	/^pattern OptionalRef <- (unOptionalRef -> True)$/;"	pi	line:527	language:Haskell
Or	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Or z (IR' ann z)$/;"	cons	data:IR'	line:238	language:Haskell
Or	./unison-core/src/Unison/Term.hs	/^  | Or a a$/;"	cons	data:F	line:80	language:Haskell
Or	./unison-core/src/Unison/Term.hs	/^  Or a b == Or a2 b2 = a == a2 && b == b2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1056	language:Haskell
Or'	./unison-core/src/Unison/Term.hs	/^pattern Or' x y <- (ABT.out -> ABT.Tm (Or x y))$/;"	pi	line:429	language:Haskell
OrElse	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  = Empty | Group r | Lit s | Wrap (Seq r) | OrElse r r | Append (Seq r)$/;"	cons	data:F	line:131	language:Haskell
OrMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data BooleanMismatch = CondMismatch | AndMismatch | OrMismatch | GuardMismatch$/;"	cons	data:BooleanMismatch	line:19	language:Haskell
Ord (Causal m h a)	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^instance Ord (Causal m h a) where$/;"	i	line:159	language:Haskell
Ord (DistinctRanged a)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Ord (DistinctRanged a) where$/;"	i	line:114	language:Haskell
Ord Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance Ord Bytes where$/;"	i	line:96	language:Haskell
Ord Symbol	./unison-core/src/Unison/Symbol.hs	/^instance Ord Symbol where$/;"	i	line:28	language:Haskell
Ord SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Ord SymbolC where$/;"	i	line:949	language:Haskell
Ord n => Monoid (Names' n)	./unison-core/src/Unison/Names2.hs	/^instance Ord n => Monoid (Names' n) where$/;"	i	line:325	language:Haskell
Ord n => Ord (HashQualified' n)	./unison-core/src/Unison/HashQualified'.hs	/^instance Ord n => Ord (HashQualified' n) where$/;"	i	line:109	language:Haskell
Ord n => Ord (HashQualified' n)	./unison-core/src/Unison/HashQualified.hs	/^instance Ord n => Ord (HashQualified' n) where$/;"	i	line:164	language:Haskell
Ord n => Semigroup (Names' n)	./unison-core/src/Unison/Names2.hs	/^instance Ord n => Semigroup (Names' n) where (<>) = mappend$/;"	i	line:323	language:Haskell
Ord v => Monoid (SlurpComponent v)	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^instance Ord v => Monoid (SlurpComponent v) where$/;"	i	line:37	language:Haskell
Ord v => Ord (TypeVar b v)	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^instance Ord v => Ord (TypeVar b v) where$/;"	i	line:21	language:Haskell
Ord v => Semigroup (SlurpComponent v)	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^instance Ord v => Semigroup (SlurpComponent v) where (<>) = mappend$/;"	i	line:36	language:Haskell
Ord1 F	./unison-core/src/Unison/Type.hs	/^instance Ord1 F where compare1 = compare$/;"	i	line:55	language:Haskell
Other	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | Other (C.ErrorNote v loc)$/;"	cons	data:TypeError	line:80	language:Haskell
Other	./unison-core/src/Unison/Var.hs	/^  Other$/;"	cons	data:InferenceType	line:113	language:Haskell
OtherBug	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | OtherBug String$/;"	cons	data:CompilerBug	line:224	language:Haskell
OtherEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^           | OtherEvent$/;"	cons	data:InputEvent	line:128	language:Haskell
OtherMode	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^data ExternalMode = CodingMode | OtherMode$/;"	cons	data:ExternalMode	line:37	language:Haskell
Output	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data Output v$/;"	d	line:84	language:Haskell
Output	./unison-core/src/Unison/Paths.hs	/^  | Output -- ^ Points at the right of an `Arrow`$/;"	cons	data:PathElement	line:41	language:Haskell
Output	./unison-core/src/Unison/Var.hs	/^  Ability | Input | Output |$/;"	cons	data:InferenceType	line:109	language:Haskell
OutputLocation	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^data OutputLocation$/;"	d	line:136	language:Haskell
P	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^type P = P.Parsec () Text$/;"	t	line:23	language:Haskell
P	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^type P = P.Parsec () Text$/;"	t	line:289	language:Haskell
P	./parser-typechecker/src/Unison/Parser.hs	/^type P v = P.ParsecT (Error v) Input ((->) ParsingEnv)$/;"	t	line:46	language:Haskell
P-Stream Input	./parser-typechecker/src/Unison/Parser.hs	/^instance P.Stream Input where$/;"	i	line:137	language:Haskell
PageDown	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | KillLine | Home | End | PageDown | PageUp$/;"	cons	data:BaseKey	line:40	language:Haskell
PageEnd	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  PageEnd ShortBranchHash Int -- PageEnd nextHash nextIndex$/;"	cons	data:HistoryTail	line:229	language:Haskell
PageUp	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | KillLine | Home | End | PageDown | PageUp$/;"	cons	data:BaseKey	line:40	language:Haskell
Pair	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^  Pair :: Vec a -> Vec b -> Vec (a, b)$/;"	c_gadt	d_gadt:Vec	line:14	language:Haskell
PairRef	./unison-core/src/Unison/DataDeclaration.hs	/^pattern PairRef <- (unPairRef -> True)$/;"	pi	line:526	language:Haskell
Parent	./parser-typechecker/src/Unison/Codebase/Path.hs	/^pattern Parent h t = Path (NameSegment h :<| t)$/;"	pi	line:314	language:Haskell
Parenthesis	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | Parenthesis$/;"	cons	data:Element	line:43	language:Haskell
ParseErrors	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ParseErrors Text [Parser.Err v]$/;"	cons	data:Output	line:140	language:Haskell
ParseResolutionFailures	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ParseResolutionFailures String [Names.ResolutionFailure v Ann]$/;"	cons	data:Output	line:101	language:Haskell
ParseType	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  ParseType :: Names -> LexedSource$/;"	c_gadt	d_gadt:Command	line:84	language:Haskell
Parsing	./parser-typechecker/src/Unison/Result.hs	/^  = Parsing (Parser.Err v)$/;"	cons	data:Note	line:32	language:Haskell
ParsingEnv	./parser-typechecker/src/Unison/Parser.hs	/^data ParsingEnv =$/;"	d	line:50	language:Haskell
ParsingEnv	./parser-typechecker/src/Unison/Parser.hs	/^  ParsingEnv { uniqueNames :: UniqueName$/;"	cons	data:ParsingEnv	line:51	language:Haskell
Passed	./yaks/easytest/src/EasyTest.hs	/^data Status = Failed | Passed !Int | Skipped | Pending$/;"	cons	data:Status	line:25	language:Haskell
Password	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data Password = Password {passwordState :: [Char], -- ^ reversed$/;"	d	line:386	language:Haskell
Password	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data Password = Password {passwordState :: [Char], -- ^ reversed$/;"	cons	data:Password	line:386	language:Haskell
Patch	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^data Patch = Patch$/;"	d	line:26	language:Haskell
Patch	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^data Patch = Patch$/;"	cons	data:Patch	line:26	language:Haskell
PatchAlreadyExists	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | PatchAlreadyExists Path.Split'$/;"	cons	data:Output	line:97	language:Haskell
PatchDiff	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^data PatchDiff = PatchDiff$/;"	d	line:31	language:Haskell
PatchDiff	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^data PatchDiff = PatchDiff$/;"	cons	data:PatchDiff	line:31	language:Haskell
PatchDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type PatchDisplay = (Name, P.PatchDiff)$/;"	t	line:97	language:Haskell
PatchInvolvesExternalDependents	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | PatchInvolvesExternalDependents PPE.PrettyPrintEnv (Set Reference)$/;"	cons	data:Output	line:181	language:Haskell
PatchNeedsToBeConflictFree	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | PatchNeedsToBeConflictFree$/;"	cons	data:Output	line:180	language:Haskell
PatchNotFound	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | PatchNotFound Path.Split'$/;"	cons	data:Output	line:113	language:Haskell
PatchPath	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^type PatchPath = Path.Split'$/;"	t	line:30	language:Haskell
Path	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Path = Path { toSeq :: Seq NameSegment } deriving (Eq, Ord)$/;"	nt	line:30	language:Haskell
Path	./parser-typechecker/src/Unison/Path.hs	/^class Path p where$/;"	c	line:16	language:Haskell
Path	./unison-core/src/Unison/ABT.hs	/^newtype Path s t a b m = Path { focus :: s -> Maybe (a, b -> Maybe t, m) }$/;"	nt	line:56	language:Haskell
Path	./unison-core/src/Unison/Paths.hs	/^type Path = [PathElement]$/;"	t	line:120	language:Haskell
Path ()	./parser-typechecker/src/Unison/Path.hs	/^instance Path () where$/;"	i	line:50	language:Haskell
Path'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Path' = Path' { unPath' :: Either Absolute Relative }$/;"	nt	line:34	language:Haskell
Path'	./unison-core/src/Unison/ABT.hs	/^type Path' f g m = forall a v . Var v => Path (Term f v a) (Term f (V v) a) (Term g v a) (Term g (V v) a) m$/;"	t	line:69	language:Haskell
PathElement	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data PathElement v loc$/;"	d	line:227	language:Haskell
PathElement	./unison-core/src/Unison/Paths.hs	/^data PathElement$/;"	d	line:32	language:Haskell
PathExtractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^type PathExtractor v loc a = Extractor (C.PathElement v loc) a$/;"	t	line:31	language:Haskell
Pattern	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data Pattern$/;"	d	line:178	language:Haskell
Pattern	./unison-core/src/Unison/Pattern.hs	/^type Pattern = PatternP ()$/;"	t	line:16	language:Haskell
Pattern	./unison-core/src/Unison/PatternP.hs	/^type Pattern loc = P.PatternP loc$/;"	t	line:11	language:Haskell
PatternArityMismatch	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | PatternArityMismatch loc (Type v loc) Int$/;"	cons	data:Cause	line:285	language:Haskell
PatternAs	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternAs Pattern$/;"	cons	data:Pattern	line:189	language:Haskell
PatternB	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = PatternI Int64 | PatternF Double | PatternN Word64 | PatternB Bool | PatternT Text | PatternC Char$/;"	cons	data:Pattern	line:179	language:Haskell
PatternBind	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternBind R.Reference ConstructorId [Pattern] Pattern$/;"	cons	data:Pattern	line:188	language:Haskell
PatternBindE	./unison-core/src/Unison/Var.hs	/^  PatternBindE | PatternBindV |$/;"	cons	data:InferenceType	line:111	language:Haskell
PatternBindV	./unison-core/src/Unison/Var.hs	/^  PatternBindE | PatternBindV |$/;"	cons	data:InferenceType	line:111	language:Haskell
PatternC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = PatternI Int64 | PatternF Double | PatternN Word64 | PatternB Bool | PatternT Text | PatternC Char$/;"	cons	data:Pattern	line:179	language:Haskell
PatternData	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternData R.Reference ConstructorId [Pattern]$/;"	cons	data:Pattern	line:180	language:Haskell
PatternF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = PatternI Int64 | PatternF Double | PatternN Word64 | PatternB Bool | PatternT Text | PatternC Char$/;"	cons	data:Pattern	line:179	language:Haskell
PatternI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = PatternI Int64 | PatternF Double | PatternN Word64 | PatternB Bool | PatternT Text | PatternC Char$/;"	cons	data:Pattern	line:179	language:Haskell
PatternIgnore	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternIgnore$/;"	cons	data:Pattern	line:190	language:Haskell
PatternMatchFailure	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | PatternMatchFailure$/;"	cons	data:CompilerBug	line:214	language:Haskell
PatternN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = PatternI Int64 | PatternF Double | PatternN Word64 | PatternB Bool | PatternT Text | PatternC Char$/;"	cons	data:Pattern	line:179	language:Haskell
PatternP	./unison-core/src/Unison/Pattern.hs	/^data PatternP loc$/;"	d	line:36	language:Haskell
PatternPure	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternPure Pattern$/;"	cons	data:Pattern	line:187	language:Haskell
PatternPureE	./unison-core/src/Unison/Var.hs	/^  PatternPureE | PatternPureV |$/;"	cons	data:InferenceType	line:110	language:Haskell
PatternPureV	./unison-core/src/Unison/Var.hs	/^  PatternPureE | PatternPureV |$/;"	cons	data:InferenceType	line:110	language:Haskell
PatternSequenceConcat	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternSequenceConcat (Either Int Int) Pattern Pattern$/;"	cons	data:Pattern	line:186	language:Haskell
PatternSequenceCons	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternSequenceCons Pattern Pattern$/;"	cons	data:Pattern	line:182	language:Haskell
PatternSequenceLiteral	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternSequenceLiteral [Pattern]$/;"	cons	data:Pattern	line:181	language:Haskell
PatternSequenceSnoc	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternSequenceSnoc Pattern Pattern$/;"	cons	data:Pattern	line:183	language:Haskell
PatternT	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = PatternI Int64 | PatternF Double | PatternN Word64 | PatternB Bool | PatternT Text | PatternC Char$/;"	cons	data:Pattern	line:179	language:Haskell
PatternVar	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | PatternVar deriving (Eq,Show)$/;"	cons	data:Pattern	line:191	language:Haskell
Pending	./yaks/easytest/src/EasyTest.hs	/^data Status = Failed | Passed !Int | Skipped | Pending$/;"	cons	data:Status	line:25	language:Haskell
Ping	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Ping a = Ping a (Pong a)$/;"	t	line:53	language:Haskell
Placeholder	./unison-core/src/Unison/Blank.hs	/^  = Placeholder loc String$/;"	cons	data:Recorded	line:16	language:Haskell
Pong	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type Pong a = Pnong | Pong (Ping a)$/;"	t	line:54	language:Haskell
PopBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PopBranchI$/;"	cons	data:Input	line:59	language:Haskell
Pos	./parser-typechecker/src/Unison/Codecs.hs	/^type Pos = Word64$/;"	t	line:35	language:Haskell
Pos	./parser-typechecker/src/Unison/Lexer.hs	/^data Pos = Pos {-# Unpack #-} !Line {-# Unpack #-} !Column deriving (Eq,Ord,Show)$/;"	d	line:123	language:Haskell
Pos	./parser-typechecker/src/Unison/Lexer.hs	/^data Pos = Pos {-# Unpack #-} !Line {-# Unpack #-} !Column deriving (Eq,Ord,Show)$/;"	cons	data:Pos	line:123	language:Haskell
Pos	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type Pos = Int$/;"	t	line:46	language:Haskell
Pos	./parser-typechecker/src/Unison/Util/Find.hs	/^type Pos = Int$/;"	t	line:160	language:Haskell
Pos	./unison-core/src/Unison/Reference.hs	/^type Pos = Word64$/;"	t	line:110	language:Haskell
Pos	./unison-core/src/Unison/Referent.hs	/^type Pos = Word64$/;"	t	line:32	language:Haskell
PosixT	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^type PosixT m = ReaderT Handles m$/;"	t	line:304	language:Haskell
Prefix	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^type Prefix = [Text]$/;"	t	line:127	language:Haskell
Prefix	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^type Prefix = [Grapheme]$/;"	t	line:156	language:Haskell
Prefs	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data Prefs = Prefs { bellStyle :: !BellStyle,$/;"	d	line:32	language:Haskell
Prefs	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data Prefs = Prefs { bellStyle :: !BellStyle,$/;"	cons	data:Prefs	line:32	language:Haskell
Pretty	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^type Pretty = P.Pretty P.ColorText$/;"	t	line:26	language:Haskell
Pretty	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^type Pretty = P.Pretty P.ColorText$/;"	t	line:115	language:Haskell
Pretty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^data Pretty s = Pretty { delta :: Delta, out :: F s (Pretty s) } deriving Eq$/;"	d	line:125	language:Haskell
Pretty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^data Pretty s = Pretty { delta :: Delta, out :: F s (Pretty s) } deriving Eq$/;"	cons	data:Pretty	line:125	language:Haskell
PrettyPrintEnv	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^data PrettyPrintEnv = PrettyPrintEnv {$/;"	d	line:23	language:Haskell
PrettyPrintEnv	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^data PrettyPrintEnv = PrettyPrintEnv {$/;"	cons	data:PrettyPrintEnv	line:23	language:Haskell
PrettyPrintEnvDecl	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^data PrettyPrintEnvDecl = PrettyPrintEnvDecl {$/;"	d	line:57	language:Haskell
PrettyPrintEnvDecl	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^data PrettyPrintEnvDecl = PrettyPrintEnvDecl {$/;"	cons	data:PrettyPrintEnvDecl	line:57	language:Haskell
PreviewAddI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PreviewAddI [HQ'.HashQualified]$/;"	cons	data:Input	line:89	language:Haskell
PreviewMergeAlreadyUpToDate	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | PreviewMergeAlreadyUpToDate Path' Path'$/;"	cons	data:Output	line:188	language:Haskell
PreviewMergeLocalBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PreviewMergeLocalBranchI Path' Path'$/;"	cons	data:Input	line:48	language:Haskell
PreviewUpdateI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PreviewUpdateI [HQ'.HashQualified]$/;"	cons	data:Input	line:91	language:Haskell
PrintAnnotation	./parser-typechecker/src/Unison/TermPrinter.hs	/^data PrintAnnotation = PrintAnnotation$/;"	d	line:753	language:Haskell
PrintAnnotation	./parser-typechecker/src/Unison/TermPrinter.hs	/^data PrintAnnotation = PrintAnnotation$/;"	cons	data:PrintAnnotation	line:753	language:Haskell
PrintLines	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^              | PrintLines [String]$/;"	cons	data:Effect	line:39	language:Haskell
PropagatePatchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PropagatePatchI PatchPath Path'$/;"	cons	data:Input	line:93	language:Haskell
Prune	./unison-core/src/Unison/ABT.hs	/^data FindAction x = Found x | Prune | Continue deriving Show$/;"	cons	data:FindAction	line:509	language:Haskell
Pty	./yaks/haskeline/tests/Pty.hs	/^module Pty (runCommandInPty) where$/;"	m	line:9	language:Haskell
Pull	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data PushPull = Push | Pull deriving (Eq, Ord, Show)$/;"	cons	data:PushPull	line:63	language:Haskell
PullAlreadyUpToDate	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | PullAlreadyUpToDate RemoteNamespace Path'$/;"	cons	data:Output	line:186	language:Haskell
PullRemoteBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PullRemoteBranchI (Maybe RemoteNamespace) Path'$/;"	cons	data:Input	line:50	language:Haskell
Pure	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Pure (Value e cont)$/;"	cons	data:Value	line:86	language:Haskell
Pure	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Pure x == Pure y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:103	language:Haskell
Pure	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  = Pure a$/;"	cons	data:Ranged	line:65	language:Haskell
Pure	./parser-typechecker/src/Unison/Util/Free.hs	/^data Free f a = Pure a | forall x . Bind (f x) (x -> Free f a)$/;"	cons	data:Free	line:13	language:Haskell
Pure	./parser-typechecker/src/Unison/Util/Free.hs	/^  Pure a >>= f = f a$/;"	fi	instance:Monad (Free f)	line:60	language:Haskell
Pure'	./unison-core/src/Unison/Type.hs	/^pattern Pure' t <- (unPure -> Just t)$/;"	pi	line:109	language:Haskell
Purple	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Push	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data PushPull = Push | Pull deriving (Eq, Ord, Show)$/;"	cons	data:PushPull	line:63	language:Haskell
PushDestinationHasNewStuff	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | PushDestinationHasNewStuff Text (Maybe Text) Names.Diff$/;"	cons	data:GitError	line:14	language:Haskell
PushPull	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data PushPull = Push | Pull deriving (Eq, Ord, Show)$/;"	d	line:63	language:Haskell
PushRemoteBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | PushRemoteBranchI (Maybe RemoteHead) Path'$/;"	cons	data:Input	line:51	language:Haskell
Put	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^type Put a = forall m . MonadPut m => a -> m ()$/;"	t	line:14	language:Haskell
PutDecl	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  PutDecl :: Reference.Id -> Decl v Ann -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:173	language:Haskell
PutT	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^newtype PutT m a = PutT { unPutT :: m (PutM a) }$/;"	nt	line:10	language:Haskell
PutTerm	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  PutTerm :: Reference.Id -> Term v Ann -> Type v Ann -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:171	language:Haskell
PutWatch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  PutWatch :: UF.WatchKind -> Reference.Id -> Term v Ann -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:126	language:Haskell
QuitI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | QuitI$/;"	cons	data:Input	line:132	language:Haskell
R4	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^type R4 a n = R4.Relation4 a n Type Value$/;"	t	line:26	language:Haskell
RDone	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  | RDone Value$/;"	cons	data:Result	line:212	language:Haskell
RError	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  | RError ErrorType Value$/;"	cons	data:Result	line:213	language:Haskell
RMatchFail	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  | RMatchFail Size [Value] Value$/;"	cons	data:Result	line:211	language:Haskell
RRequest	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  = RRequest Req$/;"	cons	data:Result	line:210	language:Haskell
Range	./parser-typechecker/src/Unison/Util/Range.hs	/^data Range = Range { start :: Pos, end :: Pos } deriving (Eq, Ord, Show)$/;"	d	line:18	language:Haskell
Range	./parser-typechecker/src/Unison/Util/Range.hs	/^data Range = Range { start :: Pos, end :: Pos } deriving (Eq, Ord, Show)$/;"	cons	data:Range	line:18	language:Haskell
Ranged	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^data Ranged a$/;"	d	line:64	language:Haskell
Ranged	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  | Ranged { get :: a, start :: Int, end :: Int }$/;"	cons	data:Ranged	line:66	language:Haskell
Raw	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Raw = Raw$/;"	d	line:202	language:Haskell
Raw	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Raw = Raw$/;"	cons	data:Raw	line:202	language:Haskell
Raw	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^data Raw h e$/;"	d	line:97	language:Haskell
RawCons	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | RawCons e (RawHash h)$/;"	cons	data:Raw	line:99	language:Haskell
RawHash	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^newtype RawHash a = RawHash { unRawHash :: Hash }$/;"	nt	line:46	language:Haskell
RawMerge	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | RawMerge e (Set (RawHash h))$/;"	cons	data:Raw	line:100	language:Haskell
RawOne	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  = RawOne e$/;"	cons	data:Raw	line:98	language:Haskell
Recorded	./unison-core/src/Unison/Blank.hs	/^data Recorded loc$/;"	d	line:14	language:Haskell
Recorded	./unison-core/src/Unison/Blank.hs	/^data Blank loc = Blank | Recorded (Recorded loc)$/;"	cons	data:Blank	line:21	language:Haskell
Red	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
RedundantTypeAnnotation	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type RedundantTypeAnnotation = Bool$/;"	t	line:92	language:Haskell
RedundantTypeAnnotation	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^type RedundantTypeAnnotation = Bool$/;"	t	line:23	language:Haskell
RedundantTypeAnnotation	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^type RedundantTypeAnnotation = Bool$/;"	t	line:83	language:Haskell
Ref	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Ref RefID Symbol (IORef (Value e cont))$/;"	cons	data:Value	line:85	language:Haskell
Ref	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Ref _ _ io1 == Ref _ _ io2 = io1 == io2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:102	language:Haskell
Ref	./unison-core/src/Unison/Referent.hs	/^pattern Ref :: Reference -> Referent$/;"	pt	signature:(Reference -> Referent)	line:23	language:Haskell
Ref	./unison-core/src/Unison/Term.hs	/^  | Ref Reference$/;"	cons	data:F	line:69	language:Haskell
Ref	./unison-core/src/Unison/Term.hs	/^  Ref x == Ref y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1045	language:Haskell
Ref	./unison-core/src/Unison/Type.hs	/^  = Ref Reference$/;"	cons	data:F	line:42	language:Haskell
Ref'	./unison-core/src/Unison/Referent.hs	/^data Referent' r = Ref' r | Con' r Int ConstructorType$/;"	cons	data:Referent'	line:29	language:Haskell
Ref'	./unison-core/src/Unison/Term.hs	/^pattern Ref' r <- (ABT.out -> ABT.Tm (Ref r))$/;"	pi	line:418	language:Haskell
Ref'	./unison-core/src/Unison/Type.hs	/^pattern Ref' r <- ABT.Tm' (Ref r)$/;"	pi	line:102	language:Haskell
RefCollisions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data RefCollisions =$/;"	d	line:830	language:Haskell
RefCollisions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  RefCollisions { termCollisions :: Relation Name Name$/;"	cons	data:RefCollisions	line:831	language:Haskell
RefID	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type RefID = Int$/;"	t	line:76	language:Haskell
Reference	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | Reference$/;"	cons	data:Element	line:16	language:Haskell
Reference	./unison-core/src/Unison/Reference.hs	/^data Reference$/;"	d	line:41	language:Haskell
Referent	./unison-core/src/Unison/Referent.hs	/^type Referent = Referent' Reference$/;"	t	line:22	language:Haskell
Referent'	./unison-core/src/Unison/Referent.hs	/^data Referent' r = Ref' r | Con' r Int ConstructorType$/;"	d	line:29	language:Haskell
ReflogEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data ReflogEntry =$/;"	d	line:197	language:Haskell
ReflogEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  ReflogEntry { hash :: ShortBranchHash, reason :: Text }$/;"	cons	data:ReflogEntry	line:198	language:Haskell
RegularThing	./parser-typechecker/src/Unison/Codebase/Editor/DisplayThing.hs	/^data DisplayThing a = BuiltinThing | MissingThing Reference.Id | RegularThing a$/;"	cons	data:DisplayThing	line:5	language:Haskell
RegularWatch	./parser-typechecker/src/Unison/UnisonFile.hs	/^pattern RegularWatch = Var.RegularWatch$/;"	pi	line:59	language:Haskell
RegularWatch	./unison-core/src/Unison/Var.hs	/^pattern RegularWatch = ""$/;"	pi	line:105	language:Haskell
Relation	./unison-core/src/Unison/Util/Relation.hs	/^data Relation a b  = Relation { domain ::  M.Map a (Set b)$/;"	d	line:33	language:Haskell
Relation	./unison-core/src/Unison/Util/Relation.hs	/^data Relation a b  = Relation { domain ::  M.Map a (Set b)$/;"	cons	data:Relation	line:33	language:Haskell
Relation3	./unison-core/src/Unison/Util/Relation3.hs	/^data Relation3 a b c$/;"	d	line:14	language:Haskell
Relation3	./unison-core/src/Unison/Util/Relation3.hs	/^  = Relation3$/;"	cons	data:Relation3	line:15	language:Haskell
Relation4	./unison-core/src/Unison/Util/Relation4.hs	/^data Relation4 a b c d$/;"	d	line:18	language:Haskell
Relation4	./unison-core/src/Unison/Util/Relation4.hs	/^  = Relation4$/;"	cons	data:Relation4	line:19	language:Haskell
Relative	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Relative = Relative { unrelative :: Path } deriving (Eq,Ord)$/;"	nt	line:33	language:Haskell
RemoteHead	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^type RemoteHead = (RemoteRepo, Path)$/;"	t	line:29	language:Haskell
RemoteNamespace	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^type RemoteNamespace = (RemoteRepo, Maybe ShortBranchHash, Path)$/;"	t	line:28	language:Haskell
RemoteNamespaceHashAmbiguous	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | RemoteNamespaceHashAmbiguous Text (Maybe Text) ShortBranchHash (Set Branch.Hash)$/;"	cons	data:GitError	line:16	language:Haskell
RemoteRepo	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^data RemoteRepo = GitRepo { url :: Text, commit :: Maybe Text }$/;"	d	line:13	language:Haskell
RemoveTermReplacementI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | RemoveTermReplacementI PatchPath Reference Reference$/;"	cons	data:Input	line:100	language:Haskell
RemoveTypeReplacementI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | RemoveTypeReplacementI PatchPath Reference Reference$/;"	cons	data:Input	line:101	language:Haskell
RemovedTermDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type RemovedTermDisplay v a = ([HashQualified], Referent, Maybe (Type v a))$/;"	t	line:85	language:Haskell
RemovedTypeDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type RemovedTypeDisplay v a = ([HashQualified], Reference, Maybe (DeclOrBuiltin v a))$/;"	t	line:86	language:Haskell
Rename	./parser-typechecker/src/Unison/Builtin.hs	/^  | Rename Text Text$/;"	cons	data:BuiltinDSL	line:191	language:Haskell
Rename'	./parser-typechecker/src/Unison/Builtin.hs	/^data BuiltinTypeDSL = B' Text CT.ConstructorType | D' Text | Rename' Text Text | Alias' Text Text$/;"	cons	data:BuiltinTypeDSL	line:180	language:Haskell
RenameTermDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type RenameTermDisplay v a = (Referent, Maybe (Type v a), Set HashQualified, Set HashQualified)$/;"	t	line:95	language:Haskell
RenameTypeDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type RenameTypeDisplay v a = (Reference, Maybe (DeclOrBuiltin v a), Set HashQualified, Set HashQualified)$/;"	t	line:96	language:Haskell
Replace	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data TermEdit = Replace Reference Typing | Deprecate$/;"	cons	data:TermEdit	line:10	language:Haskell
Replace	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^data TypeEdit = Replace Reference | Deprecate$/;"	cons	data:TypeEdit	line:7	language:Haskell
ReplaceTermI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | ReplaceTermI HashOrHQSplit' HashOrHQSplit' (Maybe PatchPath)$/;"	cons	data:Input	line:102	language:Haskell
ReplaceTypeI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | ReplaceTypeI HashOrHQSplit' HashOrHQSplit' (Maybe PatchPath)$/;"	cons	data:Input	line:103	language:Haskell
Req	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data Req e cont = Req R.Reference ConstructorId [Value e cont] cont$/;"	d	line:389	language:Haskell
Req	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data Req e cont = Req R.Reference ConstructorId [Value e cont] cont$/;"	cons	data:Req	line:389	language:Haskell
Req	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type Req = IR.Req ExternalFunction Continuation$/;"	t	line:45	language:Haskell
Request	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Request R.Reference ConstructorId [z]$/;"	cons	data:IR'	line:234	language:Haskell
Request	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | Request$/;"	cons	data:Element	line:18	language:Haskell
Request	./unison-core/src/Unison/Term.hs	/^  | Request Reference Int$/;"	cons	data:F	line:73	language:Haskell
Request	./unison-core/src/Unison/Term.hs	/^  Request r cid == Request r2 cid2 = r == r2 && cid == cid2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1049	language:Haskell
Request	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^data Request = forall a . Request (InputT IO a) (MVar a)$/;"	d	line:51	language:Haskell
Request'	./unison-core/src/Unison/Term.hs	/^pattern Request' ref n <- (ABT.out -> ABT.Tm (Request ref n))$/;"	pi	line:425	language:Haskell
RequestOrCtor'	./unison-core/src/Unison/Term.hs	/^pattern RequestOrCtor' ref n <- (unReqOrCtor -> Just (ref, n))$/;"	pi	line:426	language:Haskell
Requested	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Requested (Req e cont)$/;"	cons	data:Value	line:87	language:Haskell
Requested	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Requested r1 == Requested r2 = r1 == r2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:104	language:Haskell
Required	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  = Required -- 1, at the start$/;"	cons	data:IsOptional	line:22	language:Haskell
Reserved	./parser-typechecker/src/Unison/Lexer.hs	/^  | Reserved String  -- reserved tokens such as `{`, `(`, `type`, `of`, etc$/;"	cons	data:Lexeme	line:49	language:Haskell
ResetRootI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | ResetRootI (Either ShortBranchHash Path')$/;"	cons	data:Input	line:54	language:Haskell
Resolution	./parser-typechecker/src/Unison/Typechecker.hs	/^data Resolution v loc =$/;"	d	line:167	language:Haskell
Resolution	./parser-typechecker/src/Unison/Typechecker.hs	/^  Resolution { resolvedName :: Text$/;"	cons	data:Resolution	line:168	language:Haskell
ResolutionFailure	./unison-core/src/Unison/Names3.hs	/^data ResolutionFailure v a$/;"	d	line:33	language:Haskell
ResolutionFailures	./parser-typechecker/src/Unison/Parser.hs	/^  | ResolutionFailures [Names.ResolutionFailure v Ann]$/;"	cons	data:Error	line:104	language:Haskell
ResolutionResult	./unison-core/src/Unison/Names3.hs	/^type ResolutionResult v a r = Either (Seq (ResolutionFailure v a)) r$/;"	t	line:38	language:Haskell
Resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^class Resolve l r o where$/;"	c	line:378	language:Haskell
Resolve	./unison-core/src/Unison/Blank.hs	/^  | Resolve loc String$/;"	cons	data:Recorded	line:18	language:Haskell
Resolve Absolute HQSplit HQSplitAbsolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Absolute HQSplit HQSplitAbsolute where$/;"	i	line:401	language:Haskell
Resolve Absolute Path' Absolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Absolute Path' Absolute where$/;"	i	line:404	language:Haskell
Resolve Absolute Relative Absolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Absolute Relative Absolute where$/;"	i	line:387	language:Haskell
Resolve Path Path Path	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Path Path Path where$/;"	i	line:381	language:Haskell
Resolve Path' Path' Path'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Path' Path' Path' where$/;"	i	line:390	language:Haskell
Resolve Path' Split' Path'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Path' Split' Path' where$/;"	i	line:395	language:Haskell
Resolve Path' Split' Split'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Path' Split' Split' where$/;"	i	line:398	language:Haskell
Resolve Relative Relative Relative	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Resolve Relative Relative Relative where$/;"	i	line:384	language:Haskell
ResolveTermNameI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | ResolveTermNameI Path.HQSplit'$/;"	cons	data:Input	line:84	language:Haskell
ResolveTypeNameI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | ResolveTypeNameI Path.HQSplit'$/;"	cons	data:Input	line:85	language:Haskell
ResolvedNameNotFound	./parser-typechecker/src/Unison/Result.hs	/^  | ResolvedNameNotFound v loc Name$/;"	cons	data:CompilerBug	line:43	language:Haskell
Result	./parser-typechecker/src/Unison/Result.hs	/^type Result notes = ResultT notes Identity$/;"	t	line:27	language:Haskell
Result	./parser-typechecker/src/Unison/Result.hs	/^pattern Result notes may = MaybeT (WriterT (Identity (may, notes)))$/;"	pi	line:50	language:Haskell
Result	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^data Result$/;"	d	line:209	language:Haskell
Result	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Result v loc a = Success (Seq (InfoNote v loc)) a$/;"	d	line:128	language:Haskell
Result	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^                | Result a$/;"	cons	data:CmdM	line:61	language:Haskell
Result	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    Result x >>= g = g x$/;"	fi	instance:Monad m => Monad (CmdM m)	line:78	language:Haskell
Result	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^class LineState s => Result s where$/;"	c	line:170	language:Haskell
Result CommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Result CommandMode where$/;"	i	line:274	language:Haskell
Result InsertMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Result InsertMode where$/;"	i	line:195	language:Haskell
Result Password	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Result Password where$/;"	i	line:397	language:Haskell
Result SearchMode	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^instance Result SearchMode where$/;"	i	line:97	language:Haskell
Result s => Result (ArgMode s)	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Result s => Result (ArgMode s) where$/;"	i	line:351	language:Haskell
Result'	./parser-typechecker/src/Unison/FileParsers.hs	/^type Result' v = Result (Seq (Note v Ann))$/;"	t	line:46	language:Haskell
ResultT	./parser-typechecker/src/Unison/Result.hs	/^type ResultT notes f = MaybeT (WriterT notes f)$/;"	t	line:29	language:Haskell
RetractFailure	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | RetractFailure (Element v loc) (Context v loc)$/;"	cons	data:CompilerBug	line:212	language:Haskell
Reverse	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data Direction = Forward | Reverse$/;"	cons	data:Direction	line:83	language:Haskell
RightKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | LeftKey | RightKey | DownKey | UpKey$/;"	cons	data:BaseKey	line:38	language:Haskell
RingBell	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^              | RingBell$/;"	cons	data:Effect	line:41	language:Haskell
RunIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^newtype RunIO m = RunIO (forall b . m b -> IO (m b))$/;"	nt	line:57	language:Haskell
RunTTY	./yaks/haskeline/tests/RunTTY.hs	/^module RunTTY (Invocation(..), $/;"	m	line:4	language:Haskell
RunTerm	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data RunTerm = RunTerm {$/;"	d	line:33	language:Haskell
RunTerm	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data RunTerm = RunTerm {$/;"	cons	data:RunTerm	line:33	language:Haskell
Runtime	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^data Runtime v = Runtime$/;"	d	line:28	language:Haskell
Runtime	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^data Runtime v = Runtime$/;"	cons	data:Runtime	line:28	language:Haskell
S	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^newtype S = S {_ioState :: MVar IOState }$/;"	nt	line:122	language:Haskell
STTYSettings	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^type STTYSettings = String$/;"	t	line:128	language:Haskell
Same	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data Typing = Same | Subtype | Different$/;"	cons	data:Typing	line:20	language:Haskell
Satisfied	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^data FoldHistoryResult a = Satisfied a | Unsatisfied a deriving (Eq,Ord,Show)$/;"	cons	data:FoldHistoryResult	line:341	language:Haskell
Save	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^class LineState s => Save s where$/;"	c	line:173	language:Haskell
Save CommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Save CommandMode where$/;"	i	line:278	language:Haskell
Save InsertMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Save InsertMode where$/;"	i	line:198	language:Haskell
Save s => Save (ArgMode s)	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Save s => Save (ArgMode s) where$/;"	i	line:354	language:Haskell
SavedCommand	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^type SavedCommand m = Command (ViT m) (ArgMode CommandMode) EitherMode$/;"	t	line:18	language:Haskell
Scalar	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^  Scalar :: a -> Vec a$/;"	c_gadt	d_gadt:Vec	line:12	language:Haskell
Scheme	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data Scheme = Ssh | Https$/;"	d	line:79	language:Haskell
Scope	./parser-typechecker/src/Unison/Util/Logger.hs	/^type Scope = [String]$/;"	t	line:25	language:Haskell
Score	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^type Score = Int$/;"	t	line:21	language:Haskell
ScpProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^  | ScpProtocol (Maybe User) Host UrlPath$/;"	cons	data:GitProtocol	line:54	language:Haskell
ScratchFileName	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^type ScratchFileName = Text$/;"	t	line:52	language:Haskell
SearchByNameI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | SearchByNameI Bool Bool [String] -- SearchByName isVerbose showAll query$/;"	cons	data:Input	line:122	language:Haskell
SearchEntry	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^data SearchEntry = SearchEntry {$/;"	d	line:400	language:Haskell
SearchEntry	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^data SearchEntry = SearchEntry {$/;"	cons	data:SearchEntry	line:400	language:Haskell
SearchMode	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data SearchMode = SearchMode {searchTerm :: [Grapheme],$/;"	d	line:78	language:Haskell
SearchMode	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data SearchMode = SearchMode {searchTerm :: [Grapheme],$/;"	cons	data:SearchMode	line:78	language:Haskell
SearchResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data SearchResult = Tp TypeResult | Tm TermResult deriving (Eq, Ord, Show)$/;"	d	line:19	language:Haskell
SearchResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^data SearchResult' v a$/;"	d	line:20	language:Haskell
SearchTermsNotFound	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | SearchTermsNotFound [HQ.HashQualified]$/;"	cons	data:Output	line:118	language:Haskell
Semi	./parser-typechecker/src/Unison/Lexer.hs	/^  | Semi IsVirtual   -- separator between elements of a block$/;"	cons	data:Lexeme	line:47	language:Haskell
Semigroup (AnnotatedText a)	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^instance Semigroup (AnnotatedText a) where$/;"	i	line:29	language:Haskell
Semigroup (CompilationEnv e cont)	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Semigroup (CompilationEnv e cont) where (<>) = mappend$/;"	i	line:985	language:Haskell
Semigroup (MetadataDiff tm)	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^instance Semigroup (MetadataDiff tm) where$/;"	i	line:39	language:Haskell
Semigroup (Notes v loc)	./parser-typechecker/src/Unison/Typechecker.hs	/^instance Semigroup (Notes v loc) where$/;"	i	line:50	language:Haskell
Semigroup (Path s t a b m)	./unison-core/src/Unison/ABT.hs	/^instance Semigroup (Path s t a b m) where$/;"	i	line:61	language:Haskell
Semigroup (Pretty s)	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Semigroup (Pretty s) where (<>) = mappend$/;"	i	line:635	language:Haskell
Semigroup (SubseqExtractor' n a)	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^instance Semigroup (SubseqExtractor' n a) where$/;"	i	line:347	language:Haskell
Semigroup (TypeLookup v a)	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^instance Semigroup (TypeLookup v a) where (<>) = mappend$/;"	i	line:56	language:Haskell
Semigroup Ann	./parser-typechecker/src/Unison/Parser.hs	/^instance Semigroup Ann where$/;"	i	line:123	language:Haskell
Semigroup BranchAttentions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Semigroup BranchAttentions where$/;"	i	line:822	language:Haskell
Semigroup BranchDiff	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Semigroup BranchDiff where$/;"	i	line:187	language:Haskell
Semigroup Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance Semigroup Bytes where (<>) = mappend$/;"	i	line:81	language:Haskell
Semigroup Delta	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Semigroup Delta where (<>) = mappend$/;"	i	line:649	language:Haskell
Semigroup NameEdit	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^instance Semigroup NameEdit where$/;"	i	line:11	language:Haskell
Semigroup Patch	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^instance Semigroup Patch where$/;"	i	line:115	language:Haskell
Semigroup PatchDiff	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^instance Semigroup PatchDiff where$/;"	i	line:127	language:Haskell
Semigroup Pos	./parser-typechecker/src/Unison/Lexer.hs	/^instance Semigroup Pos where (<>) = mappend$/;"	i	line:125	language:Haskell
Semigroup PrettyPrintEnv	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^instance Semigroup PrettyPrintEnv where$/;"	i	line:118	language:Haskell
Semigroup PrintAnnotation	./parser-typechecker/src/Unison/TermPrinter.hs	/^instance Semigroup PrintAnnotation where$/;"	i	line:760	language:Haskell
Semigroup Range	./parser-typechecker/src/Unison/Util/Range.hs	/^instance Semigroup Range where$/;"	i	line:25	language:Haskell
Semigroup RefCollisions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^instance Semigroup RefCollisions where$/;"	i	line:835	language:Haskell
Semigroup UniqueName	./parser-typechecker/src/Unison/Parser.hs	/^instance Semigroup UniqueName where (<>) = mappend$/;"	i	line:57	language:Haskell
SeqOp	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type SeqOp = Pattern.SeqOp$/;"	t	line:171	language:Haskell
SeqOp	./unison-core/src/Unison/Pattern.hs	/^data SeqOp = Cons$/;"	d	line:53	language:Haskell
SeqOp	./unison-core/src/Unison/PatternP.hs	/^type SeqOp = P.SeqOp$/;"	t	line:28	language:Haskell
Sequence	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Sequence (Sequence.Seq (Value e cont))$/;"	cons	data:Value	line:84	language:Haskell
Sequence	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Sequence vs == Sequence vs2 = vs == vs2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:101	language:Haskell
Sequence	./unison-core/src/Unison/Term.hs	/^  | Sequence (Seq a)$/;"	cons	data:F	line:77	language:Haskell
Sequence	./unison-core/src/Unison/Term.hs	/^  Sequence v == Sequence v2 = v == v2$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1053	language:Haskell
Sequence'	./unison-core/src/Unison/Term.hs	/^pattern Sequence' xs <- (ABT.out -> ABT.Tm (Sequence xs))$/;"	pi	line:439	language:Haskell
SequenceLiteral	./unison-core/src/Unison/Pattern.hs	/^pattern SequenceLiteral ps = SequenceLiteralP () ps$/;"	pi	line:110	language:Haskell
SequenceLiteral	./unison-core/src/Unison/PatternP.hs	/^pattern SequenceLiteral loc ps = P.SequenceLiteralP loc ps$/;"	pi	line:25	language:Haskell
SequenceLiteralP	./unison-core/src/Unison/Pattern.hs	/^  | SequenceLiteralP loc [PatternP loc]$/;"	cons	data:PatternP	line:49	language:Haskell
SequenceLiteralP	./unison-core/src/Unison/Pattern.hs	/^  SequenceLiteralP _ ps == SequenceLiteralP _ ps2 = ps == ps2$/;"	fi	instance:Eq (PatternP loc)	line:143	language:Haskell
SequenceOp	./unison-core/src/Unison/Pattern.hs	/^pattern SequenceOp ph op pt = SequenceOpP () ph op pt$/;"	pi	line:111	language:Haskell
SequenceOp	./unison-core/src/Unison/PatternP.hs	/^pattern SequenceOp loc l op r = P.SequenceOpP loc l op r$/;"	pi	line:26	language:Haskell
SequenceOpP	./unison-core/src/Unison/Pattern.hs	/^  | SequenceOpP loc (PatternP loc) !SeqOp (PatternP loc)$/;"	cons	data:PatternP	line:50	language:Haskell
SequenceOpP	./unison-core/src/Unison/Pattern.hs	/^  SequenceOpP _ ph op pt == SequenceOpP _ ph2 op2 pt2 = ph == ph2 && op == op2 && pt == pt2$/;"	fi	instance:Eq (PatternP loc)	line:144	language:Haskell
Serialize	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^type Serialize m h e = RawHash h -> Raw h e -> m ()$/;"	t	line:123	language:Haskell
Set.member	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^fromText t | Text.all (`Set.member` Hash.validBase32HexChars) t =$/;"	fi	line:27	language:Haskell
Settings	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^data Settings m = Settings {complete :: CompletionFunc m, -- ^ Custom tab completion.$/;"	d	line:21	language:Haskell
Settings	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^data Settings m = Settings {complete :: CompletionFunc m, -- ^ Custom tab completion.$/;"	cons	data:Settings	line:21	language:Haskell
ShallowBranchEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShallowBranchEntry NameSegment Int -- number of child definitions$/;"	cons	data:ShallowListEntry	line:204	language:Haskell
ShallowListEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data ShallowListEntry v a$/;"	d	line:201	language:Haskell
ShallowPatchEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShallowPatchEntry NameSegment$/;"	cons	data:ShallowListEntry	line:205	language:Haskell
ShallowTermEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  = ShallowTermEntry Referent HQSegment (Maybe (Type v a))$/;"	cons	data:ShallowListEntry	line:202	language:Haskell
ShallowTypeEntry	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShallowTypeEntry Reference HQSegment$/;"	cons	data:ShallowListEntry	line:203	language:Haskell
ShortBranchHash	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^newtype ShortBranchHash =$/;"	nt	line:10	language:Haskell
ShortHash	./unison-core/src/Unison/ShortHash.hs	/^data ShortHash$/;"	d	line:12	language:Haskell
ShortHash	./unison-core/src/Unison/ShortHash.hs	/^  | ShortHash { prefix :: Text, cycle :: Maybe Text, cid :: Maybe Text }$/;"	cons	data:ShortHash	line:14	language:Haskell
Show (PatternP loc)	./unison-core/src/Unison/Pattern.hs	/^instance Show (PatternP loc) where$/;"	i	line:63	language:Haskell
Show (RawHash a)	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^instance Show (RawHash a) where$/;"	i	line:49	language:Haskell
Show Absolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Show Absolute where$/;"	i	line:56	language:Haskell
Show ArgumentType	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^instance Show ArgumentType where$/;"	i	line:45	language:Haskell
Show Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance Show Bytes where$/;"	i	line:86	language:Haskell
Show Continuation	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance Show Continuation where$/;"	i	line:65	language:Haskell
Show ExternalFunction	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^instance Show ExternalFunction where$/;"	i	line:799	language:Haskell
Show Grapheme	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^instance Show Grapheme where$/;"	i	line:80	language:Haskell
Show Hash	./unison-core/src/Unison/Hash.hs	/^instance Show Hash where$/;"	i	line:24	language:Haskell
Show History	./yaks/haskeline/System/Console/Haskeline/History.hs	/^instance Show History where$/;"	i	line:46	language:Haskell
Show Id	./unison-core/src/Unison/Reference.hs	/^instance Show Id where show = SH.toString . SH.take 5 . toShortHash . DerivedId$/;"	i	line:169	language:Haskell
Show Modifier	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^instance Show Modifier where$/;"	i	line:25	language:Haskell
Show Name	./unison-core/src/Unison/Name.hs	/^instance Show Name where$/;"	i	line:131	language:Haskell
Show NameSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^instance Show NameSegment where$/;"	i	line:39	language:Haskell
Show Path	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Show Path where$/;"	i	line:320	language:Haskell
Show Path'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Show Path' where$/;"	i	line:52	language:Haskell
Show PrettyPrintEnv	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^instance Show PrettyPrintEnv where$/;"	i	line:33	language:Haskell
Show Reference	./unison-core/src/Unison/Reference.hs	/^instance Show Reference where show = SH.toString . SH.take 5 . toShortHash$/;"	i	line:170	language:Haskell
Show Relative	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Show Relative where$/;"	i	line:59	language:Haskell
Show ShortBranchHash	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^instance Show ShortBranchHash where$/;"	i	line:31	language:Haskell
Show Stanza	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^instance Show Stanza where$/;"	i	line:67	language:Haskell
Show Symbol	./unison-core/src/Unison/Symbol.hs	/^instance Show Symbol where$/;"	i	line:30	language:Haskell
Show SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Show SymbolC where$/;"	i	line:66	language:Haskell
Show UcmCommand	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^instance Show UcmCommand where$/;"	i	line:64	language:Haskell
Show a => Show (F a)	./unison-core/src/Unison/Type.hs	/^instance Show a => Show (F a) where$/;"	i	line:608	language:Haskell
Show a => Show (T a)	./parser-typechecker/src/Unison/Lexer.hs	/^instance Show a => Show (T a) where$/;"	i	line:178	language:Haskell
Show e => Show (Causal m h e)	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^instance Show e => Show (Causal m h e) where$/;"	i	line:52	language:Haskell
Show n => Show (HashQualified' n)	./unison-core/src/Unison/HashQualified'.hs	/^instance Show n => Show (HashQualified' n) where$/;"	i	line:118	language:Haskell
Show n => Show (Names' n)	./unison-core/src/Unison/Names2.hs	/^instance Show n => Show (Names' n) where$/;"	i	line:330	language:Haskell
Show s => Show (Pretty s)	./parser-typechecker/src/Unison/Util/Pretty.hs	/^instance Show s => Show (Pretty s) where$/;"	i	line:779	language:Haskell
Show v => Show (TypeVar b v)	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^instance Show v => Show (TypeVar b v) where$/;"	i	line:31	language:Haskell
Show1 F	./unison-core/src/Unison/Type.hs	/^instance Show1 F where showsPrec1 = showsPrec$/;"	i	line:56	language:Haskell
ShowDefinitionByPrefixI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | ShowDefinitionByPrefixI OutputLocation [String]$/;"	cons	data:Input	line:126	language:Haskell
ShowDefinitionI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | ShowDefinitionI OutputLocation [String]$/;"	cons	data:Input	line:125	language:Haskell
ShowDiffAfterCreatePR	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterCreatePR RemoteNamespace RemoteNamespace PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:80	language:Haskell
ShowDiffAfterDeleteBranch	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterDeleteBranch Path.Absolute PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:74	language:Haskell
ShowDiffAfterDeleteDefinitions	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterDeleteDefinitions PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:73	language:Haskell
ShowDiffAfterMerge	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterMerge Path.Path' Path.Absolute PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:76	language:Haskell
ShowDiffAfterMergePreview	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterMergePreview Path.Path' Path.Absolute PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:78	language:Haskell
ShowDiffAfterMergePropagate	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterMergePropagate Path.Path' Path.Absolute Path.Path' PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:77	language:Haskell
ShowDiffAfterModifyBranch	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterModifyBranch Path.Path' Path.Absolute PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:75	language:Haskell
ShowDiffAfterPull	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterPull Path.Path' Path.Absolute PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:79	language:Haskell
ShowDiffAfterUndo	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowDiffAfterUndo PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:72	language:Haskell
ShowDiffNamespace	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  = ShowDiffNamespace Path.Absolute Path.Absolute PPE.PrettyPrintEnv (BranchDiffOutput v Ann)$/;"	cons	data:NumberedOutput	line:71	language:Haskell
ShowFailures	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type ShowFailures = Bool  -- whether to list results or just summarize$/;"	t	line:239	language:Haskell
ShowNumbers	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^data ShowNumbers = ShowNumbers | HideNumbers$/;"	d	line:1299	language:Haskell
ShowNumbers	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^data ShowNumbers = ShowNumbers | HideNumbers$/;"	cons	data:ShowNumbers	line:1299	language:Haskell
ShowReflog	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | ShowReflog [ReflogEntry]$/;"	cons	data:Output	line:185	language:Haskell
ShowReflogI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | ShowReflogI$/;"	cons	data:Input	line:127	language:Haskell
ShowSuccesses	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type ShowSuccesses = Bool -- whether to list results or just summarize$/;"	t	line:238	language:Haskell
ShowToken (Token Lexeme)	./parser-typechecker/src/Unison/Lexer.hs	/^instance ShowToken (Token Lexeme) where$/;"	i	line:84	language:Haskell
Shown	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data Hidden = Shown | HideOutput | HideAll$/;"	cons	data:Hidden	line:50	language:Haskell
SignatureNeedsAccompanyingBody	./parser-typechecker/src/Unison/Parser.hs	/^  = SignatureNeedsAccompanyingBody (L.Token v)$/;"	cons	data:Error	line:90	language:Haskell
SignumI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | SignumI z | NegateI z | Truncate0I z | ModI z z$/;"	cons	data:IR'	line:211	language:Haskell
SimpleMove	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^data KillHelper = SimpleMove (InsertMode -> InsertMode)$/;"	cons	data:KillHelper	line:78	language:Haskell
SimpleTermDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type SimpleTermDisplay v a = (HashQualified, Referent, Maybe (Type v a))$/;"	t	line:88	language:Haskell
SimpleTypeDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type SimpleTypeDisplay v a = (HashQualified, Reference, Maybe (DeclOrBuiltin v a))$/;"	t	line:89	language:Haskell
Size	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type Size = Int$/;"	t	line:48	language:Haskell
Size	./unison-core/src/Unison/Reference.hs	/^type Size = Word64$/;"	t	line:111	language:Haskell
Size	./unison-core/src/Unison/Referent.hs	/^type Size = Word64$/;"	t	line:33	language:Haskell
SkipNextUpdate	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^type SkipNextUpdate = Bool$/;"	t	line:166	language:Haskell
Skipped	./yaks/easytest/src/EasyTest.hs	/^data Status = Failed | Passed !Int | Skipped | Pending$/;"	cons	data:Status	line:25	language:Haskell
Slot	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = Slot Pos$/;"	cons	data:Z	line:195	language:Haskell
SlurpComponent	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^data SlurpComponent v =$/;"	d	line:16	language:Haskell
SlurpComponent	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^  SlurpComponent { types :: Set v, terms :: Set v }$/;"	cons	data:SlurpComponent	line:17	language:Haskell
SlurpOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | SlurpOutput Input PPE.PrettyPrintEnv (SlurpResult v)$/;"	cons	data:Output	line:138	language:Haskell
SlurpResult	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^data SlurpResult v = SlurpResult {$/;"	d	line:41	language:Haskell
SlurpResult	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^data SlurpResult v = SlurpResult {$/;"	cons	data:SlurpResult	line:41	language:Haskell
Snoc	./parser-typechecker/src/Unison/Runtime/IR.hs	/^pattern Snoc = Pattern.Snoc$/;"	pi	line:172	language:Haskell
Snoc	./unison-core/src/Unison/Pattern.hs	/^           | Snoc$/;"	cons	data:SeqOp	line:54	language:Haskell
Snoc	./unison-core/src/Unison/PatternP.hs	/^pattern Snoc = P.Snoc$/;"	pi	line:29	language:Haskell
Snoc Absolute Absolute NameSegment NameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Snoc Absolute Absolute NameSegment NameSegment where$/;"	i	line:348	language:Haskell
Snoc Path Path NameSegment NameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Snoc Path Path NameSegment NameSegment where$/;"	i	line:356	language:Haskell
Snoc Path' Path' NameSegment NameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Snoc Path' Path' NameSegment NameSegment where$/;"	i	line:366	language:Haskell
Snoc Relative Relative NameSegment NameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^instance Snoc Relative Relative NameSegment NameSegment where$/;"	i	line:340	language:Haskell
SnocList	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^type SnocList a = Snil | Snoc (List a) a$/;"	t	line:49	language:Haskell
SocketMap	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^type SocketMap = Map GUID Net.Socket$/;"	t	line:119	language:Haskell
Solved	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | Solved (B.Blank loc) v (Monotype v loc)  -- `v` is solved to some monotype$/;"	cons	data:Element	line:112	language:Haskell
Solved	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Solved _ v t == Solved _ v2 t2 = v == v2 && t == t2$/;"	fi	instance:(Ord loc, Var v) => Eq (Element v loc)	line:118	language:Haskell
SolvedBlank	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  = SolvedBlank (B.Recorded loc) v (Type v loc)$/;"	cons	data:InfoNote	line:271	language:Haskell
SomeOtherError	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^              | SomeOtherError Text$/;"	cons	data:GitError	line:17	language:Haskell
Source	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^type Source = Text$/;"	t	line:47	language:Haskell
Source	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^type Source = Text -- "id x = x\\nconst a b = a"$/;"	t	line:28	language:Haskell
SourceFileContents	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type SourceFileContents = Text$/;"	t	line:243	language:Haskell
SourceLoadFailed	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | SourceLoadFailed String$/;"	cons	data:Output	line:90	language:Haskell
SourceName	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^type SourceName = Text$/;"	t	line:46	language:Haskell
SourceName	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^type SourceName = Text -- "foo.u" or "buffer 7"$/;"	t	line:29	language:Haskell
SourceName	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type SourceName = Text$/;"	t	line:60	language:Haskell
SparseVector	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^data SparseVector bits a$/;"	d	line:17	language:Haskell
SparseVector	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^  = SparseVector { indices :: !bits$/;"	cons	data:SparseVector	line:18	language:Haskell
Specialize	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  Specialize h _ vs == Specialize h2 _ vs2 = h == h2 && vs == vs2$/;"	fi	instance:(Eq cont, Eq e) => Eq (UnderapplyStrategy e cont)	line:112	language:Haskell
Specialize	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Specialize Hash (Term SymbolC) [(SymbolC, Value e cont)] -- same$/;"	cons	data:UnderapplyStrategy	line:158	language:Haskell
Split	./parser-typechecker/src/Unison/Codebase/Path.hs	/^type Split = (Path, NameSegment)$/;"	t	line:75	language:Haskell
Split'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^type Split' = (Path', NameSegment)$/;"	t	line:78	language:Haskell
SplitAbsolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^type SplitAbsolute = (Absolute, NameSegment)$/;"	t	line:81	language:Haskell
SrcNotFound	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data ForkFailure = SrcNotFound | DestExists$/;"	cons	data:ForkFailure	line:438	language:Haskell
Ssh	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data Scheme = Ssh | Https$/;"	cons	data:Scheme	line:79	language:Haskell
SshProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^  | SshProtocol (Maybe User) HostInfo UrlPath$/;"	cons	data:GitProtocol	line:53	language:Haskell
Stack	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type Stack = MV.IOVector Value$/;"	t	line:49	language:Haskell
Stack	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^data Stack a = Stack [a] [a]$/;"	d	line:11	language:Haskell
Stack	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^data Stack a = Stack [a] [a]$/;"	cons	data:Stack	line:11	language:Haskell
Stanza	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data Stanza$/;"	d	line:58	language:Haskell
Stanza	./parser-typechecker/src/Unison/FileParser.hs	/^data Stanza v term$/;"	d	line:97	language:Haskell
Star	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^type Star r n = Metadata.Star r n$/;"	t	line:159	language:Haskell
Star	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^type Star a n = Star3 a n Type (Type, Value)$/;"	t	line:25	language:Haskell
Star	./unison-core/src/Unison/Kind.hs	/^data Kind = Star | Arrow Kind Kind deriving (Eq,Ord,Read,Show,Generic)$/;"	cons	data:Kind	line:10	language:Haskell
Star3	./parser-typechecker/src/Unison/Util/Star3.hs	/^data Star3 fact d1 d2 d3$/;"	d	line:14	language:Haskell
Star3	./parser-typechecker/src/Unison/Util/Star3.hs	/^  = Star3 { fact :: Set fact$/;"	cons	data:Star3	line:15	language:Haskell
StartOfCurrentPathHistory	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | StartOfCurrentPathHistory$/;"	cons	data:Output	line:183	language:Haskell
StartsIndented	./parser-typechecker/src/Unison/TermParser.hs	/^    | StartsIndented$/;"	cons	data:UnbreakCase	line:371	language:Haskell
StartsUnindented	./parser-typechecker/src/Unison/TermParser.hs	/^    | StartsUnindented deriving (Eq, Show)$/;"	cons	data:UnbreakCase	line:373	language:Haskell
StateT	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^newtype StateT s m a = StateT { getStateTFunc $/;"	nt	line:71	language:Haskell
StateT	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    StateT f >>= g = StateT $ \\s -> do$/;"	fi	instance:Monad m => Monad (StateT s m)	line:83	language:Haskell
Status	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^data Status =$/;"	d	line:127	language:Haskell
Status	./yaks/easytest/src/EasyTest.hs	/^data Status = Failed | Passed !Int | Skipped | Pending$/;"	d	line:25	language:Haskell
Storable Coord	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^instance Storable Coord where$/;"	i	line:169	language:Haskell
Structural	./unison-core/src/Unison/DataDeclaration.hs	/^data Modifier = Structural | Unique Text -- | Opaque (Set Reference)$/;"	cons	data:Modifier	line:71	language:Haskell
Stylized	./parser-typechecker/src/Unison/Util/Menu.hs	/^type Stylized = ColorText$/;"	t	line:20	language:Haskell
SubF	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddF z z | SubF z z | MultF z z | DivF z z$/;"	cons	data:IR'	line:217	language:Haskell
SubI	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddI z z | SubI z z | MultI z z | DivI z z$/;"	cons	data:IR'	line:209	language:Haskell
SubN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | AddN z z | DropN z z | SubN z z | MultN z z | DivN z z$/;"	cons	data:IR'	line:213	language:Haskell
SubseqExtractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^type SubseqExtractor v loc a = SubseqExtractor' (C.ErrorNote v loc) a$/;"	t	line:33	language:Haskell
SubseqExtractor'	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^data SubseqExtractor' n a =$/;"	d	line:61	language:Haskell
SubseqExtractor'	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  SubseqExtractor' { runSubseq :: n -> [Ranged a] }$/;"	cons	data:SubseqExtractor'	line:62	language:Haskell
Subst	./unison-core/src/Unison/ABT.hs	/^data Subst f v a =$/;"	d	line:456	language:Haskell
Subst	./unison-core/src/Unison/ABT.hs	/^  Subst { freshen :: forall m v' . Monad m => (v -> m v') -> m v'$/;"	cons	data:Subst	line:457	language:Haskell
Subtype	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data Typing = Same | Subtype | Different$/;"	cons	data:Typing	line:20	language:Haskell
Success	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  = Success$/;"	cons	data:Output	line:86	language:Haskell
Success	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^  | Success HQ.HashQualified (Term v Ann) (Type v Ann)$/;"	cons	data:MainTerm	line:32	language:Haskell
Success	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Result v loc a = Success (Seq (InfoNote v loc)) a$/;"	cons	data:Result	line:128	language:Haskell
Success	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Success is _          <*> TypeError es' is'       = TypeError es' (is <> is')$/;"	fi	instance:Applicative (Result v loc)	line:140	language:Haskell
Suffix	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^type Suffix = Text$/;"	t	line:125	language:Haskell
Suggestion	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Suggestion v loc =$/;"	d	line:252	language:Haskell
Suggestion	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Suggestion { suggestionName :: Text$/;"	cons	data:Suggestion	line:253	language:Haskell
SuggestionMatch	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data SuggestionMatch = Exact | WrongType | WrongName$/;"	d	line:249	language:Haskell
SwitchBranchI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | SwitchBranchI Path'$/;"	cons	data:Input	line:58	language:Haskell
Symbol	./unison-core/src/Unison/Symbol.hs	/^data Symbol = Symbol !Word64 Var.Type deriving (Generic)$/;"	d	line:13	language:Haskell
Symbol	./unison-core/src/Unison/Symbol.hs	/^data Symbol = Symbol !Word64 Var.Type deriving (Generic)$/;"	cons	data:Symbol	line:13	language:Haskell
Symbol	./unison-core/src/Unison/Symbol.hs	/^  Symbol id1 name1 == Symbol id2 name2 = id1 == id2 && name1 == name2$/;"	fi	instance:Eq Symbol	line:27	language:Haskell
SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data SymbolC =$/;"	d	line:62	language:Haskell
SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  SymbolC { isLazy :: Bool$/;"	cons	data:SymbolC	line:63	language:Haskell
SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  SymbolC _ s == SymbolC _ s2 = s == s2$/;"	fi	instance:Eq SymbolC	line:947	language:Haskell
SymbolyId	./parser-typechecker/src/Unison/Lexer.hs	/^  | SymbolyId String (Maybe ShortHash) -- an infix identifier$/;"	cons	data:Lexeme	line:54	language:Haskell
SyncLocalRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  SyncLocalRootBranch :: Branch m -> Command m i v ()$/;"	c_gadt	d_gadt:Command	line:150	language:Haskell
SyncRemoteRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  SyncRemoteRootBranch ::$/;"	c_gadt	d_gadt:Command	line:157	language:Haskell
SyntaxText	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^type SyntaxText = AnnotatedText Element$/;"	t	line:7	language:Haskell
SynthResult	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^type SynthResult =$/;"	t	line:51	language:Haskell
System.Console.Haskeline	./yaks/haskeline/System/Console/Haskeline.hs	/^module System.Console.Haskeline($/;"	m	line:29	language:Haskell
System.Console.Haskeline.Backend	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^module System.Console.Haskeline.Backend where$/;"	m	line:2	language:Haskell
System.Console.Haskeline.Backend.DumbTerm	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^module System.Console.Haskeline.Backend.DumbTerm where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Backend.Posix	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^module System.Console.Haskeline.Backend.Posix ($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Backend.Posix.Encoder	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^module System.Console.Haskeline.Backend.Posix.Encoder ($/;"	m	line:9	language:Haskell
System.Console.Haskeline.Backend.Terminfo	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^module System.Console.Haskeline.Backend.Terminfo($/;"	m	line:5	language:Haskell
System.Console.Haskeline.Backend.WCWidth	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^module System.Console.Haskeline.Backend.WCWidth($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Backend.Win32	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^module System.Console.Haskeline.Backend.Win32($/;"	m	line:2	language:Haskell
System.Console.Haskeline.Backend.Win32.Echo	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^module System.Console.Haskeline.Backend.Win32.Echo (hWithoutInputEcho) where$/;"	m	line:3	language:Haskell
System.Console.Haskeline.Command	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^module System.Console.Haskeline.Command($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Command.Completion	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^module System.Console.Haskeline.Command.Completion($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Command.History	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^module System.Console.Haskeline.Command.History where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Command.KillRing	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^module System.Console.Haskeline.Command.KillRing where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Command.Undo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^module System.Console.Haskeline.Command.Undo where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Completion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^module System.Console.Haskeline.Completion($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Directory	./yaks/haskeline/System/Console/Haskeline/Directory.hsc	/^module System.Console.Haskeline.Directory($/;"	m	line:7	language:Haskell
System.Console.Haskeline.Emacs	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^module System.Console.Haskeline.Emacs where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.History	./yaks/haskeline/System/Console/Haskeline/History.hs	/^module System.Console.Haskeline.History($/;"	m	line:14	language:Haskell
System.Console.Haskeline.IO	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^module System.Console.Haskeline.IO($/;"	m	line:34	language:Haskell
System.Console.Haskeline.InputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^module System.Console.Haskeline.InputT where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Key	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^module System.Console.Haskeline.Key(Key(..),$/;"	m	line:1	language:Haskell
System.Console.Haskeline.LineState	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^module System.Console.Haskeline.LineState($/;"	m	line:4	language:Haskell
System.Console.Haskeline.MonadException	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^module System.Console.Haskeline.MonadException($/;"	m	line:6	language:Haskell
System.Console.Haskeline.Monads	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^module System.Console.Haskeline.Monads($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Prefs	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^module System.Console.Haskeline.Prefs($/;"	m	line:1	language:Haskell
System.Console.Haskeline.Recover	./yaks/haskeline/System/Console/Haskeline/Recover.hs	/^module System.Console.Haskeline.Recover where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.RunCommand	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^module System.Console.Haskeline.RunCommand (runCommandLoop) where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Term	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^module System.Console.Haskeline.Term where$/;"	m	line:1	language:Haskell
System.Console.Haskeline.Vi	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^module System.Console.Haskeline.Vi where$/;"	m	line:1	language:Haskell
T	./parser-typechecker/src/Unison/Lexer.hs	/^data T a = T a [T a] [a] | L a deriving (Functor, Foldable, Traversable)$/;"	d	line:172	language:Haskell
T	./parser-typechecker/src/Unison/Lexer.hs	/^data T a = T a [T a] [a] | L a deriving (Functor, Foldable, Traversable)$/;"	cons	data:T	line:172	language:Haskell
T	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = I Int64 | F Double | N Word64 | B Bool | T Text | C Char | Bs Bytes.Bytes$/;"	cons	data:Value	line:79	language:Haskell
T	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  T x == T y = x == y$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:96	language:Haskell
T-Measured (Sum Int) B-ByteString	./parser-typechecker/src/Unison/Util/Bytes.hs	/^instance T.Measured (Sum Int) B.ByteString where$/;"	i	line:83	language:Haskell
TDNR	./parser-typechecker/src/Unison/Typechecker.hs	/^type TDNR f v loc a =$/;"	t	line:164	language:Haskell
TDNRMap	./parser-typechecker/src/Unison/FileParsers.hs	/^type TDNRMap v = Map Typechecker.Name [Typechecker.NamedReference v Ann]$/;"	t	line:76	language:Haskell
TFile	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^type TFile = UF.TypecheckedUnisonFile Symbol Ann$/;"	t	line:50	language:Haskell
TQueue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^data TQueue a = TQueue (TVar (Seq a)) (TVar Word64)$/;"	d	line:12	language:Haskell
TQueue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^data TQueue a = TQueue (TVar (Seq a)) (TVar Word64)$/;"	cons	data:TQueue	line:12	language:Haskell
TV	./parser-typechecker/tests/Unison/Test/Typechecker/Context.hs	/^type TV = Context.TypeVar Symbol ()$/;"	t	line:20	language:Haskell
Tag	./unison-core/src/Unison/Hashable.hs	/^  = Tag !Word8$/;"	cons	data:Token	line:11	language:Haskell
Tails	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^data Tails h$/;"	d	line:108	language:Haskell
TailsCons	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | TailsCons (RawHash h)$/;"	cons	data:Tails	line:110	language:Haskell
TailsMerge	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | TailsMerge (Set (RawHash h))$/;"	cons	data:Tails	line:111	language:Haskell
TailsOne	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  = TailsOne$/;"	cons	data:Tails	line:109	language:Haskell
Target	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Target = TargetType | TargetTerm | TargetBranch$/;"	d	line:429	language:Haskell
Target	./unison-core/src/Unison/Paths.hs	/^data Target v$/;"	d	line:19	language:Haskell
TargetBranch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Target = TargetType | TargetTerm | TargetBranch$/;"	cons	data:Target	line:429	language:Haskell
TargetTerm	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Target = TargetType | TargetTerm | TargetBranch$/;"	cons	data:Target	line:429	language:Haskell
TargetType	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^data Target = TargetType | TargetTerm | TargetBranch$/;"	cons	data:Target	line:429	language:Haskell
Term	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^type Term v = Term.Term v ()$/;"	t	line:26	language:Haskell
Term	./parser-typechecker/src/Unison/FileParsers.hs	/^type Term v = Term.Term v Ann$/;"	t	line:43	language:Haskell
Term	./parser-typechecker/src/Unison/Runtime/IR.hs	/^type Term v = Term.Term v ()$/;"	t	line:49	language:Haskell
Term	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type Term v loc = Term.Term' (TypeVar v loc) v loc$/;"	t	line:90	language:Haskell
Term	./parser-typechecker/tests/Unison/Test/Common.hs	/^type Term v = Term.Term v Ann$/;"	t	line:33	language:Haskell
Term	./unison-core/src/Unison/ABT.hs	/^data Term f v a = Term { freeVars :: Set v, annotation :: a, out :: ABT f v (Term f v a) }$/;"	d	line:38	language:Haskell
Term	./unison-core/src/Unison/ABT.hs	/^data Term f v a = Term { freeVars :: Set v, annotation :: a, out :: ABT f v (Term f v a) }$/;"	cons	data:Term	line:38	language:Haskell
Term	./unison-core/src/Unison/Paths.hs	/^type Term v = E.Term v ()$/;"	t	line:17	language:Haskell
Term	./unison-core/src/Unison/Paths.hs	/^  = Term (Term v)$/;"	cons	data:Target	line:20	language:Haskell
Term	./unison-core/src/Unison/Term.hs	/^type Term v a = Term2 v a a v a$/;"	t	line:106	language:Haskell
Term	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^class (MonadReader Layout m, MonadException m) => Term m where$/;"	c	line:20	language:Haskell
Term'	./unison-core/src/Unison/Term.hs	/^type Term' vt v a = Term2 vt a a v a$/;"	t	line:108	language:Haskell
Term0	./unison-core/src/Unison/Term.hs	/^type Term0 v = Term v ()$/;"	t	line:116	language:Haskell
Term0'	./unison-core/src/Unison/Term.hs	/^type Term0' vt v = Term' vt v ()$/;"	t	line:118	language:Haskell
Term2	./unison-core/src/Unison/Term.hs	/^type Term2 vt at ap v a = ABT.Term (F vt at ap) v a$/;"	t	line:111	language:Haskell
Term3	./unison-core/src/Unison/Term.hs	/^type Term3 v a = Term2 v () () v a$/;"	t	line:113	language:Haskell
TermAction	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^type TermAction = Actions -> TermOutput$/;"	t	line:183	language:Haskell
TermAlreadyExists	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TermAlreadyExists Path.Split' (Set Referent)$/;"	cons	data:Output	line:103	language:Haskell
TermAmbiguous	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TermAmbiguous HQ.HashQualified (Set Referent)$/;"	cons	data:Output	line:107	language:Haskell
TermDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type TermDisplay v a = (HashQualified, Referent, Maybe (Type v a), MetadataDiff (MetadataDisplay v a))$/;"	t	line:79	language:Haskell
TermEdit	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data TermEdit = Replace Reference Typing | Deprecate$/;"	d	line:10	language:Haskell
TermExistingConstructorCollision	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  TermExistingConstructorCollision | ConstructorExistingTermCollision |$/;"	cons	data:Status	line:129	language:Haskell
TermLink	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | TermLink Referent$/;"	cons	data:Value	line:80	language:Haskell
TermLink	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  TermLink r1 == TermLink r2 = r1 == r2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:106	language:Haskell
TermLink	./unison-core/src/Unison/Term.hs	/^  | TermLink Referent$/;"	cons	data:F	line:99	language:Haskell
TermLink	./unison-core/src/Unison/Term.hs	/^  TermLink x == TermLink y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1046	language:Haskell
TermLink'	./unison-core/src/Unison/Term.hs	/^pattern TermLink' r <- (ABT.out -> ABT.Tm (TermLink r))$/;"	pi	line:419	language:Haskell
TermNotFound	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TermNotFound Path.HQSplit'$/;"	cons	data:Output	line:115	language:Haskell
TermNotFound'	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TermNotFound' ShortHash$/;"	cons	data:Output	line:117	language:Haskell
TermOps	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data TermOps = TermOps$/;"	d	line:42	language:Haskell
TermOps	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data TermOps = TermOps$/;"	cons	data:TermOps	line:42	language:Haskell
TermP	./parser-typechecker/src/Unison/TermParser.hs	/^type TermP v = P v (Term v Ann)$/;"	t	line:63	language:Haskell
TermPos	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data TermPos = TermPos {termRow,termCol :: !Int}$/;"	d	line:78	language:Haskell
TermPos	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data TermPos = TermPos {termRow,termCol :: !Int}$/;"	cons	data:TermPos	line:78	language:Haskell
TermReferencesByShortHash	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  TermReferencesByShortHash :: ShortHash -> Command m i v (Set Reference)$/;"	c_gadt	d_gadt:Command	line:76	language:Haskell
TermReferentsByShortHash	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  TermReferentsByShortHash :: ShortHash -> Command m i v (Set Referent)$/;"	c_gadt	d_gadt:Command	line:77	language:Haskell
TermResolutionFailure	./unison-core/src/Unison/Names3.hs	/^  = TermResolutionFailure v a (Set Referent)$/;"	cons	data:ResolutionFailure	line:34	language:Haskell
TermResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data TermResult = TermResult$/;"	d	line:21	language:Haskell
TermResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data TermResult = TermResult$/;"	cons	data:TermResult	line:21	language:Haskell
TermResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^data TermResult' v a =$/;"	d	line:24	language:Haskell
TermResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^  TermResult' HQ'.HashQualified (Maybe (Type v a)) Referent (Set HQ'.HashQualified)$/;"	cons	data:TermResult'	line:25	language:Haskell
TermRows	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data TermRows = TermRows {$/;"	d	line:84	language:Haskell
TermRows	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data TermRows = TermRows {$/;"	cons	data:TermRows	line:84	language:Haskell
Test	./yaks/easytest/src/EasyTest.hs	/^newtype Test a = Test (ReaderT Env IO (Maybe a))$/;"	nt	line:43	language:Haskell
Test	./yaks/easytest/src/EasyTest.hs	/^  Test a >>= f = Test $ do$/;"	fi	instance:Monad Test	line:383	language:Haskell
Test	./yaks/easytest/src/EasyTest.hs	/^  Test t1 <|> Test t2 = Test $ do$/;"	fi	instance:Alternative Test	line:408	language:Haskell
TestI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | TestI Bool Bool -- TestI showSuccesses showFailures$/;"	cons	data:Input	line:111	language:Haskell
TestIncrementalOutputEnd	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TestIncrementalOutputEnd PPE.PrettyPrintEnv (Int,Int) Reference (Term v Ann)$/;"	cons	data:Output	line:158	language:Haskell
TestIncrementalOutputStart	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TestIncrementalOutputStart PPE.PrettyPrintEnv (Int,Int) Reference (Term v Ann)$/;"	cons	data:Output	line:157	language:Haskell
TestReportStats	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data TestReportStats$/;"	d	line:232	language:Haskell
TestResults	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TestResults TestReportStats$/;"	cons	data:Output	line:159	language:Haskell
TestWatch	./parser-typechecker/src/Unison/UnisonFile.hs	/^pattern TestWatch = Var.TestWatch$/;"	pi	line:60	language:Haskell
TestWatch	./unison-core/src/Unison/Var.hs	/^pattern TestWatch = "test"$/;"	pi	line:106	language:Haskell
Text	./unison-core/src/Unison/Hashable.hs	/^  | Text !Text$/;"	cons	data:Token	line:14	language:Haskell
Text	./unison-core/src/Unison/Pattern.hs	/^pattern Text t = TextP () t$/;"	pi	line:104	language:Haskell
Text	./unison-core/src/Unison/PatternP.hs	/^pattern Text loc t = P.TextP loc t$/;"	pi	line:19	language:Haskell
Text	./unison-core/src/Unison/Term.hs	/^  | Text Text$/;"	cons	data:F	line:66	language:Haskell
Text	./unison-core/src/Unison/Term.hs	/^  Text x == Text y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1042	language:Haskell
Text'	./unison-core/src/Unison/Term.hs	/^pattern Text' s <- (ABT.out -> ABT.Tm (Text s))$/;"	pi	line:415	language:Haskell
TextLiteral	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | TextLiteral$/;"	cons	data:Element	line:11	language:Haskell
TextLiteralMissingClosingQuote	./parser-typechecker/src/Unison/Lexer.hs	/^  | TextLiteralMissingClosingQuote String$/;"	cons	data:Err	line:35	language:Haskell
TextP	./unison-core/src/Unison/Pattern.hs	/^  | TextP loc !Text$/;"	cons	data:PatternP	line:43	language:Haskell
TextP	./unison-core/src/Unison/Pattern.hs	/^  TextP _ t == TextP _ t2 = t == t2$/;"	fi	instance:Eq (PatternP loc)	line:142	language:Haskell
Textual	./parser-typechecker/src/Unison/Lexer.hs	/^  | Textual String   -- text literals, `"foo bar"`$/;"	cons	data:Lexeme	line:50	language:Haskell
ThreadMap	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^type ThreadMap = Map GUID ThreadId$/;"	t	line:120	language:Haskell
Tm	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^pattern Tm n t r as = Tm' (TermResult' n t r as)$/;"	pi	line:31	language:Haskell
Tm	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data SearchResult = Tp TypeResult | Tm TermResult deriving (Eq, Ord, Show)$/;"	cons	data:SearchResult	line:19	language:Haskell
Tm	./unison-core/src/Unison/ABT.hs	/^  | Tm (f r) deriving (Functor, Foldable, Traversable)$/;"	cons	data:ABT	line:34	language:Haskell
Tm'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^  = Tm' (TermResult' v a)$/;"	cons	data:SearchResult'	line:21	language:Haskell
Tm'	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^pattern Tm' hq r as = Tm (TermResult hq r as)$/;"	pi	line:33	language:Haskell
Tm'	./unison-core/src/Unison/ABT.hs	/^pattern Tm' f <- Term _ _ (Tm f)$/;"	pi	line:173	language:Haskell
ToIntN	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | ModN z z | ToIntN z$/;"	cons	data:IR'	line:215	language:Haskell
Todo	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Todo z$/;"	cons	data:IR'	line:223	language:Haskell
TodoI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | TodoI (Maybe PatchPath) Path'$/;"	cons	data:Input	line:92	language:Haskell
TodoOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TodoOutput PPE.PrettyPrintEnvDecl (TO.TodoOutput v Ann)$/;"	cons	data:Output	line:156	language:Haskell
TodoOutput	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^data TodoOutput v a = TodoOutput$/;"	d	line:23	language:Haskell
TodoOutput	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^data TodoOutput v a = TodoOutput$/;"	cons	data:TodoOutput	line:23	language:Haskell
Token	./parser-typechecker/src/Unison/Lexer.hs	/^data Token a = Token {$/;"	d	line:71	language:Haskell
Token	./parser-typechecker/src/Unison/Lexer.hs	/^data Token a = Token {$/;"	cons	data:Token	line:71	language:Haskell
Token	./parser-typechecker/src/Unison/Lexer.hs	/^  Token f start _ <*> Token a _ end = Token (f a) start end$/;"	fi	instance:Applicative Token	line:118	language:Haskell
Token	./parser-typechecker/src/Unison/Parser.hs	/^type Token s = P.Token s$/;"	t	line:47	language:Haskell
Token	./parser-typechecker/src/Unison/Parser.hs	/^  type Token Input = L.Token L.Lexeme$/;"	t	line:138	language:Haskell
Token	./unison-core/src/Unison/Hashable.hs	/^data Token h$/;"	d	line:10	language:Haskell
Tokens	./parser-typechecker/src/Unison/Parser.hs	/^  type Tokens Input = Input$/;"	t	line:139	language:Haskell
TopLevelComponent	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | TopLevelComponent [(v, Type.Type v loc, RedundantTypeAnnotation)]$/;"	cons	data:InfoNote	line:273	language:Haskell
TopLevelComponent	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  TopLevelComponent$/;"	cons	data:TypeInfo	line:86	language:Haskell
TopLevelComponentNotFound	./parser-typechecker/src/Unison/Result.hs	/^  = TopLevelComponentNotFound v (Term v loc)$/;"	cons	data:CompilerBug	line:42	language:Haskell
TotalCount	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^type TotalCount = Int -- total number of tests$/;"	t	line:236	language:Haskell
TotalM	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type TotalM v loc = MT v loc (Either (CompilerBug v loc))$/;"	t	line:184	language:Haskell
Tp	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^pattern Tp n t r as = Tp' (TypeResult' n t r as)$/;"	pi	line:32	language:Haskell
Tp	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data SearchResult = Tp TypeResult | Tm TermResult deriving (Eq, Ord, Show)$/;"	cons	data:SearchResult	line:19	language:Haskell
Tp'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^  | Tp' (TypeResult' v a)$/;"	cons	data:SearchResult'	line:22	language:Haskell
Tp'	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^pattern Tp' hq r as = Tp (TypeResult hq r as)$/;"	pi	line:34	language:Haskell
TreeMap	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^newtype TreeMap a b = TreeMap (Map.Map a (Maybe b, TreeMap a b))$/;"	nt	line:154	language:Haskell
Truncate0I	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | SignumI z | NegateI z | Truncate0I z | ModI z z$/;"	cons	data:IR'	line:211	language:Haskell
TuplePattern	./unison-core/src/Unison/DataDeclaration.hs	/^pattern TuplePattern ps <- (unTuplePattern -> Just ps)$/;"	pi	line:530	language:Haskell
TupleTerm'	./unison-core/src/Unison/DataDeclaration.hs	/^pattern TupleTerm' xs <- (unTupleTerm -> Just xs)$/;"	pi	line:529	language:Haskell
TupleType'	./unison-core/src/Unison/DataDeclaration.hs	/^pattern TupleType' ts <- (unTupleType -> Just ts)$/;"	pi	line:528	language:Haskell
Type	./parser-typechecker/src/Unison/Builtin.hs	/^type Type v = Type.Type v ()$/;"	t	line:53	language:Haskell
Type	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^type Type = Reference$/;"	t	line:15	language:Haskell
Type	./parser-typechecker/src/Unison/FileParsers.hs	/^type Type v = Type.Type v Ann$/;"	t	line:44	language:Haskell
Type	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type Type v loc = Type.Type (TypeVar v loc) loc$/;"	t	line:89	language:Haskell
Type	./parser-typechecker/tests/Unison/Test/Common.hs	/^type Type v = Type.Type v Ann$/;"	t	line:34	language:Haskell
Type	./unison-core/src/Unison/DataDeclaration.hs	/^  = Type (Type.F a)$/;"	cons	data:F	line:274	language:Haskell
Type	./unison-core/src/Unison/Paths.hs	/^type Type v = T.Type v ()$/;"	t	line:16	language:Haskell
Type	./unison-core/src/Unison/Paths.hs	/^  | Type (Type v)$/;"	cons	data:Target	line:21	language:Haskell
Type	./unison-core/src/Unison/Type.hs	/^type Type v a = ABT.Term F v a$/;"	t	line:59	language:Haskell
Type	./unison-core/src/Unison/Var.hs	/^data Type$/;"	d	line:85	language:Haskell
Type1	./parser-typechecker/src/Unison/PrintError.hs	/^pattern Type1 = Color.HiBlue$/;"	pi	line:64	language:Haskell
Type2	./parser-typechecker/src/Unison/PrintError.hs	/^pattern Type2 = Color.Green$/;"	pi	line:65	language:Haskell
TypeAlreadyExists	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TypeAlreadyExists Path.Split' (Set Reference)$/;"	cons	data:Output	line:99	language:Haskell
TypeAscriptionColon	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | TypeAscriptionColon$/;"	cons	data:Element	line:25	language:Haskell
TypeConstructor	./unison-core/src/Unison/Var.hs	/^  TypeConstructor | TypeConstructorArg |$/;"	cons	data:InferenceType	line:112	language:Haskell
TypeConstructorArg	./unison-core/src/Unison/Var.hs	/^  TypeConstructor | TypeConstructorArg |$/;"	cons	data:InferenceType	line:112	language:Haskell
TypeDeclarationErrors	./parser-typechecker/src/Unison/Parser.hs	/^  | TypeDeclarationErrors [UF.Error v Ann]$/;"	cons	data:Error	line:103	language:Haskell
TypeDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type TypeDisplay v a = (HashQualified, Reference, Maybe (DeclOrBuiltin v a), MetadataDiff (MetadataDisplay v a))$/;"	t	line:80	language:Haskell
TypeEdit	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^data TypeEdit = Replace Reference | Deprecate$/;"	d	line:7	language:Haskell
TypeError	./parser-typechecker/src/Unison/Result.hs	/^  | TypeError (Context.ErrorNote v loc)$/;"	cons	data:Note	line:36	language:Haskell
TypeError	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^                    | TypeError (NonEmptySeq (ErrorNote v loc)) (Seq (InfoNote v loc))$/;"	cons	data:Result	line:129	language:Haskell
TypeError	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  TypeError es is       <*> r'                      = TypeError (appendSeq es (typeErrors r')) (is <> infoNotes r')$/;"	fi	instance:Applicative (Result v loc)	line:139	language:Haskell
TypeError	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  TypeError es is       >>= _ = TypeError es is$/;"	fi	instance:Monad (Result v loc)	line:145	language:Haskell
TypeError	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data TypeError v loc$/;"	d	line:25	language:Haskell
TypeErrors	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TypeErrors Text PPE.PrettyPrintEnv [Context.ErrorNote v Ann]$/;"	cons	data:Output	line:141	language:Haskell
TypeHasFreeVars	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TypeHasFreeVars (Type v Ann)$/;"	cons	data:Output	line:102	language:Haskell
TypeInfo	./parser-typechecker/src/Unison/Result.hs	/^  | TypeInfo (Context.InfoNote v loc)$/;"	cons	data:Note	line:37	language:Haskell
TypeInfo	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data TypeInfo v loc =$/;"	d	line:85	language:Haskell
TypeKeyword	./parser-typechecker/src/Unison/PrintError.hs	/^pattern TypeKeyword = Color.Yellow$/;"	pi	line:67	language:Haskell
TypeLink	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | TypeLink R.Reference$/;"	cons	data:Value	line:81	language:Haskell
TypeLink	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  TypeLink r1 == TypeLink r2 = r1 == r2$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:107	language:Haskell
TypeLink	./unison-core/src/Unison/Term.hs	/^  | TypeLink Reference$/;"	cons	data:F	line:100	language:Haskell
TypeLink	./unison-core/src/Unison/Term.hs	/^  TypeLink x == TypeLink y = x == y$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1047	language:Haskell
TypeLink'	./unison-core/src/Unison/Term.hs	/^pattern TypeLink' r <- (ABT.out -> ABT.Tm (TypeLink r))$/;"	pi	line:420	language:Haskell
TypeLookup	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^data TypeLookup v a =$/;"	d	line:17	language:Haskell
TypeLookup	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^  TypeLookup { typeOfTerms :: Map Reference (Type v a)$/;"	cons	data:TypeLookup	line:18	language:Haskell
TypeMismatch	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  = TypeMismatch (Context v loc)$/;"	cons	data:Cause	line:277	language:Haskell
TypeNotFound	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TypeNotFound Path.HQSplit'$/;"	cons	data:Output	line:114	language:Haskell
TypeNotFound'	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TypeNotFound' ShortHash$/;"	cons	data:Output	line:116	language:Haskell
TypeNote	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^type TypeNote v loc = Either (TypeError v loc) (TypeInfo v loc)$/;"	t	line:90	language:Haskell
TypeOperator	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | TypeOperator$/;"	cons	data:Element	line:23	language:Haskell
TypeP	./parser-typechecker/src/Unison/TypeParser.hs	/^type TypeP v = P v (Type v Ann)$/;"	t	line:22	language:Haskell
TypeParseError	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | TypeParseError String (Parser.Err v)$/;"	cons	data:Output	line:100	language:Haskell
TypeReferencesByShortHash	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  TypeReferencesByShortHash :: ShortHash -> Command m i v (Set Reference)$/;"	c_gadt	d_gadt:Command	line:75	language:Haskell
TypeResolutionFailure	./unison-core/src/Unison/Names3.hs	/^  | TypeResolutionFailure v a (Set Reference)$/;"	cons	data:ResolutionFailure	line:35	language:Haskell
TypeResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data TypeResult = TypeResult$/;"	d	line:27	language:Haskell
TypeResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^data TypeResult = TypeResult$/;"	cons	data:TypeResult	line:27	language:Haskell
TypeResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^data TypeResult' v a =$/;"	d	line:27	language:Haskell
TypeResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^  TypeResult' HQ'.HashQualified (DisplayThing (Decl v a)) Reference (Set HQ'.HashQualified)$/;"	cons	data:TypeResult'	line:28	language:Haskell
TypeVar	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^type TypeVar v loc = TypeVar.TypeVar (B.Blank loc) v$/;"	t	line:88	language:Haskell
TypeVar	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^data TypeVar b v = Universal v | Existential b v deriving (Functor)$/;"	d	line:14	language:Haskell
Typecheck	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  Typecheck :: AmbientAbilities v$/;"	c_gadt	d_gadt:Command	line:89	language:Haskell
TypecheckFile	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^  TypecheckFile :: UF.UnisonFile v Ann$/;"	c_gadt	d_gadt:Command	line:95	language:Haskell
Typechecked	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | Typechecked SourceName PPE.PrettyPrintEnv (SlurpResult v) (UF.TypecheckedUnisonFile v Ann)$/;"	cons	data:Output	line:148	language:Haskell
TypecheckedUnisonFile	./parser-typechecker/src/Unison/UnisonFile.hs	/^data TypecheckedUnisonFile v a =$/;"	d	line:80	language:Haskell
TypecheckedUnisonFile	./parser-typechecker/src/Unison/UnisonFile.hs	/^  TypecheckedUnisonFile {$/;"	cons	data:TypecheckedUnisonFile	line:81	language:Haskell
TypecheckerBug	./parser-typechecker/src/Unison/Result.hs	/^  | TypecheckerBug (Context.CompilerBug v loc)$/;"	cons	data:CompilerBug	line:44	language:Haskell
TypecheckingResult	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^type TypecheckingResult v =$/;"	t	line:54	language:Haskell
Typing	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^data Typing = Same | Subtype | Different$/;"	d	line:20	language:Haskell
UIO	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^type UIO a = ExceptT IOError (ReaderT S IO) a$/;"	t	line:117	language:Haskell
Ucm	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^  = Ucm Hidden ExpectingError [UcmCommand]$/;"	cons	data:Stanza	line:59	language:Haskell
UcmCommand	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data UcmCommand = UcmCommand Path.Absolute Text$/;"	d	line:56	language:Haskell
UcmCommand	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^data UcmCommand = UcmCommand Path.Absolute Text$/;"	cons	data:UcmCommand	line:56	language:Haskell
UnannotatedReference	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnannotatedReference Reference$/;"	cons	data:CompilerBug	line:217	language:Haskell
Unbound	./unison-core/src/Unison/Pattern.hs	/^pattern Unbound = UnboundP ()$/;"	pi	line:98	language:Haskell
Unbound	./unison-core/src/Unison/PatternP.hs	/^pattern Unbound loc = P.UnboundP loc$/;"	pi	line:13	language:Haskell
UnboundP	./unison-core/src/Unison/Pattern.hs	/^  = UnboundP loc$/;"	cons	data:PatternP	line:37	language:Haskell
UnboundP	./unison-core/src/Unison/Pattern.hs	/^  UnboundP _ == UnboundP _ = True$/;"	fi	instance:Eq (PatternP loc)	line:132	language:Haskell
UnbreakCase	./parser-typechecker/src/Unison/TermParser.hs	/^data UnbreakCase =$/;"	d	line:366	language:Haskell
UndeclaredTermVariable	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UndeclaredTermVariable v (Context v loc)$/;"	cons	data:CompilerBug	line:211	language:Haskell
UnderapplyStrategy	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data UnderapplyStrategy e cont$/;"	d	line:156	language:Haskell
Underline	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  | Bold | Underline$/;"	cons	data:Color	line:21	language:Haskell
Undo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^data Undo = Undo {pastUndo, futureRedo :: [InsertMode]}$/;"	d	line:9	language:Haskell
Undo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^data Undo = Undo {pastUndo, futureRedo :: [InsertMode]}$/;"	cons	data:Undo	line:9	language:Haskell
UndoFailureReason	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^data UndoFailureReason = CantUndoPastStart | CantUndoPastMerge deriving Show$/;"	d	line:241	language:Haskell
UndoI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | UndoI$/;"	cons	data:Input	line:105	language:Haskell
UndoT	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^type UndoT = StateT Undo$/;"	t	line:11	language:Haskell
Unfenced	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^  | Unfenced Text$/;"	cons	data:Stanza	line:62	language:Haskell
UnguardedLetRecCycle	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnguardedLetRecCycle [v] [(v, Term v loc)]$/;"	cons	data:Cause	line:289	language:Haskell
UnguardedLetRecCycle	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | UnguardedLetRecCycle { cycle :: [v]$/;"	cons	data:TypeError	line:64	language:Haskell
UninitializedLetRecSlot	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | UninitializedLetRecSlot Symbol [(Symbol, IR e cont)] (IR e cont)$/;"	cons	data:Value	line:89	language:Haskell
Unique	./unison-core/src/Unison/DataDeclaration.hs	/^data Modifier = Structural | Unique Text -- | Opaque (Set Reference)$/;"	cons	data:Modifier	line:71	language:Haskell
UniqueName	./parser-typechecker/src/Unison/Parser.hs	/^newtype UniqueName = UniqueName (L.Pos -> Int -> Maybe Text)$/;"	nt	line:55	language:Haskell
Unison	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^  | Unison Hidden ExpectingError (Maybe ScratchFileName) Text$/;"	cons	data:Stanza	line:60	language:Haskell
Unison.ABT	./unison-core/src/Unison/ABT.hs	/^module Unison.ABT where$/;"	m	line:11	language:Haskell
Unison.Blank	./unison-core/src/Unison/Blank.hs	/^module Unison.Blank where$/;"	m	line:3	language:Haskell
Unison.Builtin	./parser-typechecker/src/Unison/Builtin.hs	/^module Unison.Builtin$/;"	m	line:7	language:Haskell
Unison.Codebase	./parser-typechecker/src/Unison/Codebase.hs	/^module Unison.Codebase where$/;"	m	line:3	language:Haskell
Unison.Codebase.Branch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^module Unison.Codebase.Branch$/;"	m	line:8	language:Haskell
Unison.Codebase.BranchDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^module Unison.Codebase.BranchDiff where$/;"	m	line:1	language:Haskell
Unison.Codebase.BranchLoadMode	./parser-typechecker/src/Unison/Codebase/BranchLoadMode.hs	/^module Unison.Codebase.BranchLoadMode where$/;"	m	line:1	language:Haskell
Unison.Codebase.BranchUtil	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^module Unison.Codebase.BranchUtil where$/;"	m	line:1	language:Haskell
Unison.Codebase.Causal	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^module Unison.Codebase.Causal where$/;"	m	line:4	language:Haskell
Unison.Codebase.Classes	./parser-typechecker/src/Unison/Codebase/Classes.hs	/^module Unison.Codebase.Classes where$/;"	m	line:5	language:Haskell
Unison.Codebase.CodeLookup	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^module Unison.Codebase.CodeLookup where$/;"	m	line:1	language:Haskell
Unison.Codebase.Editor.Command	./parser-typechecker/src/Unison/Codebase/Editor/Command.hs	/^module Unison.Codebase.Editor.Command ($/;"	m	line:3	language:Haskell
Unison.Codebase.Editor.DisplayThing	./parser-typechecker/src/Unison/Codebase/Editor/DisplayThing.hs	/^module Unison.Codebase.Editor.DisplayThing where$/;"	m	line:1	language:Haskell
Unison.Codebase.Editor.Git	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^module Unison.Codebase.Editor.Git$/;"	m	line:3	language:Haskell
Unison.Codebase.Editor.HandleCommand	./parser-typechecker/src/Unison/Codebase/Editor/HandleCommand.hs	/^module Unison.Codebase.Editor.HandleCommand where$/;"	m	line:10	language:Haskell
Unison.Codebase.Editor.HandleInput	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^module Unison.Codebase.Editor.HandleInput (loop, loopState0, LoopState(..), currentPath, parseSearchType) where$/;"	m	line:19	language:Haskell
Unison.Codebase.Editor.Input	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^module Unison.Codebase.Editor.Input$/;"	m	line:1	language:Haskell
Unison.Codebase.Editor.Output	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^module Unison.Codebase.Editor.Output$/;"	m	line:3	language:Haskell
Unison.Codebase.Editor.Output.BranchDiff	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^module Unison.Codebase.Editor.Output.BranchDiff where$/;"	m	line:6	language:Haskell
Unison.Codebase.Editor.Propagate	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^module Unison.Codebase.Editor.Propagate where$/;"	m	line:6	language:Haskell
Unison.Codebase.Editor.RemoteRepo	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^module Unison.Codebase.Editor.RemoteRepo where$/;"	m	line:3	language:Haskell
Unison.Codebase.Editor.SearchResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^module Unison.Codebase.Editor.SearchResult' where$/;"	m	line:3	language:Haskell
Unison.Codebase.Editor.SlurpComponent	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^module Unison.Codebase.Editor.SlurpComponent where$/;"	m	line:3	language:Haskell
Unison.Codebase.Editor.SlurpResult	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^module Unison.Codebase.Editor.SlurpResult where$/;"	m	line:6	language:Haskell
Unison.Codebase.Editor.TodoOutput	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^module Unison.Codebase.Editor.TodoOutput where$/;"	m	line:2	language:Haskell
Unison.Codebase.Editor.UriParser	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^module Unison.Codebase.Editor.UriParser (repoPath) where$/;"	m	line:4	language:Haskell
Unison.Codebase.Execute	./parser-typechecker/src/Unison/Codebase/Execute.hs	/^module Unison.Codebase.Execute where$/;"	m	line:14	language:Haskell
Unison.Codebase.FileCodebase	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^module Unison.Codebase.FileCodebase$/;"	m	line:8	language:Haskell
Unison.Codebase.GitError	./parser-typechecker/src/Unison/Codebase/GitError.hs	/^module Unison.Codebase.GitError where$/;"	m	line:1	language:Haskell
Unison.Codebase.MainTerm	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^module Unison.Codebase.MainTerm where$/;"	m	line:9	language:Haskell
Unison.Codebase.Metadata	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^module Unison.Codebase.Metadata where$/;"	m	line:1	language:Haskell
Unison.Codebase.NameEdit	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^module Unison.Codebase.NameEdit where$/;"	m	line:1	language:Haskell
Unison.Codebase.NameSegment	./unison-core/src/Unison/Codebase/NameSegment.hs	/^module Unison.Codebase.NameSegment where$/;"	m	line:6	language:Haskell
Unison.Codebase.Patch	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^module Unison.Codebase.Patch where$/;"	m	line:5	language:Haskell
Unison.Codebase.Path	./parser-typechecker/src/Unison/Codebase/Path.hs	/^module Unison.Codebase.Path where$/;"	m	line:6	language:Haskell
Unison.Codebase.Reflog	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^module Unison.Codebase.Reflog where$/;"	m	line:3	language:Haskell
Unison.Codebase.Runtime	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^module Unison.Codebase.Runtime where$/;"	m	line:5	language:Haskell
Unison.Codebase.SearchResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^module Unison.Codebase.SearchResult where$/;"	m	line:3	language:Haskell
Unison.Codebase.Serialization	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^module Unison.Codebase.Serialization where$/;"	m	line:4	language:Haskell
Unison.Codebase.Serialization.PutT	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^module Unison.Codebase.Serialization.PutT where$/;"	m	line:1	language:Haskell
Unison.Codebase.Serialization.V1	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^module Unison.Codebase.Serialization.V1 where$/;"	m	line:4	language:Haskell
Unison.Codebase.ShortBranchHash	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^module Unison.Codebase.ShortBranchHash where$/;"	m	line:1	language:Haskell
Unison.Codebase.TermEdit	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^module Unison.Codebase.TermEdit where$/;"	m	line:1	language:Haskell
Unison.Codebase.TranscriptParser	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^module Unison.Codebase.TranscriptParser ($/;"	m	line:5	language:Haskell
Unison.Codebase.TypeEdit	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^module Unison.Codebase.TypeEdit where$/;"	m	line:1	language:Haskell
Unison.Codebase.Watch	./parser-typechecker/src/Unison/Codebase/Watch.hs	/^module Unison.Codebase.Watch where$/;"	m	line:5	language:Haskell
Unison.Codecs	./parser-typechecker/src/Unison/Codecs.hs	/^module Unison.Codecs where$/;"	m	line:3	language:Haskell
Unison.CommandLine	./parser-typechecker/src/Unison/CommandLine.hs	/^module Unison.CommandLine where$/;"	m	line:9	language:Haskell
Unison.CommandLine.DisplayValues	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^module Unison.CommandLine.DisplayValues where$/;"	m	line:5	language:Haskell
Unison.CommandLine.InputPattern	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^module Unison.CommandLine.InputPattern where$/;"	m	line:9	language:Haskell
Unison.CommandLine.InputPatterns	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^module Unison.CommandLine.InputPatterns where$/;"	m	line:7	language:Haskell
Unison.CommandLine.Main	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^module Unison.CommandLine.Main where$/;"	m	line:8	language:Haskell
Unison.CommandLine.OutputMessages	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^module Unison.CommandLine.OutputMessages where$/;"	m	line:15	language:Haskell
Unison.ConstructorType	./unison-core/src/Unison/ConstructorType.hs	/^module Unison.ConstructorType where$/;"	m	line:1	language:Haskell
Unison.DataDeclaration	./unison-core/src/Unison/DataDeclaration.hs	/^module Unison.DataDeclaration where$/;"	m	line:11	language:Haskell
Unison.DeclPrinter	./parser-typechecker/src/Unison/DeclPrinter.hs	/^module Unison.DeclPrinter where$/;"	m	line:6	language:Haskell
Unison.FileParser	./parser-typechecker/src/Unison/FileParser.hs	/^module Unison.FileParser where$/;"	m	line:8	language:Haskell
Unison.FileParsers	./parser-typechecker/src/Unison/FileParsers.hs	/^module Unison.FileParsers where$/;"	m	line:6	language:Haskell
Unison.Hash	./unison-core/src/Unison/Hash.hs	/^module Unison.Hash (Hash, toBytes, base32Hex, base32Hexs, fromBase32Hex, fromBytes, unsafeFromBase32Hex, showBase32Hex, validBase32HexChars) where$/;"	m	line:4	language:Haskell
Unison.HashQualified	./unison-core/src/Unison/HashQualified.hs	/^module Unison.HashQualified where$/;"	m	line:3	language:Haskell
Unison.HashQualified'	./unison-core/src/Unison/HashQualified'.hs	/^module Unison.HashQualified' where$/;"	m	line:3	language:Haskell
Unison.Hashable	./unison-core/src/Unison/Hashable.hs	/^module Unison.Hashable where$/;"	m	line:3	language:Haskell
Unison.Kind	./unison-core/src/Unison/Kind.hs	/^module Unison.Kind where$/;"	m	line:3	language:Haskell
Unison.LabeledDependency	./unison-core/src/Unison/LabeledDependency.hs	/^module Unison.LabeledDependency (derivedTerm, derivedType, termRef, typeRef, referent, dataConstructor, effectConstructor, fold, referents, LabeledDependency) where$/;"	m	line:3	language:Haskell
Unison.Lexer	./parser-typechecker/src/Unison/Lexer.hs	/^module Unison.Lexer where$/;"	m	line:10	language:Haskell
Unison.Name	./unison-core/src/Unison/Name.hs	/^module Unison.Name$/;"	m	line:3	language:Haskell
Unison.NamePrinter	./parser-typechecker/src/Unison/NamePrinter.hs	/^module Unison.NamePrinter where$/;"	m	line:1	language:Haskell
Unison.Names2	./unison-core/src/Unison/Names2.hs	/^module Unison.Names2$/;"	m	line:7	language:Haskell
Unison.Names3	./unison-core/src/Unison/Names3.hs	/^module Unison.Names3 where$/;"	m	line:5	language:Haskell
Unison.Parser	./parser-typechecker/src/Unison/Parser.hs	/^module Unison.Parser where$/;"	m	line:6	language:Haskell
Unison.Parsers	./parser-typechecker/src/Unison/Parsers.hs	/^module Unison.Parsers where$/;"	m	line:1	language:Haskell
Unison.Path	./parser-typechecker/src/Unison/Path.hs	/^module Unison.Path where$/;"	m	line:7	language:Haskell
Unison.Paths	./unison-core/src/Unison/Paths.hs	/^module Unison.Paths where$/;"	m	line:4	language:Haskell
Unison.Pattern	./unison-core/src/Unison/Pattern.hs	/^module Unison.Pattern where$/;"	m	line:3	language:Haskell
Unison.PatternP	./unison-core/src/Unison/PatternP.hs	/^module Unison.PatternP where$/;"	m	line:3	language:Haskell
Unison.Prelude	./unison-core/src/Unison/Prelude.hs	/^module Unison.Prelude$/;"	m	line:1	language:Haskell
Unison.PrettyPrintEnv	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^module Unison.PrettyPrintEnv where$/;"	m	line:3	language:Haskell
Unison.PrettyTerminal	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^module Unison.PrettyTerminal where$/;"	m	line:1	language:Haskell
Unison.PrintError	./parser-typechecker/src/Unison/PrintError.hs	/^module Unison.PrintError where$/;"	m	line:10	language:Haskell
Unison.Reference	./unison-core/src/Unison/Reference.hs	/^module Unison.Reference$/;"	m	line:6	language:Haskell
Unison.Reference.Util	./unison-core/src/Unison/Reference/Util.hs	/^module Unison.Reference.Util where$/;"	m	line:1	language:Haskell
Unison.Referent	./unison-core/src/Unison/Referent.hs	/^module Unison.Referent where$/;"	m	line:4	language:Haskell
Unison.Result	./parser-typechecker/src/Unison/Result.hs	/^module Unison.Result where$/;"	m	line:7	language:Haskell
Unison.Runtime.ANF	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^module Unison.Runtime.ANF (optimize, fromTerm, fromTerm', term, minimizeCyclesOrCrash) where$/;"	m	line:9	language:Haskell
Unison.Runtime.IOSource	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^module Unison.Runtime.IOSource where$/;"	m	line:6	language:Haskell
Unison.Runtime.IR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^module Unison.Runtime.IR where$/;"	m	line:13	language:Haskell
Unison.Runtime.Rt1	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^module Unison.Runtime.Rt1 where$/;"	m	line:13	language:Haskell
Unison.Runtime.Rt1IO	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^module Unison.Runtime.Rt1IO where$/;"	m	line:8	language:Haskell
Unison.Runtime.SparseVector	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^module Unison.Runtime.SparseVector where$/;"	m	line:4	language:Haskell
Unison.Runtime.Vector	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^module Unison.Runtime.Vector where$/;"	m	line:3	language:Haskell
Unison.Settings	./unison-core/src/Unison/Settings.hs	/^module Unison.Settings where$/;"	m	line:1	language:Haskell
Unison.ShortHash	./unison-core/src/Unison/ShortHash.hs	/^module Unison.ShortHash where$/;"	m	line:4	language:Haskell
Unison.Symbol	./unison-core/src/Unison/Symbol.hs	/^module Unison.Symbol where$/;"	m	line:4	language:Haskell
Unison.Term	./unison-core/src/Unison/Term.hs	/^module Unison.Term where$/;"	m	line:13	language:Haskell
Unison.TermParser	./parser-typechecker/src/Unison/TermParser.hs	/^module Unison.TermParser where$/;"	m	line:11	language:Haskell
Unison.TermPrinter	./parser-typechecker/src/Unison/TermPrinter.hs	/^module Unison.TermPrinter where$/;"	m	line:7	language:Haskell
Unison.Test.ABT	./parser-typechecker/tests/Unison/Test/ABT.hs	/^module Unison.Test.ABT where$/;"	m	line:3	language:Haskell
Unison.Test.Codebase	./parser-typechecker/tests/Unison/Test/Codebase.hs	/^module Unison.Test.Codebase where$/;"	m	line:5	language:Haskell
Unison.Test.Codebase.Causal	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^module Unison.Test.Codebase.Causal where$/;"	m	line:4	language:Haskell
Unison.Test.Codebase.FileCodebase	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^module Unison.Test.Codebase.FileCodebase where$/;"	m	line:1	language:Haskell
Unison.Test.Codebase.Path	./parser-typechecker/tests/Unison/Test/Codebase/Path.hs	/^module Unison.Test.Codebase.Path where$/;"	m	line:3	language:Haskell
Unison.Test.ColorText	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^module Unison.Test.ColorText where$/;"	m	line:3	language:Haskell
Unison.Test.Common	./parser-typechecker/tests/Unison/Test/Common.hs	/^module Unison.Test.Common$/;"	m	line:3	language:Haskell
Unison.Test.DataDeclaration	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^module Unison.Test.DataDeclaration where$/;"	m	line:3	language:Haskell
Unison.Test.FileParser	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^module Unison.Test.FileParser where$/;"	m	line:3	language:Haskell
Unison.Test.Git	./parser-typechecker/tests/Unison/Test/Git.hs	/^module Unison.Test.Git where$/;"	m	line:4	language:Haskell
Unison.Test.Lexer	./parser-typechecker/tests/Unison/Test/Lexer.hs	/^module Unison.Test.Lexer where$/;"	m	line:1	language:Haskell
Unison.Test.Range	./parser-typechecker/tests/Unison/Test/Range.hs	/^module Unison.Test.Range where$/;"	m	line:1	language:Haskell
Unison.Test.Referent	./parser-typechecker/tests/Unison/Test/Referent.hs	/^module Unison.Test.Referent where$/;"	m	line:3	language:Haskell
Unison.Test.Term	./parser-typechecker/tests/Unison/Test/Term.hs	/^module Unison.Test.Term where$/;"	m	line:4	language:Haskell
Unison.Test.TermParser	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^module Unison.Test.TermParser where$/;"	m	line:5	language:Haskell
Unison.Test.TermPrinter	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^module Unison.Test.TermPrinter (test) where$/;"	m	line:3	language:Haskell
Unison.Test.Type	./parser-typechecker/tests/Unison/Test/Type.hs	/^module Unison.Test.Type where$/;"	m	line:3	language:Haskell
Unison.Test.TypePrinter	./parser-typechecker/tests/Unison/Test/TypePrinter.hs	/^module Unison.Test.TypePrinter where$/;"	m	line:1	language:Haskell
Unison.Test.Typechecker	./parser-typechecker/tests/Unison/Test/Typechecker.hs	/^module Unison.Test.Typechecker where$/;"	m	line:3	language:Haskell
Unison.Test.Typechecker.Components	./parser-typechecker/tests/Unison/Test/Typechecker/Components.hs	/^module Unison.Test.Typechecker.Components where$/;"	m	line:1	language:Haskell
Unison.Test.Typechecker.Context	./parser-typechecker/tests/Unison/Test/Typechecker/Context.hs	/^module Unison.Test.Typechecker.Context ( test )$/;"	m	line:4	language:Haskell
Unison.Test.Typechecker.TypeError	./parser-typechecker/tests/Unison/Test/Typechecker/TypeError.hs	/^module Unison.Test.Typechecker.TypeError where$/;"	m	line:4	language:Haskell
Unison.Test.UnisonSources	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^module Unison.Test.UnisonSources where$/;"	m	line:5	language:Haskell
Unison.Test.UriParser	./parser-typechecker/tests/Unison/Test/UriParser.hs	/^module Unison.Test.UriParser where$/;"	m	line:3	language:Haskell
Unison.Test.Util.Bytes	./parser-typechecker/tests/Unison/Test/Util/Bytes.hs	/^module Unison.Test.Util.Bytes where$/;"	m	line:1	language:Haskell
Unison.Test.Var	./parser-typechecker/tests/Unison/Test/Var.hs	/^module Unison.Test.Var where$/;"	m	line:3	language:Haskell
Unison.Type	./unison-core/src/Unison/Type.hs	/^module Unison.Type where$/;"	m	line:13	language:Haskell
Unison.TypeParser	./parser-typechecker/src/Unison/TypeParser.hs	/^module Unison.TypeParser where$/;"	m	line:3	language:Haskell
Unison.TypePrinter	./parser-typechecker/src/Unison/TypePrinter.hs	/^module Unison.TypePrinter where$/;"	m	line:6	language:Haskell
Unison.Typechecker	./parser-typechecker/src/Unison/Typechecker.hs	/^module Unison.Typechecker where$/;"	m	line:14	language:Haskell
Unison.Typechecker.Components	./parser-typechecker/src/Unison/Typechecker/Components.hs	/^module Unison.Typechecker.Components (minimize, minimize') where$/;"	m	line:1	language:Haskell
Unison.Typechecker.Context	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^module Unison.Typechecker.Context$/;"	m	line:14	language:Haskell
Unison.Typechecker.Extractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^module Unison.Typechecker.Extractor where$/;"	m	line:4	language:Haskell
Unison.Typechecker.TypeError	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^module Unison.Typechecker.TypeError where$/;"	m	line:4	language:Haskell
Unison.Typechecker.TypeLookup	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^module Unison.Typechecker.TypeLookup where$/;"	m	line:1	language:Haskell
Unison.Typechecker.TypeVar	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^module Unison.Typechecker.TypeVar where$/;"	m	line:4	language:Haskell
Unison.UnisonFile	./parser-typechecker/src/Unison/UnisonFile.hs	/^module Unison.UnisonFile where$/;"	m	line:7	language:Haskell
Unison.Util.AnnotatedText	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^module Unison.Util.AnnotatedText where$/;"	m	line:9	language:Haskell
Unison.Util.Bytes	./parser-typechecker/src/Unison/Util/Bytes.hs	/^module Unison.Util.Bytes where$/;"	m	line:6	language:Haskell
Unison.Util.ColorText	./parser-typechecker/src/Unison/Util/ColorText.hs	/^module Unison.Util.ColorText ($/;"	m	line:4	language:Haskell
Unison.Util.Components	./unison-core/src/Unison/Util/Components.hs	/^module Unison.Util.Components where$/;"	m	line:1	language:Haskell
Unison.Util.CycleTable	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^module Unison.Util.CycleTable where$/;"	m	line:1	language:Haskell
Unison.Util.CyclicEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^module Unison.Util.CyclicEq where$/;"	m	line:6	language:Haskell
Unison.Util.CyclicOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^module Unison.Util.CyclicOrd where$/;"	m	line:6	language:Haskell
Unison.Util.Exception	./parser-typechecker/src/Unison/Util/Exception.hs	/^module Unison.Util.Exception where$/;"	m	line:1	language:Haskell
Unison.Util.Find	./parser-typechecker/src/Unison/Util/Find.hs	/^module Unison.Util.Find ($/;"	m	line:5	language:Haskell
Unison.Util.Free	./parser-typechecker/src/Unison/Util/Free.hs	/^module Unison.Util.Free where$/;"	m	line:3	language:Haskell
Unison.Util.Less	./parser-typechecker/src/Unison/Util/Less.hs	/^module Unison.Util.Less where$/;"	m	line:1	language:Haskell
Unison.Util.List	./unison-core/src/Unison/Util/List.hs	/^module Unison.Util.List where$/;"	m	line:1	language:Haskell
Unison.Util.Logger	./parser-typechecker/src/Unison/Util/Logger.hs	/^module Unison.Util.Logger where$/;"	m	line:13	language:Haskell
Unison.Util.Map	./parser-typechecker/src/Unison/Util/Map.hs	/^module Unison.Util.Map$/;"	m	line:1	language:Haskell
Unison.Util.Menu	./parser-typechecker/src/Unison/Util/Menu.hs	/^module Unison.Util.Menu (menu1, menuN, groupMenuN) where$/;"	m	line:6	language:Haskell
Unison.Util.Monoid	./unison-core/src/Unison/Util/Monoid.hs	/^module Unison.Util.Monoid where$/;"	m	line:1	language:Haskell
Unison.Util.Pretty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^module Unison.Util.Pretty ($/;"	m	line:8	language:Haskell
Unison.Util.Range	./parser-typechecker/src/Unison/Util/Range.hs	/^module Unison.Util.Range where$/;"	m	line:1	language:Haskell
Unison.Util.Relation	./unison-core/src/Unison/Util/Relation.hs	/^module Unison.Util.Relation where$/;"	m	line:2	language:Haskell
Unison.Util.Relation3	./unison-core/src/Unison/Util/Relation3.hs	/^module Unison.Util.Relation3 where$/;"	m	line:3	language:Haskell
Unison.Util.Relation4	./unison-core/src/Unison/Util/Relation4.hs	/^module Unison.Util.Relation4 where$/;"	m	line:3	language:Haskell
Unison.Util.Set	./unison-core/src/Unison/Util/Set.hs	/^module Unison.Util.Set where$/;"	m	line:1	language:Haskell
Unison.Util.Star3	./parser-typechecker/src/Unison/Util/Star3.hs	/^module Unison.Util.Star3 where$/;"	m	line:3	language:Haskell
Unison.Util.SyntaxText	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^module Unison.Util.SyntaxText where$/;"	m	line:1	language:Haskell
Unison.Util.TQueue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^module Unison.Util.TQueue where$/;"	m	line:1	language:Haskell
Unison.Util.TransitiveClosure	./parser-typechecker/src/Unison/Util/TransitiveClosure.hs	/^module Unison.Util.TransitiveClosure where$/;"	m	line:3	language:Haskell
Unison.Var	./unison-core/src/Unison/Var.hs	/^module Unison.Var where$/;"	m	line:6	language:Haskell
UnisonFile	./parser-typechecker/src/Unison/FileParsers.hs	/^type UnisonFile v = UF.UnisonFile v Ann$/;"	t	line:45	language:Haskell
UnisonFile	./parser-typechecker/src/Unison/UnisonFile.hs	/^data UnisonFile v a = UnisonFile {$/;"	d	line:41	language:Haskell
UnisonFile	./parser-typechecker/src/Unison/UnisonFile.hs	/^data UnisonFile v a = UnisonFile {$/;"	cons	data:UnisonFile	line:41	language:Haskell
UnisonFileChanged	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  = UnisonFileChanged SourceName Source$/;"	cons	data:Event	line:25	language:Haskell
UnisonRuntimeException	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^newtype UnisonRuntimeException = UnisonRuntimeException Text$/;"	nt	line:104	language:Haskell
UnitRef	./unison-core/src/Unison/DataDeclaration.hs	/^pattern UnitRef <- (unUnitRef -> True)$/;"	pi	line:525	language:Haskell
Universal	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^pattern Universal v = Var (TypeVar.Universal v)$/;"	pi	line:94	language:Haskell
Universal	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^data TypeVar b v = Universal v | Existential b v deriving (Functor)$/;"	cons	data:TypeVar	line:14	language:Haskell
Universal	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  Universal v == Universal v2 = v == v2$/;"	fi	instance:Eq v => Eq (TypeVar b v)	line:17	language:Haskell
Unknown	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Unknown = Data | Effect deriving Show$/;"	d	line:206	language:Haskell
UnknownAbilityConstructor	./parser-typechecker/src/Unison/Parser.hs	/^  | UnknownAbilityConstructor (L.Token HQ.HashQualified) (Set (Reference, Int))$/;"	cons	data:Error	line:93	language:Haskell
UnknownConstructor	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnknownConstructor Unknown Reference Int (DataDeclaration' v loc)$/;"	cons	data:CompilerBug	line:210	language:Haskell
UnknownDataConstructor	./parser-typechecker/src/Unison/Parser.hs	/^  | UnknownDataConstructor (L.Token HQ.HashQualified) (Set (Reference, Int))$/;"	cons	data:Error	line:94	language:Haskell
UnknownDecl	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  = UnknownDecl Unknown Reference (Map Reference (DataDeclaration' v loc))$/;"	cons	data:CompilerBug	line:209	language:Haskell
UnknownExistentialVariable	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnknownExistentialVariable v (Context v loc)$/;"	cons	data:CompilerBug	line:220	language:Haskell
UnknownId	./parser-typechecker/src/Unison/Parser.hs	/^  | UnknownId (L.Token HQ.HashQualified) (Set Referent) (Set Reference)$/;"	cons	data:Error	line:97	language:Haskell
UnknownLexeme	./parser-typechecker/src/Unison/Lexer.hs	/^  | UnknownLexeme$/;"	cons	data:Err	line:34	language:Haskell
UnknownSymbol	./parser-typechecker/src/Unison/Result.hs	/^  | UnknownSymbol v loc$/;"	cons	data:Note	line:35	language:Haskell
UnknownSymbol	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnknownSymbol loc v$/;"	cons	data:Cause	line:279	language:Haskell
UnknownTerm	./parser-typechecker/src/Unison/Parser.hs	/^  | UnknownTerm (L.Token HQ.HashQualified) (Set Referent)$/;"	cons	data:Error	line:95	language:Haskell
UnknownTerm	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnknownTerm loc v [Suggestion v loc] (Type v loc)$/;"	cons	data:Cause	line:280	language:Haskell
UnknownTerm	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | UnknownTerm { unknownTermV :: v$/;"	cons	data:TypeError	line:71	language:Haskell
UnknownTermReference	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  | UnknownTermReference Reference$/;"	cons	data:CompilerBug	line:219	language:Haskell
UnknownType	./parser-typechecker/src/Unison/Parser.hs	/^  | UnknownType (L.Token HQ.HashQualified) (Set Reference)$/;"	cons	data:Error	line:96	language:Haskell
UnknownType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | UnknownType { unknownTypeV :: v$/;"	cons	data:TypeError	line:67	language:Haskell
UnknownType	./parser-typechecker/src/Unison/UnisonFile.hs	/^  = UnknownType v a$/;"	cons	data:Error	line:264	language:Haskell
UnknownTypeOrTerm	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^  | UnknownTypeOrTerm Reference$/;"	cons	data:Err	line:121	language:Haskell
UnlinkI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | UnlinkI [Path.HQSplit'] Path.HQSplit'$/;"	cons	data:Input	line:116	language:Haskell
UnnamedWatch	./unison-core/src/Unison/Var.hs	/^  | UnnamedWatch WatchKind Text -- guid$/;"	cons	data:Type	line:100	language:Haskell
UnprocessedFence	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^  | UnprocessedFence FenceType Text$/;"	cons	data:Stanza	line:61	language:Haskell
Unsatisfied	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^data FoldHistoryResult a = Satisfied a | Unsatisfied a deriving (Eq,Ord,Show)$/;"	cons	data:FoldHistoryResult	line:341	language:Haskell
UpKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^             | LeftKey | RightKey | DownKey | UpKey$/;"	cons	data:BaseKey	line:38	language:Haskell
Update	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  Add | Update | Duplicate | Collision | Conflicted |$/;"	cons	data:Status	line:128	language:Haskell
UpdateAliases	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  | UpdateAliases { oldRefNames :: Set Name$/;"	cons	data:Aliases	line:37	language:Haskell
UpdateBuiltinsI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^  | UpdateBuiltinsI$/;"	cons	data:Input	line:128	language:Haskell
UpdateI	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^    | UpdateI (Maybe PatchPath) [HQ'.HashQualified]$/;"	cons	data:Input	line:90	language:Haskell
UpdateTermDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type UpdateTermDisplay v a = (Maybe [SimpleTermDisplay v a], [TermDisplay v a])$/;"	t	line:91	language:Haskell
UpdateTypeDisplay	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^type UpdateTypeDisplay v a = (Maybe [SimpleTypeDisplay v a], [TypeDisplay v a])$/;"	t	line:92	language:Haskell
UrlPath	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^type UrlPath = Text$/;"	t	line:85	language:Haskell
UseEmpty	./parser-typechecker/src/Unison/Parser.hs	/^  | UseEmpty (L.Token String) -- an empty `use` statement$/;"	cons	data:Error	line:101	language:Haskell
UseInvalidPrefixSuffix	./parser-typechecker/src/Unison/Parser.hs	/^  | UseInvalidPrefixSuffix (Either (L.Token Name) (L.Token Name)) (Maybe [L.Token Name])$/;"	cons	data:Error	line:100	language:Haskell
UseKeyword	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | UseKeyword$/;"	cons	data:Element	line:33	language:Haskell
UsePrefix	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | UsePrefix$/;"	cons	data:Element	line:34	language:Haskell
UseSuffix	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | UseSuffix$/;"	cons	data:Element	line:35	language:Haskell
User	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data User = User Text$/;"	d	line:82	language:Haskell
User	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^data User = User Text$/;"	cons	data:User	line:82	language:Haskell
User	./unison-core/src/Unison/Var.hs	/^  = User Text$/;"	cons	data:Type	line:87	language:Haskell
V	./unison-core/src/Unison/ABT.hs	/^data V v = Free v | Bound v deriving (Eq,Ord,Show,Functor)$/;"	d	line:47	language:Haskell
Val	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  | Val (Value e cont)$/;"	cons	data:Z	line:197	language:Haskell
Value	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^type Value = Reference$/;"	t	line:16	language:Haskell
Value	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data Value e cont$/;"	d	line:78	language:Haskell
Value	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type Value = IR.Value ExternalFunction Continuation$/;"	t	line:46	language:Haskell
Var	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  = Var (TypeVar v loc)                    -- A variable declaration$/;"	cons	data:Element	line:111	language:Haskell
Var	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Var v == Var v2                = v == v2$/;"	fi	instance:(Ord loc, Var v) => Eq (Element v loc)	line:117	language:Haskell
Var	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^             | Var$/;"	cons	data:Element	line:15	language:Haskell
Var	./unison-core/src/Unison/ABT.hs	/^  = Var v$/;"	cons	data:ABT	line:31	language:Haskell
Var	./unison-core/src/Unison/ABT.hs	/^class Ord v => Var v where$/;"	c	line:44	language:Haskell
Var	./unison-core/src/Unison/Paths.hs	/^  | Var v$/;"	cons	data:Target	line:22	language:Haskell
Var	./unison-core/src/Unison/Pattern.hs	/^pattern Var = VarP ()$/;"	pi	line:99	language:Haskell
Var	./unison-core/src/Unison/PatternP.hs	/^pattern Var loc = P.VarP loc$/;"	pi	line:14	language:Haskell
Var	./unison-core/src/Unison/Var.hs	/^class (Show v, ABT.Var v) => Var v where$/;"	c	line:24	language:Haskell
Var Symbol	./unison-core/src/Unison/Symbol.hs	/^instance Var Symbol where$/;"	i	line:20	language:Haskell
Var SymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^instance Var SymbolC where$/;"	i	line:956	language:Haskell
Var v => Hashable1 (F v a p)	./unison-core/src/Unison/Term.hs	/^instance Var v => Hashable1 (F v a p) where$/;"	i	line:960	language:Haskell
Var v => Ord (ShallowListEntry v a)	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^instance Var v => Ord (ShallowListEntry v a) where$/;"	i	line:209	language:Haskell
Var v => Var (TypeVar b v)	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^instance Var v => Var (TypeVar b v) where$/;"	i	line:38	language:Haskell
Var v => Var (V v)	./unison-core/src/Unison/ABT.hs	/^instance Var v => Var (V v) where$/;"	i	line:53	language:Haskell
Var'	./unison-core/src/Unison/ABT.hs	/^pattern Var' v <- Term _ _ (Var v)$/;"	pi	line:168	language:Haskell
Var'	./unison-core/src/Unison/Term.hs	/^pattern Var' v <- ABT.Var' v$/;"	pi	line:408	language:Haskell
Var'	./unison-core/src/Unison/Type.hs	/^pattern Var' v <- ABT.Var' v$/;"	pi	line:122	language:Haskell
VarP	./unison-core/src/Unison/Pattern.hs	/^  | VarP loc$/;"	cons	data:PatternP	line:38	language:Haskell
VarP	./unison-core/src/Unison/Pattern.hs	/^  VarP _ == VarP _ = True$/;"	fi	instance:Eq (PatternP loc)	line:133	language:Haskell
Vec	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^data Vec a where$/;"	d_gadt	line:11	language:Haskell
Vec	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^  Vec :: UV.Unbox a => UV.Vector a -> Vec a$/;"	c_gadt	d_gadt:Vec	line:13	language:Haskell
VectorBody	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^data ExistentialMismatch = IfBody | VectorBody | CaseBody$/;"	cons	data:ExistentialMismatch	line:22	language:Haskell
Version	./parser-typechecker/unison/Version.hs	/^module Version where$/;"	m	line:4	language:Haskell
Vi	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data EditMode = Vi | Emacs$/;"	cons	data:EditMode	line:61	language:Haskell
ViState	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^data ViState m = ViState { $/;"	d	line:20	language:Haskell
ViState	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^data ViState m = ViState { $/;"	cons	data:ViState	line:20	language:Haskell
ViT	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^type ViT m = StateT (ViState m) (InputCmdT m)$/;"	t	line:31	language:Haskell
VisualBell	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data BellStyle = NoBell | VisualBell | AudibleBell$/;"	cons	data:BellStyle	line:58	language:Haskell
WarnIncomingRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  | WarnIncomingRootBranch (Set ShortBranchHash)$/;"	cons	data:Output	line:182	language:Haskell
WatchBinding	./parser-typechecker/src/Unison/FileParser.hs	/^  = WatchBinding UF.WatchKind Ann ((Ann, v), term)$/;"	cons	data:Stanza	line:98	language:Haskell
WatchExpression	./parser-typechecker/src/Unison/FileParser.hs	/^  | WatchExpression UF.WatchKind Text Ann term$/;"	cons	data:Stanza	line:99	language:Haskell
WatchKind	./parser-typechecker/src/Unison/UnisonFile.hs	/^type WatchKind = Var.WatchKind$/;"	t	line:58	language:Haskell
WatchKind	./unison-core/src/Unison/Var.hs	/^type WatchKind = String$/;"	t	line:103	language:Haskell
White	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Width	./parser-typechecker/src/Unison/Util/Pretty.hs	/^type Width = Int$/;"	t	line:122	language:Haskell
Window	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^data Window = Window {pos :: Int -- ^ # of visible chars to left of cursor$/;"	d	line:17	language:Haskell
Window	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^data Window = Window {pos :: Int -- ^ # of visible chars to left of cursor$/;"	cons	data:Window	line:17	language:Haskell
WindowEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^           | WindowEvent$/;"	cons	data:InputEvent	line:127	language:Haskell
WindowResize	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^  = WindowResize$/;"	cons	data:Event	line:119	language:Haskell
WordyId	./parser-typechecker/src/Unison/Lexer.hs	/^  | WordyId String   (Maybe ShortHash) -- a (non-infix) identifier$/;"	cons	data:Lexeme	line:53	language:Haskell
Wrap	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  = Empty | Group r | Lit s | Wrap (Seq r) | OrElse r r | Append (Seq r)$/;"	cons	data:F	line:131	language:Haskell
WrapHandler	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  = WrapHandler Value Continuation$/;"	cons	data:Continuation	line:55	language:Haskell
WrongName	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data SuggestionMatch = Exact | WrongType | WrongName$/;"	cons	data:SuggestionMatch	line:249	language:Haskell
WrongType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data SuggestionMatch = Exact | WrongType | WrongName$/;"	cons	data:SuggestionMatch	line:249	language:Haskell
X	./unison-core/src/Unison/LabeledDependency.hs	/^newtype LabeledDependency = X (Either Reference Referent) deriving (Eq, Ord, Show)$/;"	cons	newtype:LabeledDependency	line:13	language:Haskell
Yellow	./parser-typechecker/src/Unison/Util/ColorText.hs	/^  =  Black | Red | Green | Yellow | Blue | Purple | Cyan | White$/;"	cons	data:Color	line:19	language:Haskell
Z	./parser-typechecker/src/Unison/Runtime/IR.hs	/^data Z e cont$/;"	d	line:194	language:Haskell
Z	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^type Z = IR.Z ExternalFunction Continuation$/;"	t	line:47	language:Haskell
ZeroPlus	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  | ZeroPlus -- 0 or more, at the end$/;"	cons	data:IsOptional	line:24	language:Haskell
_	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  _ == _ = False$/;"	fi	instance:(Eq cont, Eq e) => Eq (Value e cont)	line:108	language:Haskell
_	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  _ == _ = False$/;"	fi	instance:(Eq cont, Eq e) => Eq (UnderapplyStrategy e cont)	line:113	language:Haskell
_	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  _ == _ = False$/;"	fi	instance:(Ord loc, Var v) => Eq (Element v loc)	line:121	language:Haskell
_	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  _ == _ = False$/;"	fi	instance:Eq v => Eq (TypeVar b v)	line:19	language:Haskell
_	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  _ == _ = False$/;"	fi	instance:Eq Bytes	line:93	language:Haskell
_	./unison-core/src/Unison/Pattern.hs	/^  _ == _ = False$/;"	fi	instance:Eq (PatternP loc)	line:145	language:Haskell
_	./unison-core/src/Unison/Term.hs	/^  _ == _ = False$/;"	fi	instance:(ABT-Var vt, Eq at, Eq a) => Eq (F vt at p a)	line:1062	language:Haskell
_1	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^_1 :: (UV.Unbox a, UV.Unbox b) => SparseVector bits (a,b) -> SparseVector bits a$/;"	ft	signature:((UV.Unbox a, UV.Unbox b) => SparseVector bits (a, b) -> SparseVector bits a)	line:71	language:Haskell
_2	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^_2 :: (UV.Unbox a, UV.Unbox b) => SparseVector bits (a,b) -> SparseVector bits b$/;"	ft	signature:((UV.Unbox a, UV.Unbox b) => SparseVector bits (a, b) -> SparseVector bits b)	line:74	language:Haskell
_Cons	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  _Cons = prism (uncurry cons) uncons where$/;"	fi	instance:Cons Path Path NameSegment NameSegment	line:332	language:Haskell
_Snoc	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  _Snoc = prism (uncurry snocRelative) $ \\case$/;"	fi	instance:Snoc Relative Relative NameSegment NameSegment	line:341	language:Haskell
_Snoc	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  _Snoc = prism (uncurry snocAbsolute) $ \\case$/;"	fi	instance:Snoc Absolute Absolute NameSegment NameSegment	line:349	language:Haskell
_Snoc	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  _Snoc = prism (uncurry snoc) unsnoc$/;"	fi	instance:Snoc Path Path NameSegment NameSegment	line:357	language:Haskell
_Snoc	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  _Snoc = prism (uncurry snoc') $ \\case$/;"	fi	instance:Snoc Path' Path' NameSegment NameSegment	line:367	language:Haskell
_Snoc	./unison-core/src/Unison/Codebase/NameSegment.hs	/^  _Snoc = Lens.prism snoc unsnoc$/;"	fi	instance:Lens-Snoc Name Name NameSegment NameSegment	line:46	language:Haskell
_addedTermEdits	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  { _addedTermEdits :: Relation Reference TermEdit$/;"	c_a	cons:PatchDiff.PatchDiff	line:32	language:Haskell
_addedTypeEdits	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  , _addedTypeEdits :: Relation Reference TypeEdit$/;"	c_a	cons:PatchDiff.PatchDiff	line:33	language:Haskell
_ambientAbilities	./parser-typechecker/src/Unison/Typechecker.hs	/^  { _ambientAbilities  :: [Type v loc]$/;"	c_a	cons:Env.Env	line:68	language:Haskell
_any	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^_any :: SubseqExtractor v loc ()$/;"	ft	signature:(SubseqExtractor v loc ())	line:96	language:Haskell
_any'	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^_any' :: (n -> Int) -> SubseqExtractor' n ()$/;"	ft	signature:((n -> Int) -> SubseqExtractor' n ())	line:102	language:Haskell
_children	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , _children :: Map NameSegment (Branch m)$/;"	c_a	cons:Branch0.Branch0	line:164	language:Haskell
_childrenR	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , _childrenR :: Map NameSegment Hash$/;"	c_a	cons:Raw.Raw	line:205	language:Haskell
_currentPathStack	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^      , _currentPathStack :: NonEmpty Path.Absolute$/;"	c_a	cons:LoopState.LoopState	line:145	language:Haskell
_edits	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , _edits :: Map NameSegment (EditHash, m Patch)$/;"	c_a	cons:Branch0.Branch0	line:165	language:Haskell
_editsR	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , _editsR :: Map NameSegment EditHash$/;"	c_a	cons:Raw.Raw	line:206	language:Haskell
_fromNames	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^_fromNames :: Names0 -> [SearchResult]$/;"	ft	signature:(Names0 -> [SearchResult])	line:76	language:Haskell
_handleMap	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^  { _handleMap :: HandleMap$/;"	c_a	cons:IOState.IOState	line:112	language:Haskell
_history	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^newtype Branch m = Branch { _history :: Causal m Raw (Branch0 m) }$/;"	c_a	cons:Branch.Branch	line:152	language:Haskell
_hqTermAliases	./unison-core/src/Unison/Names2.hs	/^_hqTermAliases :: Ord n => Names' n -> n -> Referent -> Set (HQ.HashQualified' n)$/;"	ft	signature:(Ord n => Names' n -> n -> Referent -> Set (HQ.HashQualified' n))	line:256	language:Haskell
_hqTermName	./unison-core/src/Unison/Names2.hs	/^_hqTermName :: Ord n => Names' n -> n -> Referent -> HQ.HashQualified' n$/;"	ft	signature:(Ord n => Names' n -> n -> Referent -> HQ.HashQualified' n)	line:242	language:Haskell
_hqTermName'	./unison-core/src/Unison/Names2.hs	/^_hqTermName' :: Names' n -> n -> Referent -> HQ.HashQualified' n$/;"	ft	signature:(Names' n -> n -> Referent -> HQ.HashQualified' n)	line:269	language:Haskell
_hqTypeAliases	./unison-core/src/Unison/Names2.hs	/^_hqTypeAliases ::$/;"	ft	signature:(Ord n => Names' n -> n -> Reference -> Set (HQ.HashQualified' n))	line:252	language:Haskell
_hqTypeName	./unison-core/src/Unison/Names2.hs	/^_hqTypeName :: Ord n => Names' n -> n -> Reference -> HQ.HashQualified' n$/;"	ft	signature:(Ord n => Names' n -> n -> Reference -> HQ.HashQualified' n)	line:247	language:Haskell
_hqTypeName'	./unison-core/src/Unison/Names2.hs	/^_hqTypeName' :: Names' n -> n -> Reference -> HQ.HashQualified' n$/;"	ft	signature:(Names' n -> n -> Reference -> HQ.HashQualified' n)	line:273	language:Haskell
_ioState	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^newtype S = S {_ioState :: MVar IOState }$/;"	c_a	cons:S.S	line:122	language:Haskell
_lastInput	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^      , _lastInput :: Maybe Input$/;"	c_a	cons:LoopState.LoopState	line:158	language:Haskell
_latestFile	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^      , _latestFile :: Maybe (FilePath, SkipNextUpdate)$/;"	c_a	cons:LoopState.LoopState	line:153	language:Haskell
_latestTypecheckedFile	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^      , _latestTypecheckedFile :: Maybe (UF.TypecheckedUnisonFile v Ann)$/;"	c_a	cons:LoopState.LoopState	line:154	language:Haskell
_liftToAction	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^_liftToAction :: m a -> Action m i v a$/;"	ft	signature:(m a -> Action m i v a)	line:138	language:Haskell
_logContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^_logContext :: (Ord loc, Var v) => String -> M v loc ()$/;"	ft	signature:((Ord loc, Var v) => String -> M v loc ())	line:437	language:Haskell
_no	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^_no :: SubseqExtractor' n a -> SubseqExtractor' n ()$/;"	ft	signature:(SubseqExtractor' n a -> SubseqExtractor' n ())	line:71	language:Haskell
_numberedArgs	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^      , _numberedArgs :: NumberedArgs$/;"	c_a	cons:LoopState.LoopState	line:163	language:Haskell
_posToEnglish	./parser-typechecker/src/Unison/PrintError.hs	/^_posToEnglish :: IsString s => L.Pos -> s$/;"	ft	signature:(IsString s => L.Pos -> s)	line:800	language:Haskell
_printArrowsAtPos	./parser-typechecker/src/Unison/PrintError.hs	/^_printArrowsAtPos :: String -> Int -> Int -> String$/;"	ft	signature:(String -> Int -> Int -> String)	line:884	language:Haskell
_printPosRange	./parser-typechecker/src/Unison/PrintError.hs	/^_printPosRange :: String -> L.Pos -> L.Pos -> String$/;"	ft	signature:(String -> L.Pos -> L.Pos -> String)	line:878	language:Haskell
_removedTermEdits	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  , _removedTermEdits :: Relation Reference TermEdit$/;"	c_a	cons:PatchDiff.PatchDiff	line:34	language:Haskell
_removedTypeEdits	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  , _removedTypeEdits :: Relation Reference TypeEdit$/;"	c_a	cons:PatchDiff.PatchDiff	line:35	language:Haskell
_repeatMenu1	./parser-typechecker/src/Unison/Util/Menu.hs	/^_repeatMenu1 :: forall a mc$/;"	ft	signature:(forall a mc . Console -> Caption -> (a -> Stylized) -> (mc -> Stylized) -> [([Keyword], [a])] -> [([Keyword], mc)] -> Maybe Keyword -> IO (Either mc [a]))	line:103	language:Haskell
_repeatMenu1	./parser-typechecker/src/Unison/Util/Menu.hs	/^_repeatMenu1 console caption render renderMeta groups metas initial =$/;"	fi	line:112	language:Haskell
_root	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^      { _root :: Branch m$/;"	c_a	cons:LoopState.LoopState	line:143	language:Haskell
_searchBranchPrefix	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^_searchBranchPrefix :: Branch m -> Name -> [SearchResult]$/;"	ft	signature:(Branch m -> Name -> [SearchResult])	line:1771	language:Haskell
_socketMap	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^  , _socketMap :: SocketMap$/;"	c_a	cons:IOState.IOState	line:113	language:Haskell
_stripTextPrefix	./unison-core/src/Unison/Name.hs	/^_stripTextPrefix :: Text -> Name -> Maybe Name$/;"	ft	signature:(Text -> Name -> Maybe Name)	line:79	language:Haskell
_termEdits	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  { _termEdits :: Relation Reference TermEdit$/;"	c_a	cons:Patch.Patch	line:27	language:Haskell
_terms	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  { _terms :: Star Referent NameSegment$/;"	c_a	cons:Branch0.Branch0	line:162	language:Haskell
_termsR	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  { _termsR :: Star Referent NameSegment$/;"	c_a	cons:Raw.Raw	line:203	language:Haskell
_threadMap	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^  , _threadMap :: ThreadMap$/;"	c_a	cons:IOState.IOState	line:114	language:Haskell
_typeEdits	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  , _typeEdits :: Relation Reference TypeEdit$/;"	c_a	cons:Patch.Patch	line:28	language:Haskell
_typeLookup	./parser-typechecker/src/Unison/Typechecker.hs	/^  , _typeLookup        :: TL.TypeLookup v loc$/;"	c_a	cons:Env.Env	line:69	language:Haskell
_types	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , _types :: Star Reference NameSegment$/;"	c_a	cons:Branch0.Branch0	line:163	language:Haskell
_typesR	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , _typesR :: Star Reference NameSegment$/;"	c_a	cons:Raw.Raw	line:204	language:Haskell
_unionLeftRef	./unison-core/src/Unison/Names2.hs	/^_unionLeftRef :: Ord n => Names' n -> Names' n -> Names' n$/;"	ft	signature:(Ord n => Names' n -> Names' n -> Names' n)	line:148	language:Haskell
_unqualifiedTerms	./parser-typechecker/src/Unison/Typechecker.hs	/^  , _unqualifiedTerms  :: Map Name [NamedReference v loc]$/;"	c_a	cons:Env.Env	line:70	language:Haskell
`	./parser-typechecker/tests/Unison/Test/Git.hs	/^```unison$/;"	fi	line:46	language:Haskell
`	./parser-typechecker/tests/Unison/Test/Git.hs	/^```$/;"	fi	line:48	language:Haskell
a	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  a == b = view terms a == view terms b$/;"	fi	instance:Eq (Branch0 m)	line:433	language:Haskell
a	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  a == b = currentHash a == currentHash b$/;"	fi	instance:Eq (Causal m h a)	line:157	language:Haskell
a	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  a <= b = currentHash a <= currentHash b$/;"	fi	instance:Ord (Causal m h a)	line:160	language:Haskell
a	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  a <> b = MetadataDiff (addedMetadata a <> addedMetadata b)$/;"	fi	instance:Semigroup (MetadataDiff tm)	line:40	language:Haskell
a	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  a <> b = Patch (_termEdits a <> _termEdits b)$/;"	fi	instance:Semigroup Patch	line:116	language:Haskell
a	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  a <> b = PatchDiff$/;"	fi	instance:Semigroup PatchDiff	line:128	language:Haskell
a	./parser-typechecker/src/Unison/Parser.hs	/^  a <> External = a$/;"	fi	instance:Semigroup Ann	line:127	language:Haskell
a	./parser-typechecker/src/Unison/Parser.hs	/^  a <> Intrinsic = a$/;"	fi	instance:Semigroup Ann	line:129	language:Haskell
abilities	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  abilities :: [Type v loc],           -- Allowed ambient abilities$/;"	c_a	cons:MEnv.MEnv	line:318	language:Haskell
abilityCheck	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^abilityCheck :: (Var v, Ord loc) => [Type v loc] -> M v loc ()$/;"	ft	signature:((Var v, Ord loc) => [Type v loc] -> M v loc ())	line:1630	language:Haskell
abilityCheck'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^abilityCheck' :: forall v loc . (Var v, Ord loc) => [Type v loc] -> [Type v loc] -> M v loc ()$/;"	ft	signature:(forall v loc . (Var v, Ord loc) => [Type v loc] -> [Type v loc] -> M v loc ())	line:1574	language:Haskell
abilityCheckFailure	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^abilityCheckFailure = cause >>= \\case$/;"	fi	line:257	language:Haskell
abilityCheckFailure	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^abilityCheckFailure :: Ex.ErrorExtractor v a (TypeError v a)$/;"	ft	signature:(Ex.ErrorExtractor v a (TypeError v a))	line:129	language:Haskell
abilityCheckFailureSite	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , abilityCheckFailureSite :: loc$/;"	c_a	cons:TypeError.AbilityCheckFailure	line:61	language:Haskell
abilityNamed	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^abilityNamed :: String -> R.Reference$/;"	ft	signature:(String -> R.Reference)	line:57	language:Haskell
abs	./unison-core/src/Unison/ABT.hs	/^abs :: Ord v => v -> Term f v () -> Term f v ()$/;"	ft	signature:(Ord v => v -> Term f v () -> Term f v ())	line:194	language:Haskell
abs'	./unison-core/src/Unison/ABT.hs	/^abs' :: Ord v => a -> v -> Term f v a -> Term f v a$/;"	ft	signature:(Ord v => a -> v -> Term f v a -> Term f v a)	line:197	language:Haskell
absChain	./unison-core/src/Unison/ABT.hs	/^absChain :: Ord v => [v] -> Term f v () -> Term f v ()$/;"	ft	signature:(Ord v => [v] -> Term f v () -> Term f v ())	line:207	language:Haskell
absChain'	./unison-core/src/Unison/ABT.hs	/^absChain' :: Ord v => [(a, v)] -> Term f v a -> Term f v a$/;"	ft	signature:(Ord v => [(a, v)] -> Term f v a -> Term f v a)	line:213	language:Haskell
absCycle	./unison-core/src/Unison/ABT.hs	/^absCycle :: Ord v => [v] -> Term f v () -> Term f v ()$/;"	ft	signature:(Ord v => [v] -> Term f v () -> Term f v ())	line:210	language:Haskell
absoluteEmpty	./parser-typechecker/src/Unison/Codebase/Path.hs	/^absoluteEmpty :: Absolute$/;"	ft	signature:(Absolute)	line:223	language:Haskell
absoluteToPath'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^absoluteToPath' :: Absolute -> Path'$/;"	ft	signature:(Absolute -> Path')	line:49	language:Haskell
absr	./unison-core/src/Unison/ABT.hs	/^absr :: (Functor f, Foldable f, Var v) => v -> Term f (V v) () -> Term f (V v) ()$/;"	ft	signature:((Functor f, Foldable f, Var v) => v -> Term f (V v) () -> Term f (V v) ())	line:200	language:Haskell
absr'	./unison-core/src/Unison/ABT.hs	/^absr' :: (Functor f, Foldable f, Var v) => a -> v -> Term f (V v) a -> Term f (V v) a$/;"	ft	signature:((Functor f, Foldable f, Var v) => a -> v -> Term f (V v) a -> Term f (V v) a)	line:204	language:Haskell
ac	./parser-typechecker/src/Unison/TermPrinter.hs	/^ac :: Int -> BlockContext -> Imports -> DocLiteralContext -> AmbientContext$/;"	ft	signature:(Int -> BlockContext -> Imports -> DocLiteralContext -> AmbientContext)	line:622	language:Haskell
acceptOneChar	./yaks/haskeline/System/Console/Haskeline.hs	/^acceptOneChar :: Monad m => KeyCommand m InsertMode (Maybe Char)$/;"	ft	signature:(Monad m => KeyCommand m InsertMode (Maybe Char))	line:223	language:Haskell
accumulate	./unison-core/src/Unison/Hash.hs	/^  accumulate = fromBytes . BA.convert . CH.hashFinalize . go CH.hashInit where$/;"	fi	instance:H-Accumulate Hash	line:37	language:Haskell
accumulate	./unison-core/src/Unison/Hashable.hs	/^  accumulate :: [Token h] -> h$/;"	ft	signature:([Token h] -> h)	class:Accumulate	line:20	language:Haskell
accumulate'	./unison-core/src/Unison/Hashable.hs	/^accumulate' :: (Accumulate h, Hashable t) => t -> h$/;"	ft	signature:((Accumulate h, Hashable t) => t -> h)	line:27	language:Haskell
accumulateToken	./unison-core/src/Unison/Hashable.hs	/^accumulateToken :: (Accumulate h, Hashable t) => t -> Token h$/;"	ft	signature:((Accumulate h, Hashable t) => t -> Token h)	line:24	language:Haskell
actBell	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^actBell :: (Term m, MonadReader Prefs m) => m ()$/;"	ft	signature:((Term m, MonadReader Prefs m) => m ())	line:94	language:Haskell
add	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^add :: InputPattern$/;"	ft	signature:(InputPattern)	line:139	language:Haskell
addChar	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^addChar :: Char -> SearchMode -> SearchMode$/;"	ft	signature:(Char -> SearchMode -> SearchMode)	line:106	language:Haskell
addCombiner	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^addCombiner :: Grapheme -> Char -> Grapheme$/;"	ft	signature:(Grapheme -> Char -> Grapheme)	line:100	language:Haskell
addCustomBinding	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^addCustomBinding :: String -> Prefs -> Prefs$/;"	ft	signature:(String -> Prefs -> Prefs)	line:104	language:Haskell
addCustomKeySequence	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^addCustomKeySequence :: String -> Prefs -> Prefs$/;"	ft	signature:(String -> Prefs -> Prefs)	line:109	language:Haskell
addDefsToCodebase	./parser-typechecker/src/Unison/Codebase.hs	/^addDefsToCodebase :: forall m v a. (Monad m, Var v)$/;"	ft	signature:(forall m v a. (Monad m, Var v) => Codebase m v a -> UF.TypecheckedUnisonFile v a -> m ())	line:117	language:Haskell
addFromNames0	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^addFromNames0 :: Monad m => Names0 -> Branch0 m -> Branch0 m$/;"	ft	signature:(Monad m => Names0 -> Branch0 m -> Branch0 m)	line:29	language:Haskell
addHistory	./yaks/haskeline/System/Console/Haskeline/History.hs	/^addHistory :: String -> History -> History$/;"	ft	signature:(String -> History -> History)	line:85	language:Haskell
addHistoryRemovingAllDupes	./yaks/haskeline/System/Console/Haskeline/History.hs	/^addHistoryRemovingAllDupes :: String -> History -> History$/;"	ft	signature:(String -> History -> History)	line:106	language:Haskell
addHistoryUnlessConsecutiveDupe	./yaks/haskeline/System/Console/Haskeline/History.hs	/^addHistoryUnlessConsecutiveDupe :: String -> History -> History$/;"	ft	signature:(String -> History -> History)	line:99	language:Haskell
addNum	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^addNum :: Int -> ArgMode s -> ArgMode s$/;"	ft	signature:(Int -> ArgMode s -> ArgMode s)	line:361	language:Haskell
addPasswordChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^addPasswordChar :: Char -> Password -> Password$/;"	ft	signature:(Char -> Password -> Password)	line:400	language:Haskell
addQuotes	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^addQuotes :: Completion -> Completion$/;"	ft	signature:(Completion -> Completion)	line:133	language:Haskell
addRunMain	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^addRunMain mainName Nothing = do$/;"	fi	line:2537	language:Haskell
addTerm	./unison-core/src/Unison/Names2.hs	/^addTerm :: Ord n => n -> Referent -> Names' n -> Names' n$/;"	ft	signature:(Ord n => n -> Referent -> Names' n -> Names' n)	line:207	language:Haskell
addTermName	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^addTermName r new md =$/;"	fi	line:771	language:Haskell
addType	./unison-core/src/Unison/Names2.hs	/^addType :: Ord n => n -> Reference -> Names' n -> Names' n$/;"	ft	signature:(Ord n => n -> Reference -> Names' n -> Names' n)	line:204	language:Haskell
addTypeName	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^addTypeName r new md =$/;"	fi	line:776	language:Haskell
added	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^  NameEdit { added :: Set Reference, removed :: Set Reference }$/;"	c_a	cons:NameEdit.NameEdit	line:9	language:Haskell
addedMetadata	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  MetadataDiff { addedMetadata :: [tm]$/;"	c_a	cons:MetadataDiff.MetadataDiff	line:35	language:Haskell
addedNames	./unison-core/src/Unison/Names3.hs	/^       , addedNames    :: Names0$/;"	c_a	cons:Diff.Diff	line:73	language:Haskell
addedPatches	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  addedPatches      :: [PatchDisplay],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:58	language:Haskell
addedTerms	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  { addedTerms :: Star Referent NameSegment$/;"	c_a	cons:BranchDiff.BranchDiff	line:180	language:Haskell
addedTerms	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  addedTerms        :: [AddedTermDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:57	language:Haskell
addedTypes	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , addedTypes :: Star Reference NameSegment$/;"	c_a	cons:BranchDiff.BranchDiff	line:182	language:Haskell
addedTypes	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  addedTypes        :: [AddedTypeDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:56	language:Haskell
adds	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , adds :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:48	language:Haskell
advance1	./parser-typechecker/src/Unison/Parser.hs	/^  advance1 _ _ cp = setPos cp . L.end$/;"	fi	instance:P-Stream Input	line:156	language:Haskell
advanceN	./parser-typechecker/src/Unison/Parser.hs	/^  advanceN _ _ cp = setPos cp . L.end . last . inputStream$/;"	fi	instance:P-Stream Input	line:158	language:Haskell
advancePos	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^advancePos :: Int -> Layout -> TermRows -> TermPos -> TermPos$/;"	ft	signature:(Int -> Layout -> TermRows -> TermPos -> TermPos)	line:252	language:Haskell
afterChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^overChar, beforeChar, afterChar :: (Char -> Bool) -> InsertMode -> Bool$/;"	ft	signature:((Char -> Bool) -> InsertMode -> Bool)	line:415	language:Haskell
afterChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^afterChar f (IMode (x:_) _) = f (baseChar x)$/;"	fi	line:422	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^    afterCursor = afterCursor . foundHistory$/;"	fi	instance:LineState SearchMode	line:95	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    afterCursor :: s -> [Grapheme] -- ^ The text under and to the right of the cursor.$/;"	ft	signature:(s -> [Grapheme])	class:LineState	line:154	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    afterCursor (IMode _ ys) = ys$/;"	fi	instance:LineState InsertMode	line:193	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    afterCursor CEmpty = []$/;"	fi	instance:LineState CommandMode	line:271	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    afterCursor = afterCursor . argState$/;"	fi	instance:LineState s => LineState (ArgMode s)	line:349	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    afterCursor _ = []$/;"	fi	instance:LineState Message	line:382	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    afterCursor _ = []$/;"	fi	instance:LineState Password	line:395	language:Haskell
afterCursor	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^    afterCursor = afterCursor . entryState$/;"	fi	instance:LineState SearchEntry	line:411	language:Haskell
aliasMany	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^aliasMany :: InputPattern$/;"	ft	signature:(InputPattern)	line:461	language:Haskell
aliasTerm	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^aliasTerm :: InputPattern$/;"	ft	signature:(InputPattern)	line:435	language:Haskell
aliasType	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^aliasType :: InputPattern$/;"	ft	signature:(InputPattern)	line:448	language:Haskell
aliases	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^aliases :: SearchResult -> Set HashQualified$/;"	ft	signature:(SearchResult -> Set HashQualified)	line:55	language:Haskell
aliases	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  , aliases     :: [String]$/;"	c_a	cons:InputPattern.InputPattern	line:30	language:Haskell
aliasesToShow	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^aliasesToShow :: Int$/;"	ft	signature:(Int)	line:159	language:Haskell
align	./parser-typechecker/src/Unison/Util/Pretty.hs	/^align rows = (((uncurry (<>)) <$>) . align') (second Just <$> rows)$/;"	fi	line:535	language:Haskell
align'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^align' rows = alignedRows$/;"	fi	line:554	language:Haskell
alignment	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    alignment _ = (#alignment COORD)$/;"	fi	instance:Storable Coord	line:171	language:Haskell
allErrors	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^allErrors = asum$/;"	fi	line:106	language:Haskell
allInSubBlock	./parser-typechecker/src/Unison/TermPrinter.hs	/^allInSubBlock :: (Var v, Ord v) => Term3 v PrintAnnotation -> Prefix -> Suffix -> Int -> Bool$/;"	ft	signature:((Var v, Ord v) => Term3 v PrintAnnotation -> Prefix -> Suffix -> Int -> Bool)	line:953	language:Haskell
allReferenceTargets	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^allReferenceTargets :: Patch -> Set Reference$/;"	ft	signature:(Patch -> Set Reference)	line:74	language:Haskell
allReferences	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^allReferences :: Patch -> Set Reference$/;"	ft	signature:(Patch -> Set Reference)	line:64	language:Haskell
allReferences	./unison-core/src/Unison/Names2.hs	/^termReferences, typeReferences, allReferences :: Names' n -> Set Reference$/;"	ft	signature:(Names' n -> Set Reference)	line:91	language:Haskell
allReferences	./unison-core/src/Unison/Names2.hs	/^allReferences n = termReferences n <> typeReferences n$/;"	fi	line:94	language:Haskell
allTerms	./parser-typechecker/src/Unison/UnisonFile.hs	/^allTerms :: Ord v => TypecheckedUnisonFile v a -> Map v (Term v a)$/;"	ft	signature:(Ord v => TypecheckedUnisonFile v a -> Map v (Term v a))	line:115	language:Haskell
allVars	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^       , allVars :: Set v -- all variables seen so far$/;"	c_a	cons:Info.Info	line:333	language:Haskell
allVars	./parser-typechecker/src/Unison/UnisonFile.hs	/^allVars :: Ord v => UnisonFile v a -> Set v$/;"	ft	signature:(Ord v => UnisonFile v a -> Set v)	line:314	language:Haskell
allVars	./unison-core/src/Unison/ABT.hs	/^allVars :: Foldable f => Term f v a -> [v]$/;"	ft	signature:(Foldable f => Term f v a -> [v])	line:275	language:Haskell
allVars	./unison-core/src/Unison/DataDeclaration.hs	/^allVars :: Ord v => DataDeclaration' v a -> Set v$/;"	ft	signature:(Ord v => DataDeclaration' v a -> Set v)	line:189	language:Haskell
allVars	./unison-core/src/Unison/Term.hs	/^allVars :: Ord v => Term v a -> Set v$/;"	ft	signature:(Ord v => Term v a -> Set v)	line:286	language:Haskell
allVars'	./unison-core/src/Unison/DataDeclaration.hs	/^allVars' :: Ord v => Decl v a -> Set v$/;"	ft	signature:(Ord v => Decl v a -> Set v)	line:195	language:Haskell
allWatches	./parser-typechecker/src/Unison/UnisonFile.hs	/^allWatches :: UnisonFile v a -> [(v, Term v a)]$/;"	ft	signature:(UnisonFile v a -> [(v, Term v a)])	line:55	language:Haskell
allow	./parser-typechecker/src/Unison/CommandLine.hs	/^allow :: FilePath -> Bool$/;"	ft	signature:(FilePath -> Bool)	line:40	language:Haskell
allow	./yaks/easytest/src/EasyTest.hs	/^      , allow :: String }$/;"	c_a	cons:Env.Env	line:41	language:Haskell
alreadyExistsId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^alreadyExistsId = mkErrorType "io.ErrorType.AlreadyExists"$/;"	fi	line:111	language:Haskell
alternations	./parser-typechecker/src/Unison/Util/Pretty.hs	/^alternations :: (LL.ListLike s c) => (c -> Bool) -> s -> [s]$/;"	ft	signature:((LL.ListLike s c) => (c -> Bool) -> s -> [s])	line:216	language:Haskell
amap	./unison-core/src/Unison/ABT.hs	/^amap :: (Functor f, Foldable f, Ord v) => (a -> a2) -> Term f v a -> Term f v a2$/;"	ft	signature:((Functor f, Foldable f, Ord v) => (a -> a2) -> Term f v a -> Term f v a2)	line:145	language:Haskell
amap	./unison-core/src/Unison/Term.hs	/^amap :: Ord v => (a -> a2) -> Term v a -> Term v a2$/;"	ft	signature:(Ord v => (a -> a2) -> Term v a -> Term v a2)	line:185	language:Haskell
amap'	./unison-core/src/Unison/ABT.hs	/^amap' :: (Functor f, Foldable f, Ord v) => (Term f v a -> a -> a2) -> Term f v a -> Term f v a2$/;"	ft	signature:((Functor f, Foldable f, Ord v) => (Term f v a -> a -> a2) -> Term f v a -> Term f v a2)	line:148	language:Haskell
ambient	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | AbilityCheckFailure { ambient                 :: [C.Type v loc]$/;"	c_a	cons:TypeError.AbilityCheckFailure	line:59	language:Haskell
and	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^and = booleanMismatch0 AndMismatch (Ex.inSynthesizeApp >> Ex.inAndApp)$/;"	fi	line:180	language:Haskell
and	./unison-core/src/Unison/Term.hs	/^and :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:536	language:Haskell
andor	./unison-core/src/Unison/Type.hs	/^andor :: Ord v => Type v ()$/;"	ft	signature:(Ord v => Type v ())	line:302	language:Haskell
andor'	./unison-core/src/Unison/Type.hs	/^andor' :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:306	language:Haskell
ann	./parser-typechecker/src/Unison/Parser.hs	/^  ann :: a -> Ann$/;"	ft	signature:(a -> Ann)	class:Annotated	line:177	language:Haskell
ann	./parser-typechecker/src/Unison/Parser.hs	/^  ann = id$/;"	fi	instance:Annotated Ann	line:180	language:Haskell
ann	./parser-typechecker/src/Unison/Parser.hs	/^  ann (L.Token _ s e) = Ann s e$/;"	fi	instance:Annotated (L-Token a)	line:183	language:Haskell
ann	./parser-typechecker/src/Unison/Parser.hs	/^  ann = ann . ABT.annotation$/;"	fi	instance:Annotated a => Annotated (ABT-Term f v a)	line:186	language:Haskell
ann	./parser-typechecker/src/Unison/Parser.hs	/^  ann = ann . Pattern.loc$/;"	fi	instance:Annotated a => Annotated (PatternP a)	line:189	language:Haskell
ann	./parser-typechecker/src/Unison/Parser.hs	/^  ann (MatchCase p _ b) = ann p <> ann b$/;"	fi	instance:(Annotated a, Annotated b) => Annotated (MatchCase a b)	line:192	language:Haskell
ann	./unison-core/src/Unison/Term.hs	/^ann :: Ord v$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a -> Type vt at -> Term2 vt at ap v a)	line:568	language:Haskell
ann	./unison-core/src/Unison/Type.hs	/^ann :: Ord v => a -> Type v a -> K.Kind -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a -> K.Kind -> Type v a)	line:275	language:Haskell
ann_	./unison-core/src/Unison/Term.hs	/^ann_ :: Ord v => Term0' vt v -> Type vt () -> Term0' vt v$/;"	ft	signature:(Ord v => Term0' vt v -> Type vt () -> Term0' vt v)	line:565	language:Haskell
annotate	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^annotate :: a -> AnnotatedText a -> AnnotatedText a$/;"	ft	signature:(a -> AnnotatedText a -> AnnotatedText a)	line:91	language:Haskell
annotate	./unison-core/src/Unison/ABT.hs	/^annotate :: a -> Term f v a -> Term f v a$/;"	ft	signature:(a -> Term f v a -> Term f v a)	line:135	language:Haskell
annotate'	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^annotate' :: Maybe b -> AnnotatedText a -> AnnotatedText b$/;"	ft	signature:(Maybe b -> AnnotatedText a -> AnnotatedText b)	line:84	language:Haskell
annotateBound	./unison-core/src/Unison/ABT.hs	/^annotateBound :: (Ord v, Foldable f, Functor f) => Term f v a -> Term f v (a, Set v)$/;"	ft	signature:((Ord v, Foldable f, Functor f) => Term f v a -> Term f v (a, Set v))	line:106	language:Haskell
annotateBound'	./unison-core/src/Unison/ABT.hs	/^annotateBound' :: (Ord v, Functor f, Foldable f) => Term f v a0 -> Term f v [v]$/;"	ft	signature:((Ord v, Functor f, Foldable f) => Term f v a0 -> Term f v [v])	line:102	language:Haskell
annotateBound''	./unison-core/src/Unison/ABT.hs	/^annotateBound'' :: (Ord v, Functor f, Foldable f) => Term f v a -> Term f v (a, [v])$/;"	ft	signature:((Ord v, Functor f, Foldable f) => Term f v a -> Term f v (a, [v]))	line:114	language:Haskell
annotateDepth	./parser-typechecker/src/Unison/Runtime/IR.hs	/^annotateDepth :: IR' a z -> IR' a (z, Int)$/;"	ft	signature:(IR' a z -> IR' a (z, Int))	line:395	language:Haskell
annotateLetRecBindings	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^annotateLetRecBindings isTop letrec =$/;"	fi	line:1165	language:Haskell
annotateMaybe	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^annotateMaybe :: AnnotatedText (Maybe a) -> AnnotatedText a$/;"	ft	signature:(AnnotatedText (Maybe a) -> AnnotatedText a)	line:95	language:Haskell
annotateRefs	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^annotateRefs :: (Applicative f, Var v)$/;"	ft	signature:((Applicative f, Var v) => (Reference -> f (Type.Type v loc)) -> Term v loc -> f (Term v loc))	line:1680	language:Haskell
annotatedAsErrorSite	./parser-typechecker/src/Unison/PrintError.hs	/^annotatedAsErrorSite = annotatedAsStyle ErrorSite$/;"	fi	line:1124	language:Haskell
annotatedAsStyle	./parser-typechecker/src/Unison/PrintError.hs	/^annotatedAsStyle style s ann =$/;"	fi	line:1132	language:Haskell
annotatedToEnglish	./parser-typechecker/src/Unison/PrintError.hs	/^annotatedToEnglish :: (Annotated a, IsString s) => a -> s$/;"	ft	signature:((Annotated a, IsString s) => a -> s)	line:831	language:Haskell
annotatedVar	./unison-core/src/Unison/ABT.hs	/^annotatedVar :: a -> v -> Term f v a$/;"	ft	signature:(a -> v -> Term f v a)	line:191	language:Haskell
annotatedsAsErrorSite	./parser-typechecker/src/Unison/PrintError.hs	/^annotatedsAsErrorSite :: (Annotated a) => String -> [a] -> Pretty ColorText$/;"	ft	signature:((Annotated a) => String -> [a] -> Pretty ColorText)	line:1135	language:Haskell
annotatedsAsStyle	./parser-typechecker/src/Unison/PrintError.hs	/^annotatedsAsStyle :: (Annotated a) => Color -> String -> [a] -> Pretty ColorText$/;"	ft	signature:((Annotated a) => Color -> String -> [a] -> Pretty ColorText)	line:1138	language:Haskell
annotatedsStartingLineAsStyle	./parser-typechecker/src/Unison/PrintError.hs	/^annotatedsStartingLineAsStyle style src as = showSourceMaybes$/;"	fi	line:1144	language:Haskell
annotation	./unison-core/src/Unison/ABT.hs	/^data Term f v a = Term { freeVars :: Set v, annotation :: a, out :: ABT f v (Term f v a) }$/;"	c_a	cons:Term.Term	line:38	language:Haskell
annotation	./unison-core/src/Unison/DataDeclaration.hs	/^  annotation :: a,$/;"	c_a	cons:DataDeclaration'.DataDeclaration	line:76	language:Haskell
annotations	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  , annotations :: Map Range a$/;"	c_a	cons:AnnotatedExcerpt.AnnotatedExcerpt	line:81	language:Haskell
ansiKeys	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^ansiKeys :: [(String, Key)]$/;"	ft	signature:([(String, Key)])	line:123	language:Haskell
anyToken	./parser-typechecker/src/Unison/Parser.hs	/^anyToken :: Ord v => P v (L.Token L.Lexeme)$/;"	ft	signature:(Ord v => P v (L.Token L.Lexeme))	line:218	language:Haskell
app	./unison-core/src/Unison/Term.hs	/^app :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:527	language:Haskell
app	./unison-core/src/Unison/Type.hs	/^app :: Ord v => a -> Type v a -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a -> Type v a -> Type v a)	line:255	language:Haskell
app'	./unison-core/src/Unison/Type.hs	/^app' :: (Ord v, Semigroup a) => Type v a -> Type v a -> Type v a$/;"	ft	signature:((Ord v, Semigroup a) => Type v a -> Type v a -> Type v a)	line:263	language:Haskell
app_	./unison-core/src/Unison/Term.hs	/^app_ :: Ord v => Term0' vt v -> Term0' vt v -> Term0' vt v$/;"	ft	signature:(Ord v => Term0' vt v -> Term0' vt v -> Term0' vt v)	line:524	language:Haskell
append	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^append :: Metadata -> Metadata -> Metadata$/;"	ft	signature:(Metadata -> Metadata -> Metadata)	line:53	language:Haskell
appendCont	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^appendCont :: Symbol -> Req -> Continuation -> Req$/;"	ft	signature:(Symbol -> Req -> Continuation -> Req)	line:95	language:Haskell
appendContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^appendContext :: (Var v, Ord loc) => [Element v loc] -> M v loc ()$/;"	ft	signature:((Var v, Ord loc) => [Element v loc] -> M v loc ())	line:461	language:Haskell
appendFromCommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^insertFromCommandMode, appendFromCommandMode :: CommandMode -> InsertMode$/;"	ft	signature:(CommandMode -> InsertMode)	line:326	language:Haskell
appendFromCommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^appendFromCommandMode CEmpty = emptyIM$/;"	fi	line:331	language:Haskell
appendReflog	./parser-typechecker/src/Unison/Codebase.hs	/^           , appendReflog       :: Text -> Branch m -> Branch m -> m ()$/;"	c_a	cons:Codebase.Codebase	line:77	language:Haskell
application	./unison-core/src/Unison/Pattern.hs	/^application :: PatternP loc -> Bool$/;"	ft	signature:(PatternP loc -> Bool)	line:81	language:Haskell
apply	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^apply :: (Var v, Ord loc) => Context v loc -> Type v loc -> Type v loc$/;"	ft	signature:((Var v, Ord loc) => Context v loc -> Type v loc -> Type v loc)	line:700	language:Haskell
apply'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^apply' :: (Var v, Ord loc) => Map v (Monotype v loc) -> Type v loc -> Type v loc$/;"	ft	signature:((Var v, Ord loc) => Map v (Monotype v loc) -> Type v loc -> Type v loc)	line:707	language:Haskell
applyArg	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^applyArg :: (s -> s) -> ArgMode s -> s$/;"	ft	signature:((s -> s) -> ArgMode s -> s)	line:367	language:Haskell
applyArgHelper	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^applyArgHelper :: KillHelper -> ArgMode InsertMode -> ([Grapheme],InsertMode)$/;"	ft	signature:(KillHelper -> ArgMode InsertMode -> ([Grapheme], InsertMode))	line:90	language:Haskell
applyCmdArg	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^applyCmdArg :: (InsertMode -> InsertMode) -> ArgMode CommandMode -> CommandMode$/;"	ft	signature:((InsertMode -> InsertMode) -> ArgMode CommandMode -> CommandMode)	line:374	language:Haskell
applyCtx	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^applyCtx :: (Var v, Ord loc) => [Element v loc] -> Type v loc -> Type v loc$/;"	ft	signature:((Var v, Ord loc) => [Element v loc] -> Type v loc -> Type v loc)	line:704	language:Haskell
applyDeprecations	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^applyDeprecations :: Applicative m => Patch -> Branch0 m -> Branch0 m$/;"	ft	signature:(Applicative m => Patch -> Branch0 m -> Branch0 m)	line:418	language:Haskell
applyHelper	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^applyHelper :: KillHelper -> InsertMode -> ([Grapheme],InsertMode)$/;"	ft	signature:(KillHelper -> InsertMode -> ([Grapheme], InsertMode))	line:86	language:Haskell
applyKeysToCmd	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^applyKeysToCmd :: Monad m => [Key] -> CmdM m (a,[Key])$/;"	ft	signature:(Monad m => [Key] -> CmdM m (a, [Key]) -> CmdM m (a, [Key]))	line:115	language:Haskell
applyKeysToMap	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^applyKeysToMap :: Monad m => [Key] -> KeyMap (CmdM m (a,[Key]))$/;"	ft	signature:(Monad m => [Key] -> KeyMap (CmdM m (a, [Key])) -> CmdM m (a, [Key]))	line:107	language:Haskell
applyM	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^applyM :: (Var v, Ord loc) => Type v loc -> M v loc (Type v loc)$/;"	ft	signature:((Var v, Ord loc) => Type v loc -> M v loc (Type v loc))	line:1140	language:Haskell
applyPropagate	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^applyPropagate patch Edits {..} = do$/;"	fi	line:438	language:Haskell
applySelection	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^applySelection :: forall v a. Var v =>$/;"	ft	signature:(forall v a. Var v => [HQ'.HashQualified] -> UF.TypecheckedUnisonFile v a -> SlurpResult v -> SlurpResult v)	line:2064	language:Haskell
applyingFunction	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^applyingFunction :: forall v loc. (Var v) => Ex.ErrorExtractor v loc (TypeError v loc)$/;"	ft	signature:(forall v loc. (Var v) => Ex.ErrorExtractor v loc (TypeError v loc))	line:263	language:Haskell
applyingNonFunction	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^applyingNonFunction :: Var v => Ex.ErrorExtractor v loc (TypeError v loc)$/;"	ft	signature:(Var v => Ex.ErrorExtractor v loc (TypeError v loc))	line:238	language:Haskell
apps	./unison-core/src/Unison/Term.hs	/^apps = foldl' (\\f (a, t) -> app a f t)$/;"	fi	line:553	language:Haskell
apps	./unison-core/src/Unison/Type.hs	/^apps :: Ord v => Type v a -> [(a, Type v a)] -> Type v a$/;"	ft	signature:(Ord v => Type v a -> [(a, Type v a)] -> Type v a)	line:260	language:Haskell
apps'	./unison-core/src/Unison/Term.hs	/^apps' = foldl' (\\f t -> app (ABT.annotation f <> ABT.annotation t) f t)$/;"	fi	line:560	language:Haskell
apps'	./unison-core/src/Unison/Type.hs	/^apps' :: (Semigroup a, Ord v) => Type v a -> [Type v a] -> Type v a$/;"	ft	signature:((Semigroup a, Ord v) => Type v a -> [Type v a] -> Type v a)	line:266	language:Haskell
arg	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , arg          :: C.Term v loc$/;"	c_a	cons:TypeError.FunctionApplication	line:47	language:Haskell
arg	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data ArgMode s = ArgMode {arg :: Int, argState :: s}$/;"	c_a	cons:ArgMode.ArgMode	line:341	language:Haskell
argNum	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , argNum       :: Int$/;"	c_a	cons:TypeError.FunctionApplication	line:48	language:Haskell
argState	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data ArgMode s = ArgMode {arg :: Int, argState :: s}$/;"	c_a	cons:ArgMode.ArgMode	line:341	language:Haskell
argType	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^argType :: InputPattern -> Int -> Maybe ArgumentType$/;"	ft	signature:(InputPattern -> Int -> Maybe ArgumentType)	line:51	language:Haskell
args	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  , args        :: [(IsOptional, ArgumentType)]$/;"	c_a	cons:InputPattern.InputPattern	line:31	language:Haskell
arity	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^arity :: Value -> Int$/;"	ft	signature:(Value -> Int)	line:219	language:Haskell
arity	./unison-core/src/Unison/Term.hs	/^arity :: Term2 vt at ap v a -> Int$/;"	ft	signature:(Term2 vt at ap v a -> Int)	line:588	language:Haskell
arity	./unison-core/src/Unison/Type.hs	/^arity :: Type v a -> Int$/;"	ft	signature:(Type v a -> Int)	line:95	language:Haskell
arrow	./parser-typechecker/src/Unison/TypeParser.hs	/^arrow :: Var v => TypeP v -> TypeP v$/;"	ft	signature:(Var v => TypeP v -> TypeP v)	line:100	language:Haskell
arrow	./unison-core/src/Unison/Type.hs	/^arrow :: Ord v => a -> Type v a -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a -> Type v a -> Type v a)	line:269	language:Haskell
arrow'	./unison-core/src/Unison/Type.hs	/^arrow' :: (Semigroup a, Ord v) => Type v a -> Type v a -> Type v a$/;"	ft	signature:((Semigroup a, Ord v) => Type v a -> Type v a -> Type v a)	line:272	language:Haskell
arrows	./parser-typechecker/src/Unison/PrintError.hs	/^arrows :: (IsString a, Monoid a) => (b -> a) -> [b] -> a$/;"	ft	signature:((IsString a, Monoid a) => (b -> a) -> [b] -> a)	line:757	language:Haskell
arrows	./unison-core/src/Unison/Type.hs	/^arrows :: Ord v => [(a, Type v a)] -> Type v a -> Type v a$/;"	ft	signature:(Ord v => [(a, Type v a)] -> Type v a -> Type v a)	line:329	language:Haskell
as	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  as <> AnnotatedText (("", _) :<| bs) = as <> AnnotatedText bs$/;"	fi	instance:Semigroup (AnnotatedText a)	line:31	language:Haskell
asDataDecl	./unison-core/src/Unison/DataDeclaration.hs	/^asDataDecl :: Decl v a -> DataDeclaration' v a$/;"	ft	signature:(Decl v a -> DataDeclaration' v a)	line:60	language:Haskell
asDeclaration	./unison-core/src/Unison/Paths.hs	/^asDeclaration :: Target v -> Maybe (v, Term v)$/;"	ft	signature:(Target v -> Maybe (v, Term v))	line:203	language:Haskell
asPathExtractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^asPathExtractor :: (C.PathElement v loc -> Maybe a) -> SubseqExtractor v loc a$/;"	ft	signature:((C.PathElement v loc -> Maybe a) -> SubseqExtractor v loc a)	line:152	language:Haskell
asTerm	./unison-core/src/Unison/Paths.hs	/^asTerm :: Target v -> Maybe (Term v)$/;"	ft	signature:(Target v -> Maybe (Term v))	line:191	language:Haskell
asType	./unison-core/src/Unison/Paths.hs	/^asType :: Target v -> Maybe (Type v)$/;"	ft	signature:(Target v -> Maybe (Type v))	line:195	language:Haskell
asVar	./unison-core/src/Unison/Paths.hs	/^asVar :: Target v -> Maybe v$/;"	ft	signature:(Target v -> Maybe v)	line:199	language:Haskell
asciiartUnison	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^asciiartUnison :: P.Pretty P.ColorText$/;"	ft	signature:(P.Pretty P.ColorText)	line:108	language:Haskell
aside	./parser-typechecker/src/Unison/CommandLine.hs	/^aside :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s -> P.Pretty s)	line:88	language:Haskell
ask	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  ask = MT (\\e -> pure (e, env e))$/;"	fi	instance:Monad f => MonadReader (MEnv v loc) (MT v loc f)	line:1812	language:Haskell
ask	./yaks/easytest/src/EasyTest.hs	/^  ask = Test $ do$/;"	fi	instance:MonadReader Env Test	line:368	language:Haskell
ask	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    ask :: m r$/;"	ft	signature:(m r)	class:MonadReader	line:36	language:Haskell
ask	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    ask = Reader.ask$/;"	fi	instance:Monad m => MonadReader r (ReaderT r m)	line:39	language:Haskell
ask	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    ask = get$/;"	fi	instance:Monad m => MonadReader s (StateT s m)	line:42	language:Haskell
ask	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    ask = lift ask$/;"	fi	instance:(MonadReader r m, MonadTrans t, Monad (t m)) => MonadReader r (t m)	line:46	language:Haskell
askFirst	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^askFirst :: Monad m => Prefs -> Int -> CmdM m ()$/;"	ft	signature:(Monad m => Prefs -> Int -> CmdM m () -> CmdM m ())	line:84	language:Haskell
askIMCompletions	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^askIMCompletions :: CommandMonad m =>$/;"	ft	signature:(CommandMonad m => Command m InsertMode (InsertMode, [Completion]))	line:24	language:Haskell
asks	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^asks :: MonadReader r m => (r -> a) -> m a$/;"	ft	signature:(MonadReader r m => (r -> a) -> m a)	line:48	language:Haskell
assertInvocation	./yaks/haskeline/tests/RunTTY.hs	/^assertInvocation :: Invocation -> [B.ByteString] -> [B.ByteString]$/;"	ft	signature:(Invocation -> [B.ByteString] -> [B.ByteString] -> Assertion)	line:84	language:Haskell
assertSame	./yaks/haskeline/tests/RunTTY.hs	/^assertSame :: B.ByteString -> B.ByteString -> Assertion$/;"	ft	signature:(B.ByteString -> B.ByteString -> Assertion)	line:105	language:Haskell
assertSameList	./yaks/haskeline/tests/RunTTY.hs	/^assertSameList :: (Show a, Eq a) => [a] -> [a] -> Assertion$/;"	ft	signature:((Show a, Eq a) => [a] -> [a] -> Assertion)	line:99	language:Haskell
assignTermName	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^assignTermName :: Referent -> HashQualified -> PrettyPrintEnv -> PrettyPrintEnv$/;"	ft	signature:(Referent -> HashQualified -> PrettyPrintEnv -> PrettyPrintEnv)	line:85	language:Haskell
at	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^at :: Size -> Z -> Stack -> IO Value$/;"	ft	signature:(Size -> Z -> Stack -> IO Value)	line:107	language:Haskell
at	./parser-typechecker/src/Unison/Util/Bytes.hs	/^at :: Int -> Bytes -> Maybe Word8$/;"	ft	signature:(Int -> Bytes -> Maybe Word8)	line:66	language:Haskell
at	./parser-typechecker/src/Unison/Util/Logger.hs	/^at :: Level -> Logger -> Logger$/;"	ft	signature:(Level -> Logger -> Logger)	line:98	language:Haskell
at	./unison-core/src/Unison/ABT.hs	/^at :: Path s t a b m -> s -> Maybe a$/;"	ft	signature:(Path s t a b m -> s -> Maybe a)	line:78	language:Haskell
at	./unison-core/src/Unison/Paths.hs	/^at :: Var v => Path -> Target v -> Maybe (Target v)$/;"	ft	signature:(Var v => Path -> Target v -> Maybe (Target v))	line:126	language:Haskell
atDebug	./parser-typechecker/src/Unison/Util/Logger.hs	/^atError, atWarn, atInfo, atDebug, atTrace :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:101	language:Haskell
atEnd	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^atStart, atEnd :: (Char -> Bool) -> InsertMode -> Bool$/;"	ft	signature:((Char -> Bool) -> InsertMode -> Bool)	line:408	language:Haskell
atEnd	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^atEnd f (IMode _ (y1:y2:_)) = f (baseChar y1) && not (f (baseChar y2))$/;"	fi	line:412	language:Haskell
atError	./parser-typechecker/src/Unison/Util/Logger.hs	/^atError, atWarn, atInfo, atDebug, atTrace :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:101	language:Haskell
atInfo	./parser-typechecker/src/Unison/Util/Logger.hs	/^atError, atWarn, atInfo, atDebug, atTrace :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:101	language:Haskell
atStart	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^atStart, atEnd :: (Char -> Bool) -> InsertMode -> Bool$/;"	ft	signature:((Char -> Bool) -> InsertMode -> Bool)	line:408	language:Haskell
atTerm	./unison-core/src/Unison/Paths.hs	/^atTerm :: Var v => Path -> Term v -> Maybe (Term v)$/;"	ft	signature:(Var v => Path -> Term v -> Maybe (Term v))	line:129	language:Haskell
atTrace	./parser-typechecker/src/Unison/Util/Logger.hs	/^atError, atWarn, atInfo, atDebug, atTrace :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:101	language:Haskell
atType	./unison-core/src/Unison/Paths.hs	/^atType :: Var v => Path -> Type v -> Maybe (Type v)$/;"	ft	signature:(Var v => Path -> Type v -> Maybe (Type v))	line:132	language:Haskell
atWarn	./parser-typechecker/src/Unison/Util/Logger.hs	/^atError, atWarn, atInfo, atDebug, atTrace :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:101	language:Haskell
atb	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^atb :: Size -> Z -> Stack -> IO Bool$/;"	ft	signature:(Size -> Z -> Stack -> IO Bool)	line:137	language:Haskell
atbs	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^atbs :: Size -> Z -> Stack -> IO Bytes.Bytes$/;"	ft	signature:(Size -> Z -> Stack -> IO Bytes.Bytes)	line:150	language:Haskell
atc	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^atc :: Size -> Z -> Stack -> IO Char$/;"	ft	signature:(Size -> Z -> Stack -> IO Char)	line:117	language:Haskell
atd	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^atd :: Size -> Z -> Stack -> IO (R.Reference, ConstructorId, [Value])$/;"	ft	signature:(Size -> Z -> Stack -> IO (R.Reference, ConstructorId, [Value]))	line:160	language:Haskell
atf	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^atf :: Size -> Z -> Stack -> IO Double$/;"	ft	signature:(Size -> Z -> Stack -> IO Double)	line:132	language:Haskell
ati	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^ati :: Size -> Z -> Stack -> IO Int64$/;"	ft	signature:(Size -> Z -> Stack -> IO Int64)	line:122	language:Haskell
atn	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^atn :: Size -> Z -> Stack -> IO Word64$/;"	ft	signature:(Size -> Z -> Stack -> IO Word64)	line:127	language:Haskell
atomic	./parser-typechecker/src/Unison/Util/Logger.hs	/^atomic :: Logger -> IO Logger$/;"	ft	signature:(Logger -> IO Logger)	line:34	language:Haskell
atomicLogger	./yaks/easytest/src/EasyTest.hs	/^atomicLogger :: IO (String -> IO ())$/;"	ft	signature:(IO (String -> IO ()))	line:48	language:Haskell
ats	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^ats :: Size -> Z -> Stack -> IO (Seq Value)$/;"	ft	signature:(Size -> Z -> Stack -> IO (Seq Value))	line:155	language:Haskell
att	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^att :: Size -> Z -> Stack -> IO Text$/;"	ft	signature:(Size -> Z -> Stack -> IO Text)	line:142	language:Haskell
autoAddHistory	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^                            autoAddHistory :: Bool -- ^ If 'True', each nonblank line returned by$/;"	c_a	cons:Settings.Settings	line:25	language:Haskell
av'	./unison-core/src/Unison/Type.hs	/^av' :: Var v => a -> Text -> Type v a$/;"	ft	signature:(Var v => a -> Text -> Type v a)	line:317	language:Haskell
awaitSize	./parser-typechecker/src/Unison/Util/TQueue.hs	/^awaitSize :: Int -> TQueue a -> STM ()$/;"	ft	signature:(Int -> TQueue a -> STM ())	line:23	language:Haskell
b	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^pattern Existential b v = Var (TypeVar.Existential b v)$/;"	fi	line:95	language:Haskell
b	./unison-core/src/Unison/Pattern.hs	/^pattern Boolean b = BooleanP () b$/;"	fi	line:100	language:Haskell
b1	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  b1 == b2 | size b1 == size b2 = go b1 b2$/;"	fi	instance:Eq Bytes	line:90	language:Haskell
back	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^back :: InputPattern$/;"	ft	signature:(InputPattern)	line:493	language:Haskell
backs	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^backs,spaces :: Int -> String$/;"	ft	signature:(Int -> String)	line:59	language:Haskell
backtick	./parser-typechecker/src/Unison/CommandLine.hs	/^backtick :: IsString s => P.Pretty s -> P.Pretty s$/;"	ft	signature:(IsString s => P.Pretty s -> P.Pretty s)	line:76	language:Haskell
backtickEOS	./parser-typechecker/src/Unison/CommandLine.hs	/^backtickEOS :: IsString s => P.Pretty s -> P.Pretty s$/;"	ft	signature:(IsString s => P.Pretty s -> P.Pretty s)	line:79	language:Haskell
backticked	./parser-typechecker/src/Unison/Util/Pretty.hs	/^backticked :: IsString s => Pretty s -> Pretty s$/;"	ft	signature:(IsString s => Pretty s -> Pretty s)	line:776	language:Haskell
bad	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^bad :: EitherResult -> Test TFile$/;"	ft	signature:(EitherResult -> Test TFile)	line:68	language:Haskell
bang	./parser-typechecker/src/Unison/TermParser.hs	/^bang :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:615	language:Haskell
base32Hex	./unison-core/src/Unison/Hash.hs	/^base32Hex :: Hash -> Text$/;"	ft	signature:(Hash -> Text)	line:56	language:Haskell
base32Hexs	./unison-core/src/Unison/Hash.hs	/^base32Hexs :: Hash -> String$/;"	ft	signature:(Hash -> String)	line:98	language:Haskell
baseChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^baseChar :: Grapheme -> Char$/;"	ft	signature:(Grapheme -> Char)	line:83	language:Haskell
baseGrapheme	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^baseGrapheme :: Char -> Grapheme$/;"	ft	signature:(Char -> Grapheme)	line:96	language:Haskell
basicNames0'	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^basicNames0' :: Functor m => Action' m v (Names0, Names0)$/;"	ft	signature:(Functor m => Action' m v (Names0, Names0))	line:2502	language:Haskell
basicParseNames0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^basicParseNames0, basicPrettyPrintNames0, slurpResultNames0 :: Functor m => Action' m v Names0$/;"	ft	signature:(Functor m => Action' m v Names0)	line:2489	language:Haskell
basicPrettyPrintNames0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^basicParseNames0, basicPrettyPrintNames0, slurpResultNames0 :: Functor m => Action' m v Names0$/;"	ft	signature:(Functor m => Action' m v Names0)	line:2489	language:Haskell
basicPrettyPrintNames0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^basicPrettyPrintNames0 = snd <$> basicNames0'$/;"	fi	line:2491	language:Haskell
before	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^before :: Monad m => Branch m -> Branch m -> m Bool$/;"	ft	signature:(Monad m => Branch m -> Branch m -> m Bool)	line:394	language:Haskell
before	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^before :: Monad m => Causal m h e -> Causal m h e -> m Bool$/;"	ft	signature:(Monad m => Causal m h e -> Causal m h e -> m Bool)	line:267	language:Haskell
beforeChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^overChar, beforeChar, afterChar :: (Char -> Bool) -> InsertMode -> Bool$/;"	ft	signature:((Char -> Bool) -> InsertMode -> Bool)	line:415	language:Haskell
beforeChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^beforeChar f (IMode _ (_:y:_)) = f (baseChar y)$/;"	fi	line:419	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^    beforeCursor _ sm = beforeCursor prefix (foundHistory sm)$/;"	fi	instance:LineState SearchMode	line:91	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    beforeCursor :: Prefix -- ^ The input prefix.$/;"	ft	signature:(Prefix -> s -> [Grapheme])	class:LineState	line:150	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    beforeCursor prefix (IMode xs _) = prefix ++ reverse xs$/;"	fi	instance:LineState InsertMode	line:192	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    beforeCursor prefix CEmpty = prefix$/;"	fi	instance:LineState CommandMode	line:269	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    beforeCursor _ am = let pre = map baseGrapheme $ "(arg: " ++ show (arg am) ++ ") "$/;"	fi	instance:LineState s => LineState (ArgMode s)	line:347	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    beforeCursor _ = stringToGraphemes . messageText$/;"	fi	instance:LineState Message	line:381	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    beforeCursor prefix p$/;"	fi	instance:LineState Password	line:390	language:Haskell
beforeCursor	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^    beforeCursor prefix se = beforeCursor (prefix ++ stringToGraphemes [searchChar se])$/;"	fi	instance:LineState SearchEntry	line:409	language:Haskell
bellStyle	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^data Prefs = Prefs { bellStyle :: !BellStyle,$/;"	c_a	cons:Prefs.Prefs	line:32	language:Haskell
bellVisual	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                        bellAudible,bellVisual :: TermOutput,$/;"	c_a	cons:Actions.Actions	line:38	language:Haskell
betaNormalForm	./unison-core/src/Unison/Term.hs	/^betaNormalForm :: Var v => Term0 v -> Term0 v$/;"	ft	signature:(Var v => Term0 v -> Term0 v)	line:902	language:Haskell
betaReduce	./unison-core/src/Unison/Term.hs	/^betaReduce :: Var v => Term0 v -> Term0 v$/;"	ft	signature:(Var v => Term0 v -> Term0 v)	line:898	language:Haskell
bigWordLeft	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^wordRight, wordLeft, bigWordLeft :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:89	language:Haskell
bigWordLeft	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^bigWordLeft = goLeftUntil (atStart (not . isSpace))$/;"	fi	line:92	language:Haskell
bigproblem	./parser-typechecker/src/Unison/CommandLine.hs	/^bigproblem :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s)	line:97	language:Haskell
bimap	./unison-core/src/Unison/Util/Relation.hs	/^bimap :: (Ord a, Ord b, Ord c, Ord d)$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => (a -> c) -> (b -> d) -> Relation a b -> Relation c d)	line:468	language:Haskell
bind	./unison-core/src/Unison/ABT.hs	/^        , bind :: Term f v a -> Term f v a$/;"	c_a	cons:Subst.Subst	line:458	language:Haskell
bindExternal	./unison-core/src/Unison/Type.hs	/^bindExternal bs = ABT.substsInheritAnnotation [ (v, ref () r) | (v, r) <- bs ]$/;"	fi	line:69	language:Haskell
bindInheritAnnotation	./unison-core/src/Unison/ABT.hs	/^        , bindInheritAnnotation :: forall b . Term f v b -> Term f v a$/;"	c_a	cons:Subst.Subst	line:459	language:Haskell
bindNames	./parser-typechecker/src/Unison/UnisonFile.hs	/^bindNames :: Var v$/;"	ft	signature:(Var v => Names0 -> UnisonFile v a -> Names.ResolutionResult v a (UnisonFile v a))	line:234	language:Haskell
bindNames	./unison-core/src/Unison/DataDeclaration.hs	/^bindNames :: Var v$/;"	ft	signature:(Var v => Set v -> Names0 -> DataDeclaration' v a -> Names.ResolutionResult v a (DataDeclaration' v a))	line:198	language:Haskell
bindNames	./unison-core/src/Unison/Term.hs	/^bindNames keepFreeTerms ns e = do$/;"	fi	line:141	language:Haskell
bindNames	./unison-core/src/Unison/Type.hs	/^bindNames keepFree ns t = let$/;"	fi	line:77	language:Haskell
bindSomeNames	./unison-core/src/Unison/Term.hs	/^bindSomeNames ns e = bindNames keepFree ns e where$/;"	fi	line:173	language:Haskell
binding	./parser-typechecker/src/Unison/TermParser.hs	/^binding :: forall v. Var v => P v ((Ann, v), Term v Ann)$/;"	ft	signature:(forall v. Var v => P v ((Ann, v), Term v Ann))	line:671	language:Haskell
black	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
black	./parser-typechecker/src/Unison/Util/Pretty.hs	/^black = map CT.black$/;"	fi	line:668	language:Haskell
blank	./parser-typechecker/src/Unison/Parser.hs	/^blank :: Ord v => P v (L.Token String)$/;"	ft	signature:(Ord v => P v (L.Token String))	line:374	language:Haskell
blank	./unison-core/src/Unison/Term.hs	/^blank :: Ord v => a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a)	line:508	language:Haskell
blank	./unison-core/src/Unison/Var.hs	/^blank = typed Blank$/;"	fi	line:70	language:Haskell
block	./parser-typechecker/src/Unison/TermParser.hs	/^block :: forall v. Var v => String -> TermP v$/;"	ft	signature:(forall v. Var v => String -> TermP v)	line:712	language:Haskell
block'	./parser-typechecker/src/Unison/TermParser.hs	/^block' isTop s openBlock closeBlock = do$/;"	fi	line:818	language:Haskell
blockContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^  , blockContext :: BlockContext$/;"	c_a	cons:AmbientContext.AmbientContext	line:65	language:Haskell
blockTerm	./parser-typechecker/src/Unison/TermParser.hs	/^blockTerm :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:121	language:Haskell
blockedCallout	./parser-typechecker/src/Unison/Util/Pretty.hs	/^blockedCallout = callout "ð«"$/;"	fi	line:774	language:Haskell
blue	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
blue	./parser-typechecker/src/Unison/Util/ColorText.hs	/^blue = style Blue$/;"	fi	line:29	language:Haskell
blue	./parser-typechecker/src/Unison/Util/Pretty.hs	/^blue = map CT.blue$/;"	fi	line:672	language:Haskell
bold	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
bold	./parser-typechecker/src/Unison/Util/ColorText.hs	/^bold = style Bold$/;"	fi	line:41	language:Haskell
bold	./parser-typechecker/src/Unison/Util/Pretty.hs	/^bold = map CT.bold$/;"	fi	line:684	language:Haskell
bool	./yaks/easytest/src/EasyTest.hs	/^bool :: Test Bool$/;"	ft	signature:(Test Bool)	line:214	language:Haskell
boolean	./parser-typechecker/src/Unison/TermParser.hs	/^boolean :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:276	language:Haskell
boolean	./unison-core/src/Unison/Term.hs	/^boolean :: Ord v => a -> Bool -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Bool -> Term2 vt at ap v a)	line:485	language:Haskell
boolean	./unison-core/src/Unison/Type.hs	/^boolean :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:237	language:Haskell
booleanMismatch0	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^booleanMismatch0 :: (Var v, Ord loc)$/;"	ft	signature:((Var v, Ord loc) => BooleanMismatch -> Ex.SubseqExtractor v loc () -> Ex.ErrorExtractor v loc (TypeError v loc))	line:193	language:Haskell
booleanRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
booleanRef	./unison-core/src/Unison/Type.hs	/^booleanRef = Reference.Builtin "Boolean"$/;"	fi	line:216	language:Haskell
bootstrapNames	./parser-typechecker/src/Unison/Codebase.hs	/^bootstrapNames :: Names.Names0$/;"	ft	signature:(Names.Names0)	line:93	language:Haskell
border	./parser-typechecker/src/Unison/Util/Pretty.hs	/^border :: (LL.ListLike s Char, IsString s) => Int -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Int -> Pretty s -> Pretty s)	line:697	language:Haskell
bothCompletors	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^bothCompletors c1 c2 q code b currentPath = do$/;"	fi	line:1274	language:Haskell
bothEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^bothEq ::$/;"	ft	signature:((CyclicEq a, CyclicEq b) => CT.CycleTable Int Int -> CT.CycleTable Int Int -> a -> a -> b -> b -> IO Bool)	line:34	language:Haskell
bothEq'	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^bothEq' :: (Eq a, CyclicEq b) => CT.CycleTable Int Int -> CT.CycleTable Int Int$/;"	ft	signature:((Eq a, CyclicEq b) => CT.CycleTable Int Int -> CT.CycleTable Int Int -> a -> a -> b -> b -> IO Bool)	line:28	language:Haskell
bothOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^bothOrd ::$/;"	ft	signature:((CyclicOrd a, CyclicOrd b) => CT.CycleTable Int Int -> CT.CycleTable Int Int -> a -> a -> b -> b -> IO Ordering)	line:29	language:Haskell
bothOrd'	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^bothOrd' ::$/;"	ft	signature:((Ord a, CyclicOrd b) => CT.CycleTable Int Int -> CT.CycleTable Int Int -> a -> a -> b -> b -> IO Ordering)	line:22	language:Haskell
bound	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^bound :: Nat -> Vec a -> Nat$/;"	ft	signature:(Nat -> Vec a -> Nat)	line:42	language:Haskell
bound	./unison-core/src/Unison/ABT.hs	/^bound :: (Ord v, Foldable f) => Term f v a -> Set v$/;"	ft	signature:((Ord v, Foldable f) => Term f v a -> Set v)	line:123	language:Haskell
bound	./unison-core/src/Unison/DataDeclaration.hs	/^  bound :: [v],$/;"	c_a	cons:DataDeclaration'.DataDeclaration	line:77	language:Haskell
bound'	./unison-core/src/Unison/ABT.hs	/^bound' :: Foldable f => Term f v a -> [v]$/;"	ft	signature:(Foldable f => Term f v a -> [v])	line:95	language:Haskell
boundVarsIR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^boundVarsIR :: IR e cont -> Set Symbol$/;"	ft	signature:(IR e cont -> Set Symbol)	line:646	language:Haskell
boxForkLeft	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxForkLeft, boxLeft, boxRight ::$/;"	ft	signature:(forall s . (LL.ListLike s Char, IsString s) => [Pretty s] -> [Pretty s])	line:706	language:Haskell
boxLeft	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxForkLeft, boxLeft, boxRight ::$/;"	ft	signature:(forall s . (LL.ListLike s Char, IsString s) => [Pretty s] -> [Pretty s])	line:706	language:Haskell
boxLeft	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxLeft = boxLeft' lBoxStyle2$/;"	fi	line:709	language:Haskell
boxLeft'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxLeft', boxRight' :: (LL.ListLike s Char, IsString s)$/;"	ft	signature:((LL.ListLike s Char, IsString s) => BoxStyle s -> [Pretty s] -> [Pretty s])	line:712	language:Haskell
boxLeftM	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxLeftM, boxRightM :: forall m s . (Monad m, LL.ListLike s Char, IsString s)$/;"	ft	signature:(forall m s . (Monad m, LL.ListLike s Char, IsString s) => [m (Pretty s)] -> [m (Pretty s)])	line:737	language:Haskell
boxLeftM'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxLeftM' :: forall m s . (Monad m, LL.ListLike s Char, IsString s)$/;"	ft	signature:(forall m s . (Monad m, LL.ListLike s Char, IsString s) => BoxStyle s -> [m (Pretty s)] -> [m (Pretty s)])	line:742	language:Haskell
boxRight	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxForkLeft, boxLeft, boxRight ::$/;"	ft	signature:(forall s . (LL.ListLike s Char, IsString s) => [Pretty s] -> [Pretty s])	line:706	language:Haskell
boxRight	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxRight = boxRight' rBoxStyle2$/;"	fi	line:710	language:Haskell
boxRight'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxLeft', boxRight' :: (LL.ListLike s Char, IsString s)$/;"	ft	signature:((LL.ListLike s Char, IsString s) => BoxStyle s -> [Pretty s] -> [Pretty s])	line:712	language:Haskell
boxRight'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxRight' style = fmap runIdentity . boxRightM' style . fmap Identity$/;"	fi	line:715	language:Haskell
boxRightM	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxLeftM, boxRightM :: forall m s . (Monad m, LL.ListLike s Char, IsString s)$/;"	ft	signature:(forall m s . (Monad m, LL.ListLike s Char, IsString s) => [m (Pretty s)] -> [m (Pretty s)])	line:737	language:Haskell
boxRightM	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxRightM = boxRightM' rBoxStyle2$/;"	fi	line:740	language:Haskell
boxRightM'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^boxRightM' :: forall m s. (Monad m, LL.ListLike s Char, IsString s)$/;"	ft	signature:(forall m s. (Monad m, LL.ListLike s Char, IsString s) => BoxStyle s -> [m (Pretty s)] -> [m (Pretty s)])	line:757	language:Haskell
braceList	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^braceList :: [(Char,Char)]$/;"	ft	signature:([(Char, Char)])	line:349	language:Haskell
bracket	./parser-typechecker/src/Unison/Util/Pretty.hs	/^bracket :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s)	line:703	language:Haskell
bracket	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^bracket :: MonadException m => m a -> (a -> m b) -> (a -> m c) -> m c$/;"	ft	signature:(MonadException m => m a -> (a -> m b) -> (a -> m c) -> m c)	line:117	language:Haskell
bracketSet	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^bracketSet :: MonadException m => IO a -> (a -> IO ()) -> a -> m b -> m b$/;"	ft	signature:(MonadException m => IO a -> (a -> IO ()) -> a -> m b -> m b)	line:163	language:Haskell
branch0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^branch0 :: Metadata.Star Referent NameSegment$/;"	ft	signature:(Metadata.Star Referent NameSegment -> Metadata.Star Reference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (EditHash, m Patch) -> Branch0 m)	line:286	language:Haskell
branchFromFiles	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^branchFromFiles :: MonadIO m => BranchLoadMode -> FilePath -> Branch.Hash -> m (Branch m)$/;"	ft	signature:(MonadIO m => BranchLoadMode -> FilePath -> Branch.Hash -> m (Branch m))	line:306	language:Haskell
branchHashLength	./parser-typechecker/src/Unison/Codebase.hs	/^           , branchHashLength   :: m Int$/;"	c_a	cons:Codebase.Codebase	line:89	language:Haskell
branchHashesByPrefix	./parser-typechecker/src/Unison/Codebase.hs	/^           , branchHashesByPrefix :: ShortBranchHash -> m (Set Branch.Hash)$/;"	c_a	cons:Codebase.Codebase	line:90	language:Haskell
branchHashesByPrefix	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^branchHashesByPrefix :: MonadIO m => CodebasePath -> ShortBranchHash -> m (Set Branch.Hash)$/;"	ft	signature:(MonadIO m => CodebasePath -> ShortBranchHash -> m (Set Branch.Hash))	line:611	language:Haskell
branchHeadDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^branchHeadDir root = branchesDir root <\/> "_head"$/;"	fi	line:190	language:Haskell
branchHeadUpdates	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^branchHeadUpdates root = do$/;"	fi	line:728	language:Haskell
branchPath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^branchPath :: CodebasePath -> Hash.Hash -> FilePath$/;"	ft	signature:(CodebasePath -> Hash.Hash -> FilePath)	line:265	language:Haskell
branchesDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^branchesDir root = root <\/> "paths"$/;"	fi	line:189	language:Haskell
break	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  break f at = (LL.takeWhile (not . f) at, LL.dropWhile (not . f) at)$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:51	language:Haskell
breakAt	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^breakAt :: (Var v, Ord loc)$/;"	ft	signature:((Var v, Ord loc) => Element v loc -> Context v loc -> Maybe (Context v loc, Element v loc, [Element v loc]))	line:401	language:Haskell
breakAtDashes	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^breakAtDashes :: String -> [String]$/;"	ft	signature:(String -> [String])	line:94	language:Haskell
btw	./parser-typechecker/src/Unison/Typechecker.hs	/^btw :: Monad f => Context.InfoNote v loc -> ResultT (Notes v loc) f ()$/;"	ft	signature:(Monad f => Context.InfoNote v loc -> ResultT (Notes v loc) f ())	line:193	language:Haskell
btw	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^btw :: InfoNote v loc -> M v loc ()$/;"	ft	signature:(InfoNote v loc -> M v loc ())	line:197	language:Haskell
btw'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^btw' :: InfoNote v loc -> Result v loc ()$/;"	ft	signature:(InfoNote v loc -> Result v loc ())	line:148	language:Haskell
bufferModeBlockId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
bufferModeBlockId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^bufferModeBlockId = constructorNamed bufferModeReference "io.BufferMode.Block"$/;"	fi	line:103	language:Haskell
bufferModeLineId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
bufferModeLineId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^bufferModeLineId = constructorNamed bufferModeReference "io.BufferMode.Line"$/;"	fi	line:102	language:Haskell
bufferModeReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^bufferModeReference = typeNamed "io.BufferMode"$/;"	fi	line:71	language:Haskell
bugs	./parser-typechecker/src/Unison/Typechecker.hs	/^  bugs   :: Seq (Context.CompilerBug v loc),$/;"	c_a	cons:Notes.Notes	line:45	language:Haskell
buildTest	./parser-typechecker/tests/Unison/Test/Transcripts.hs	/^buildTest :: FilePath -> String -> Test ()$/;"	ft	signature:(FilePath -> String -> Test ())	line:15	language:Haskell
builtin	./unison-core/src/Unison/Term.hs	/^builtin :: Ord v => a -> Text -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Text -> Term2 vt at ap v a)	line:479	language:Haskell
builtin	./unison-core/src/Unison/Type.hs	/^builtin :: Ord v => a -> Text -> Type v a$/;"	ft	signature:(Ord v => a -> Text -> Type v a)	line:225	language:Haskell
builtinAnnotation	./parser-typechecker/src/Unison/Codebase.hs	/^  builtinAnnotation :: a$/;"	ft	signature:(a)	class:BuiltinAnnotation	line:283	language:Haskell
builtinAnnotation	./parser-typechecker/src/Unison/Codebase.hs	/^  builtinAnnotation = Parser.Intrinsic$/;"	fi	instance:BuiltinAnnotation Parser-Ann	line:286	language:Haskell
builtinCompilationEnv	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^builtinCompilationEnv :: CompilationEnv$/;"	ft	signature:(CompilationEnv)	line:256	language:Haskell
builtinConstructorType	./parser-typechecker/src/Unison/Builtin.hs	/^builtinConstructorType :: Map R.Reference CT.ConstructorType$/;"	ft	signature:(Map R.Reference CT.ConstructorType)	line:177	language:Haskell
builtinDataDecls	./parser-typechecker/src/Unison/Builtin.hs	/^builtinDataDecls :: Var v => [(v, (R.Reference, DataDeclaration v))]$/;"	ft	signature:(Var v => [(v, (R.Reference, DataDeclaration v))])	line:87	language:Haskell
builtinDataDecls	./unison-core/src/Unison/DataDeclaration.hs	/^builtinDataDecls :: Var v => [(v, Reference, DataDeclaration' v ())]$/;"	ft	signature:(Var v => [(v, Reference, DataDeclaration' v ())])	line:451	language:Haskell
builtinDependencies	./parser-typechecker/src/Unison/Builtin.hs	/^builtinDependencies :: Rel.Relation R.Reference R.Reference$/;"	ft	signature:(Rel.Relation R.Reference R.Reference)	line:101	language:Haskell
builtinEffectDecls	./parser-typechecker/src/Unison/Builtin.hs	/^builtinEffectDecls :: Var v => [(v, (R.Reference, EffectDeclaration v))]$/;"	ft	signature:(Var v => [(v, (R.Reference, EffectDeclaration v))])	line:91	language:Haskell
builtinTermsByType	./parser-typechecker/src/Unison/Builtin.hs	/^builtinTermsByType :: Rel.Relation R.Reference Referent.Referent$/;"	ft	signature:(Rel.Relation R.Reference Referent.Referent)	line:106	language:Haskell
builtinTermsByTypeMention	./parser-typechecker/src/Unison/Builtin.hs	/^builtinTermsByTypeMention :: Rel.Relation R.Reference Referent.Referent$/;"	ft	signature:(Rel.Relation R.Reference Referent.Referent)	line:113	language:Haskell
builtinTypeDependents	./parser-typechecker/src/Unison/Builtin.hs	/^builtinTypeDependents :: R.Reference -> Set R.Reference$/;"	ft	signature:(R.Reference -> Set R.Reference)	line:120	language:Haskell
builtinTypes	./parser-typechecker/src/Unison/Builtin.hs	/^builtinTypes :: [(Name, R.Reference)]$/;"	ft	signature:([(Name, R.Reference)])	line:126	language:Haskell
builtinTypesSrc	./parser-typechecker/src/Unison/Builtin.hs	/^builtinTypesSrc :: [BuiltinTypeDSL]$/;"	ft	signature:([BuiltinTypeDSL])	line:150	language:Haskell
builtins	./parser-typechecker/src/Unison/Runtime/IR.hs	/^builtins :: Map R.Reference (IR e cont)$/;"	ft	signature:(Map R.Reference (IR e cont))	line:864	language:Haskell
builtinsSrc	./parser-typechecker/src/Unison/Builtin.hs	/^builtinsSrc :: Var v => [BuiltinDSL v]$/;"	ft	signature:(Var v => [BuiltinDSL v])	line:226	language:Haskell
bulleted	./parser-typechecker/src/Unison/Util/Pretty.hs	/^bulleted = prefixed "* " "  "$/;"	fi	line:399	language:Haskell
bytes	./unison-core/src/Unison/Type.hs	/^bytes :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:249	language:Haskell
bytesRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
bytesRef	./unison-core/src/Unison/Type.hs	/^bytesRef = Reference.Builtin "Bytes"$/;"	fi	line:220	language:Haskell
c	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^c :: M (Causal M Int64 [Int64])$/;"	ft	signature:(M (Causal M Int64 [Int64]))	line:28	language:Haskell
c	./unison-core/src/Unison/Pattern.hs	/^pattern Char c = CharP () c$/;"	fi	line:105	language:Haskell
c2	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^c2 :: M (Causal M Int64 [Int64])$/;"	ft	signature:(M (Causal M Int64 [Int64]))	line:37	language:Haskell
calcImports	./parser-typechecker/src/Unison/TermPrinter.hs	/^calcImports im tm = (im', render $ getUses result)$/;"	fi	line:870	language:Haskell
callout	./parser-typechecker/src/Unison/Util/Pretty.hs	/^callout :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s)	line:700	language:Haskell
cancelInput	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^cancelInput :: InputState -> IO ()$/;"	ft	signature:(InputState -> IO ())	line:84	language:Haskell
cancel_input	./yaks/haskeline/examples/export/HaskelineExport.hs	/^cancel_input sptr = do$/;"	fi	line:31	language:Haskell
candidates	./parser-typechecker/src/Unison/Util/Find.hs	/^candidates :: Names.Names' Name.Name -> HashQualified -> [SearchResult]$/;"	ft	signature:(Names.Names' Name.Name -> HashQualified -> [SearchResult])	line:141	language:Haskell
canonicalizeKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^canonicalizeKey :: Key -> Key$/;"	ft	signature:(Key -> Key)	line:120	language:Haskell
capitalize	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^capitalize :: [Grapheme] -> [Grapheme]$/;"	ft	signature:([Grapheme] -> [Grapheme])	line:100	language:Haskell
catch	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^catch :: (MonadException m, E.Exception e) => m a -> (e -> m a) -> m a$/;"	ft	signature:((MonadException m, E.Exception e) => m a -> (e -> m a) -> m a)	line:97	language:Haskell
catchAny	./parser-typechecker/src/Unison/Util/Exception.hs	/^catchAny :: IO a -> (SomeException -> IO a) -> IO a$/;"	ft	signature:(IO a -> (SomeException -> IO a) -> IO a)	line:15	language:Haskell
catches	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^catches :: (MonadException m) => m a -> [Handler m a] -> m a$/;"	ft	signature:((MonadException m) => m a -> [Handler m a] -> m a)	line:105	language:Haskell
cause	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  cause :: Cause v loc,$/;"	c_a	cons:ErrorNote.ErrorNote	line:264	language:Haskell
cause	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^cause :: ErrorExtractor v loc (C.Cause v loc)$/;"	ft	signature:(ErrorExtractor v loc (C.Cause v loc))	line:224	language:Haskell
cd	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^cd :: InputPattern$/;"	ft	signature:(InputPattern)	line:479	language:Haskell
ceilDiv	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^ceilDiv :: Integral a => a -> a -> a$/;"	ft	signature:(Integral a => a -> a -> a)	line:160	language:Haskell
chDelta	./parser-typechecker/src/Unison/Util/Pretty.hs	/^chDelta :: Char -> Delta$/;"	ft	signature:(Char -> Delta)	line:656	language:Haskell
chainl1	./parser-typechecker/src/Unison/Parser.hs	/^chainl1 :: Ord v => P v a -> P v (a -> a -> a) -> P v a$/;"	ft	signature:(Ord v => P v a -> P v (a -> a -> a) -> P v a)	line:424	language:Haskell
chainr1	./parser-typechecker/src/Unison/Parser.hs	/^chainr1 :: Ord v => P v a -> P v (a -> a -> a) -> P v a$/;"	ft	signature:(Ord v => P v a -> P v (a -> a -> a) -> P v a)	line:418	language:Haskell
change	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^change :: (LineState t, Monad m) => (s -> t) -> Command m s t$/;"	ft	signature:((LineState t, Monad m) => (s -> t) -> Command m s t)	line:159	language:Haskell
changeFromChar	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^changeFromChar :: (LineState t, Monad m) => (Char -> s -> t) -> KeyCommand m s t$/;"	ft	signature:((LineState t, Monad m) => (Char -> s -> t) -> KeyCommand m s t)	line:162	language:Haskell
changeLeft	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^changeRight, changeLeft :: Int -> ActionM ()$/;"	ft	signature:(Int -> ActionM ())	line:243	language:Haskell
changeLeft	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^changeLeft n    | n <= 0 = return ()$/;"	fi	line:246	language:Haskell
changePos	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^changePos :: TermPos -> TermPos -> TermAction$/;"	ft	signature:(TermPos -> TermPos -> TermAction)	line:226	language:Haskell
changeRight	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^changeRight, changeLeft :: Int -> ActionM ()$/;"	ft	signature:(Int -> ActionM ())	line:243	language:Haskell
changeVars	./unison-core/src/Unison/ABT.hs	/^changeVars :: (Foldable f, Functor f, Var v) => Map v v -> Term f v a -> Term f v a$/;"	ft	signature:((Foldable f, Functor f, Var v) => Map v v -> Term f v a -> Term f v a)	line:254	language:Haskell
changedPatches	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , changedPatches :: Map NameSegment Patch.PatchDiff$/;"	c_a	cons:BranchDiff.BranchDiff	line:184	language:Haskell
char	./parser-typechecker/src/Unison/TermParser.hs	/^char :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:273	language:Haskell
char	./unison-core/src/Unison/Term.hs	/^char :: Ord v => a -> Char -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Char -> Term2 vt at ap v a)	line:497	language:Haskell
char	./unison-core/src/Unison/Type.hs	/^char :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:243	language:Haskell
char	./yaks/easytest/src/EasyTest.hs	/^char :: Test Char$/;"	ft	signature:(Test Char)	line:221	language:Haskell
char'	./yaks/easytest/src/EasyTest.hs	/^char' :: Char -> Char -> Test Char$/;"	ft	signature:(Char -> Char -> Test Char)	line:243	language:Haskell
charCommand	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^charCommand :: (LineState s, Monad m) => (Char -> s -> m (Either Effect s))$/;"	ft	signature:((LineState s, Monad m) => (Char -> s -> m (Either Effect s)) -> KeyCommand m s s)	line:152	language:Haskell
charRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
charRef	./unison-core/src/Unison/Type.hs	/^charRef = Reference.Builtin "Char"$/;"	fi	line:218	language:Haskell
character	./parser-typechecker/src/Unison/Parser.hs	/^character :: Ord v => P v (L.Token Char)$/;"	ft	signature:(Ord v => P v (L.Token Char))	line:390	language:Haskell
check	./parser-typechecker/src/Unison/Typechecker.hs	/^check env term typ = synthesize env (Term.ann (ABT.annotation term) term typ)$/;"	fi	line:315	language:Haskell
check	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^check :: forall v loc . (Var v, Ord loc) => Term v loc -> Type v loc -> M v loc ()$/;"	ft	signature:(forall v loc . (Var v, Ord loc) => Term v loc -> Type v loc -> M v loc ())	line:1309	language:Haskell
checkCase	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^checkCase :: forall v loc . (Var v, Ord loc)$/;"	ft	signature:(forall v loc . (Var v, Ord loc) => Type v loc -> Type v loc -> Term.MatchCase loc (Term v loc) -> M v loc ())	line:961	language:Haskell
checkForGit	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^checkForGit :: MonadIO m => MonadError GitError m => m ()$/;"	ft	signature:(MonadIO m => MonadError GitError m => m ())	line:97	language:Haskell
checkGitDir	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^checkGitDir :: FilePath -> IO Bool$/;"	ft	signature:(FilePath -> IO Bool)	line:102	language:Haskell
checkPattern	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^checkPattern tx ty | (debugEnabled || debugPatternsEnabled) && traceShow ("checkPattern"::String, tx, ty) False = undefined$/;"	fi	line:989	language:Haskell
checkScoped	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^checkScoped :: forall v loc . (Var v, Ord loc) => Term v loc -> Type v loc -> M v loc ()$/;"	ft	signature:(forall v loc . (Var v, Ord loc) => Term v loc -> Type v loc -> M v loc ())	line:1297	language:Haskell
checkTodo	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^checkTodo :: Patch -> Names0 -> Action m i v (TO.TodoOutput v Ann)$/;"	ft	signature:(Patch -> Names0 -> Action m i v (TO.TodoOutput v Ann))	line:1688	language:Haskell
children	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^children :: Lens' (Branch0 m) (Map NameSegment (Branch m))$/;"	ft	signature:(Lens' (Branch0 m) (Map NameSegment (Branch m)))	line:282	language:Haskell
children	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^children :: Causal m h e -> Seq (m (Causal m h e))$/;"	ft	signature:(Causal m h e -> Seq (m (Causal m h e)))	line:201	language:Haskell
choiceCmd	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^choiceCmd :: [KeyMap a] -> KeyMap a$/;"	ft	signature:([KeyMap a] -> KeyMap a)	line:103	language:Haskell
choose	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^choose :: (B.FiniteBits bits, UV.Unbox a)$/;"	ft	signature:((B.FiniteBits bits, UV.Unbox a) => bits -> SparseVector bits a -> SparseVector bits a -> SparseVector bits a)	line:86	language:Haskell
chunkEmpty	./parser-typechecker/src/Unison/Parser.hs	/^  chunkEmpty pxy = null . P.chunkToTokens pxy$/;"	fi	instance:P-Stream Input	line:149	language:Haskell
chunkLength	./parser-typechecker/src/Unison/Parser.hs	/^  chunkLength pxy = length . P.chunkToTokens pxy$/;"	fi	instance:P-Stream Input	line:147	language:Haskell
chunkToTokens	./parser-typechecker/src/Unison/Parser.hs	/^  chunkToTokens _ = inputStream$/;"	fi	instance:P-Stream Input	line:145	language:Haskell
chunks	./parser-typechecker/src/Unison/Util/Bytes.hs	/^chunks :: Bytes -> [B.ByteString]$/;"	ft	signature:(Bytes -> [B.ByteString])	line:36	language:Haskell
cid	./unison-core/src/Unison/ShortHash.hs	/^  | ShortHash { prefix :: Text, cycle :: Maybe Text, cid :: Maybe Text }$/;"	c_a	cons:ShortHash.ShortHash	line:14	language:Haskell
cleanup	./unison-core/src/Unison/Type.hs	/^cleanup :: Var v => Type v a -> Type v a$/;"	ft	signature:(Var v => Type v a -> Type v a)	line:566	language:Haskell
cleanupAbilityLists	./unison-core/src/Unison/Type.hs	/^cleanupAbilityLists :: Var v => Type v a -> Type v a$/;"	ft	signature:(Var v => Type v a -> Type v a)	line:551	language:Haskell
cleanupTypes	./unison-core/src/Unison/Settings.hs	/^cleanupTypes :: Bool$/;"	ft	signature:(Bool)	line:17	language:Haskell
cleanupVars	./unison-core/src/Unison/Type.hs	/^cleanupVars :: Var v => [Type v a] -> [Type v a]$/;"	ft	signature:(Var v => [Type v a] -> [Type v a])	line:523	language:Haskell
cleanupVars1	./unison-core/src/Unison/Type.hs	/^cleanupVars1 :: Var v => Type v a -> Type v a$/;"	ft	signature:(Var v => Type v a -> Type v a)	line:546	language:Haskell
cleanupVars1'	./unison-core/src/Unison/Type.hs	/^cleanupVars1' :: Var v => Map.Map v v -> Type v a -> Type v a$/;"	ft	signature:(Var v => Map.Map v v -> Type v a -> Type v a)	line:541	language:Haskell
cleanupVarsMap	./unison-core/src/Unison/Type.hs	/^cleanupVarsMap :: Var v => [Type v a] -> Map.Map v v$/;"	ft	signature:(Var v => [Type v a] -> Map.Map v v)	line:532	language:Haskell
cleanups	./unison-core/src/Unison/Type.hs	/^cleanups :: Var v => [Type v a] -> [Type v a]$/;"	ft	signature:(Var v => [Type v a] -> [Type v a])	line:563	language:Haskell
clearAll	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^clearAll :: LinesAffected -> TermAction$/;"	ft	signature:(LinesAffected -> TermAction)	line:211	language:Haskell
clearAllA	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                        clearAllA :: LinesAffected -> TermOutput,$/;"	c_a	cons:Actions.Actions	line:39	language:Haskell
clearCurrentLine	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^clearCurrentLine :: IO ()$/;"	ft	signature:(IO ())	line:33	language:Haskell
clearDeadText	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^clearDeadText :: Int -> String$/;"	ft	signature:(Int -> String)	line:113	language:Haskell
clearDeadText	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^clearDeadText :: TermRows -> ActionM ()$/;"	ft	signature:(TermRows -> ActionM ())	line:317	language:Haskell
clearLayout	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    clearLayout = clearLayoutD$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	line:44	language:Haskell
clearLayout	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    clearLayout = runActionT clearLayoutT$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:360	language:Haskell
clearLayout	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    clearLayout = clearScreen$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:361	language:Haskell
clearLayout	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    clearLayout :: m ()$/;"	ft	signature:(m ())	class:Term	line:25	language:Haskell
clearLayoutD	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^clearLayoutD :: DumbTermM ()$/;"	ft	signature:(DumbTermM ())	line:64	language:Haskell
clearLayoutT	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^clearLayoutT :: ActionM ()$/;"	ft	signature:(ActionM ())	line:330	language:Haskell
clearLine	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^drawLine, clearLine :: Term m => LineChars -> m ()$/;"	ft	signature:(Term m => LineChars -> m ())	line:28	language:Haskell
clearLine	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^clearLine = flip drawLineDiff ([],[])$/;"	fi	line:31	language:Haskell
clearScreen	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^clearScreen :: DrawM ()$/;"	ft	signature:(DrawM ())	line:538	language:Haskell
clearScreenCmd	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^clearScreenCmd :: Command m s s$/;"	ft	signature:(Command m s s)	line:141	language:Haskell
clearToLineEnd	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                        clearToLineEnd :: TermOutput,$/;"	c_a	cons:Actions.Actions	line:36	language:Haskell
closeBlock	./parser-typechecker/src/Unison/Parser.hs	/^closeBlock :: Ord v => P v (L.Token ())$/;"	ft	signature:(Ord v => P v (L.Token ()))	line:281	language:Haskell
closeHandles	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^                        , closeHandles :: IO ()}$/;"	c_a	cons:Handles.Handles	line:53	language:Haskell
closeHandles	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^closeHandles :: Handles -> IO ()$/;"	ft	signature:(Handles -> IO ())	line:259	language:Haskell
closeInput	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^closeInput :: InputState -> IO ()$/;"	ft	signature:(InputState -> IO ())	line:79	language:Haskell
closeTerm	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            closeTerm :: IO ()$/;"	c_a	cons:RunTerm.RunTerm	line:38	language:Haskell
closeWithDependencies	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^closeWithDependencies :: forall v a. Ord v$/;"	ft	signature:(forall v a. Ord v => TypecheckedUnisonFile v a -> SlurpComponent v -> SlurpComponent v)	line:46	language:Haskell
close_input	./yaks/haskeline/examples/export/HaskelineExport.hs	/^close_input sptr = do$/;"	fi	line:26	language:Haskell
closed	./parser-typechecker/src/Unison/FileParser.hs	/^closed :: Var v => P v ()$/;"	ft	signature:(Var v => P v ())	line:138	language:Haskell
codeLookup	./parser-typechecker/src/Unison/Builtin.hs	/^codeLookup :: (Applicative m, Var v) => CodeLookup v m Ann$/;"	ft	signature:((Applicative m, Var v) => CodeLookup v m Ann)	line:94	language:Haskell
codeLookup	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^codeLookup :: CodeLookup Symbol Identity Ann$/;"	ft	signature:(CodeLookup Symbol Identity Ann)	line:48	language:Haskell
codePageToUnicode	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^codePageToUnicode :: CodePage -> B.ByteString -> IO String$/;"	ft	signature:(CodePage -> B.ByteString -> IO String)	line:479	language:Haskell
codebase1	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^codebase1 fmtV@(S.Format getV putV) fmtA@(S.Format getA putA) path =$/;"	fi	line:631	language:Haskell
codebasePath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^codebasePath :: FilePath$/;"	ft	signature:(FilePath)	line:124	language:Haskell
col	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  Delta { line :: !Int, col :: !Int, maxCol :: !Int }$/;"	c_a	cons:Delta.Delta	line:646	language:Haskell
collateReferences	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^collateReferences (toList -> types) (toList -> terms) =$/;"	fi	line:1851	language:Haskell
collectNothings	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^collectNothings :: (a -> Maybe b) -> [a] -> [a]$/;"	ft	signature:((a -> Maybe b) -> [a] -> [a])	line:1325	language:Haskell
collectRan	./unison-core/src/Unison/Util/Relation.hs	/^collectRan :: Ord a => Ord c =>$/;"	ft	signature:(Ord a => Ord c => (b -> Maybe c) -> Relation a b -> Relation a c)	line:486	language:Haskell
collectUntilPause	./parser-typechecker/src/Unison/Codebase/Watch.hs	/^collectUntilPause :: forall m a. MonadIO m => TQueue a -> Int -> m [a]$/;"	ft	signature:(forall m a. MonadIO m => TQueue a -> Int -> m [a])	line:71	language:Haskell
collisions	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , collisions :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:53	language:Haskell
column	./parser-typechecker/src/Unison/Lexer.hs	/^column :: Pos -> Column$/;"	ft	signature:(Pos -> Column)	line:136	language:Haskell
column2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column2 = lines . (group <$>) . align$/;"	fi	line:464	language:Haskell
column2M	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column2M = fmap column2 . sequenceA$/;"	fi	line:470	language:Haskell
column2UnzippedM	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column2UnzippedM bottomPadding left right = let$/;"	fi	line:510	language:Haskell
column3	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column3 = column3sep ""$/;"	fi	line:482	language:Haskell
column3M	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column3M = fmap column3 . sequence$/;"	fi	line:488	language:Haskell
column3UnzippedM	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column3UnzippedM bottomPadding left mid right = let$/;"	fi	line:497	language:Haskell
column3sep	./parser-typechecker/src/Unison/Util/Pretty.hs	/^column3sep sep rows = let$/;"	fi	line:521	language:Haskell
combineStatus	./yaks/easytest/src/EasyTest.hs	/^combineStatus :: Status -> Status -> Status$/;"	ft	signature:(Status -> Status -> Status)	line:27	language:Haskell
combiningChars	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^                            combiningChars :: [Char]}$/;"	c_a	cons:Grapheme.Grapheme	line:77	language:Haskell
commandLine	./parser-typechecker/src/Unison/Codebase/Editor/HandleCommand.hs	/^commandLine config awaitInput setBranchRef rt notifyUser notifyNumbered loadSource codebase rngGen =$/;"	fi	line:106	language:Haskell
commandNameArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^commandNameArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1209	language:Haskell
commandNames	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^commandNames :: [String]$/;"	ft	signature:([String])	line:1206	language:Haskell
commandRedo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^commandUndo, commandRedo :: (MonadState Undo m, Save s) => Command m s s$/;"	ft	signature:((MonadState Undo m, Save s) => Command m s s)	line:47	language:Haskell
commandRedo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^commandRedo = simpleCommand $ liftM Right . update . redoFuture$/;"	fi	line:49	language:Haskell
commandUndo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^commandUndo, commandRedo :: (MonadState Undo m, Save s) => Command m s s$/;"	ft	signature:((MonadState Undo m, Save s) => Command m s s)	line:47	language:Haskell
commas	./parser-typechecker/src/Unison/PrintError.hs	/^commas :: (IsString a, Monoid a) => (b -> a) -> [b] -> a$/;"	ft	signature:((IsString a, Monoid a) => (b -> a) -> [b] -> a)	line:760	language:Haskell
commas	./parser-typechecker/src/Unison/Util/Pretty.hs	/^commas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:304	language:Haskell
commented	./parser-typechecker/src/Unison/Util/Pretty.hs	/^commented = prefixed "-- " "-- "$/;"	fi	line:407	language:Haskell
commit	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^data RemoteRepo = GitRepo { url :: Text, commit :: Maybe Text }$/;"	c_a	cons:RemoteRepo.GitRepo	line:13	language:Haskell
commonPrefix	./yaks/haskeline/tests/RunTTY.hs	/^commonPrefix :: B.ByteString -> B.ByteString$/;"	ft	signature:(B.ByteString -> B.ByteString -> (B.ByteString, B.ByteString, B.ByteString))	line:117	language:Haskell
compactSet	./unison-core/src/Unison/Util/Relation.hs	/^compactSet :: Ord a => Set (Maybe (Set a)) -> Set a$/;"	ft	signature:(Ord a => Set (Maybe (Set a)) -> Set a)	line:284	language:Haskell
compare	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^   compare x y = case compare (toNS x) (toNS y) of$/;"	fi	instance:Var v => Ord (ShallowListEntry v a)	line:210	language:Haskell
compare	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  SymbolC _ s `compare` SymbolC _ s2 = s `compare` s2$/;"	fi	instance:Ord SymbolC	line:950	language:Haskell
compare	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  Universal v `compare` Universal v2 = compare v v2$/;"	fi	instance:Ord v => Ord (TypeVar b v)	line:22	language:Haskell
compare	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  b1 `compare` b2 =$/;"	fi	instance:Ord Bytes	line:97	language:Haskell
compare	./unison-core/src/Unison/ABT.hs	/^  t1 `compare` t2 = go (out t1) (out t2) where$/;"	fi	instance:(Foldable f, Functor f, Ord1 f, Var v) => Ord (Term f v a)	line:544	language:Haskell
compare	./unison-core/src/Unison/HashQualified'.hs	/^  compare a b = case compare (toName a) (toName b) of$/;"	fi	instance:Ord n => Ord (HashQualified' n)	line:110	language:Haskell
compare	./unison-core/src/Unison/HashQualified.hs	/^  compare a b = case compare (toName a) (toName b) of$/;"	fi	instance:Ord n => Ord (HashQualified' n)	line:165	language:Haskell
compare	./unison-core/src/Unison/Symbol.hs	/^  Symbol id1 name1 `compare` Symbol id2 name2 = (id1,name1) `compare` (id2,name2)$/;"	fi	instance:Ord Symbol	line:29	language:Haskell
compare1	./unison-core/src/Unison/Type.hs	/^instance Ord1 F where compare1 = compare$/;"	fi	instance:Ord1 F	line:55	language:Haskell
compilationEnv	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^compilationEnv :: Monad m$/;"	ft	signature:(Monad m => CL.CodeLookup Symbol m a -> Term.Term Symbol a -> m CompilationEnv)	line:225	language:Haskell
compilationEnv0	./parser-typechecker/src/Unison/Runtime/IR.hs	/^compilationEnv0 :: CompilationEnv e cont$/;"	ft	signature:(CompilationEnv e cont)	line:982	language:Haskell
compile	./parser-typechecker/src/Unison/Runtime/IR.hs	/^compile :: (Show e, Show cont) => CompilationEnv e cont -> Term Symbol -> IR e cont$/;"	ft	signature:((Show e, Show cont) => CompilationEnv e cont -> Term Symbol -> IR e cont)	line:425	language:Haskell
compile0	./parser-typechecker/src/Unison/Runtime/IR.hs	/^compile0 env bound t =$/;"	fi	line:446	language:Haskell
compilerBug	./parser-typechecker/src/Unison/Result.hs	/^compilerBug :: Monad f => CompilerBug v loc -> ResultT (Seq (Note v loc)) f a$/;"	ft	signature:(Monad f => CompilerBug v loc -> ResultT (Seq (Note v loc)) f a)	line:86	language:Haskell
compilerBug	./parser-typechecker/src/Unison/Typechecker.hs	/^compilerBug :: Context.CompilerBug v loc -> Result (Notes v loc) ()$/;"	ft	signature:(Context.CompilerBug v loc -> Result (Notes v loc) ())	line:183	language:Haskell
compilerBug	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^compilerBug :: CompilerBug v loc -> Result v loc a$/;"	ft	signature:(CompilerBug v loc -> Result v loc a)	line:154	language:Haskell
compilerCrash	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^compilerCrash :: CompilerBug v loc -> M v loc a$/;"	ft	signature:(CompilerBug v loc -> M v loc a)	line:634	language:Haskell
compilerCrashResult	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^compilerCrashResult :: CompilerBug v loc -> Result v loc a$/;"	ft	signature:(CompilerBug v loc -> Result v loc a)	line:640	language:Haskell
complete	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^data Settings m = Settings {complete :: CompletionFunc m, -- ^ Custom tab completion.$/;"	c_a	cons:Settings.Settings	line:21	language:Haskell
completeFilename	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^completeFilename :: MonadIO m => CompletionFunc m$/;"	ft	signature:(MonadIO m => CompletionFunc m)	line:97	language:Haskell
completeQuotedWord	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^completeQuotedWord :: Monad m => Maybe Char -- ^ An optional escape character$/;"	ft	signature:(Monad m => Maybe Char -> [Char] -> (String -> m [Completion]) -> CompletionFunc m -> CompletionFunc m)	line:120	language:Haskell
completeWord	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^completeWord :: Monad m => Maybe Char$/;"	ft	signature:(Monad m => Maybe Char -> [Char]-- ^ Characters which count as whitespace -> (String -> m [Completion]) -> CompletionFunc m)	line:55	language:Haskell
completeWordWithPrev	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^completeWordWithPrev :: Monad m => Maybe Char$/;"	ft	signature:(Monad m => Maybe Char -> [Char]-- ^ Characters which count as whitespace -> (String -> String -> m [Completion]) -> CompletionFunc m)	line:66	language:Haskell
completeWordWithPrev	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^completeWordWithPrev esc ws f (line, _) = do$/;"	fi	line:74	language:Haskell
completion	./parser-typechecker/src/Unison/CommandLine.hs	/^completion :: String -> Line.Completion$/;"	ft	signature:(String -> Line.Completion)	line:106	language:Haskell
completion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^completion :: String -> Completion$/;"	ft	signature:(String -> Completion)	line:102	language:Haskell
completion'	./parser-typechecker/src/Unison/CommandLine.hs	/^completion' :: String -> Line.Completion$/;"	ft	signature:(String -> Line.Completion)	line:109	language:Haskell
completionCmd	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^completionCmd :: (MonadState Undo m, CommandMonad m)$/;"	ft	signature:((MonadState Undo m, CommandMonad m) => Key -> KeyCommand m InsertMode InsertMode)	line:35	language:Haskell
completionPaging	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     completionPaging :: !Bool, $/;"	c_a	cons:Prefs.Prefs	line:37	language:Haskell
completionPromptLimit	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     completionPromptLimit :: !(Maybe Int),$/;"	c_a	cons:Prefs.Prefs	line:40	language:Haskell
completionType	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     completionType :: !CompletionType,$/;"	c_a	cons:Prefs.Prefs	line:36	language:Haskell
component	./unison-core/src/Unison/Reference.hs	/^component :: H.Hash -> [k] -> [(k, Reference)]$/;"	ft	signature:(H.Hash -> [k] -> [(k, Reference)])	line:152	language:Haskell
componentFor	./unison-core/src/Unison/Reference.hs	/^componentFor :: Reference -> Component$/;"	ft	signature:(Reference -> Component)	line:116	language:Haskell
componentIdFromString	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^componentIdFromString :: String -> Maybe Reference.Id$/;"	ft	signature:(String -> Maybe Reference.Id)	line:405	language:Haskell
componentIdToString	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^componentIdToString :: Reference.Id -> String$/;"	ft	signature:(Reference.Id -> String)	line:401	language:Haskell
components	./unison-core/src/Unison/ABT.hs	/^components :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]$/;"	ft	signature:(Var v => [(v, Term f v a)] -> [[ (v, Term f v a) ]])	line:558	language:Haskell
components	./unison-core/src/Unison/Reference.hs	/^components :: [(H.Hash, [k])] -> [(k, Reference)]$/;"	ft	signature:([(H.Hash, [k])] -> [(k, Reference)])	line:157	language:Haskell
components	./unison-core/src/Unison/Util/Components.hs	/^components :: Ord v => (t -> Set v) -> [(v, t)] -> [[(v, t)]]$/;"	ft	signature:(Ord v => (t -> Set v) -> [(v, t)] -> [[ (v, t) ]])	line:36	language:Haskell
compose	./unison-core/src/Unison/ABT.hs	/^compose :: Monoid m => Path s t a b m -> Path a b a' b' m -> Path s t a' b' m$/;"	ft	signature:(Monoid m => Path s t a b m -> Path a b a' b' m -> Path s t a' b' m)	line:71	language:Haskell
computationType	./parser-typechecker/src/Unison/TypeParser.hs	/^computationType :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:32	language:Haskell
computeFrontier	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^computeFrontier :: forall m . Monad m$/;"	ft	signature:(forall m . Monad m => (Reference -> m (Set Reference)) -> Patch -> Names0 -> m (R.Relation Reference Reference))	line:1728	language:Haskell
computeFrontier	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^computeFrontier getDependents patch names = do$/;"	fi	line:498	language:Haskell
computeSlices	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^computeSlices :: NamespaceSlice Referent$/;"	ft	signature:(NamespaceSlice Referent -> NamespaceSlice Referent -> NamespaceSlice Reference -> NamespaceSlice Reference -> (DiffSlice Referent, DiffSlice Reference))	line:87	language:Haskell
cond	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^cond = booleanMismatch0 CondMismatch Ex.inIfCond$/;"	fi	line:182	language:Haskell
condensedExcerptToText	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^condensedExcerptToText :: Int -> AnnotatedExcerpt a -> AnnotatedText a$/;"	ft	signature:(Int -> AnnotatedExcerpt a -> AnnotatedText a)	line:120	language:Haskell
confirmedCommand	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^confirmedCommand :: Input -> Action m i v Bool$/;"	ft	signature:(Input -> Action m i v Bool)	line:1749	language:Haskell
conflicts	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , conflicts :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:56	language:Haskell
conflicts	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^conflicts :: Patch -> Patch$/;"	ft	signature:(Patch -> Patch)	line:111	language:Haskell
conflicts	./unison-core/src/Unison/Names2.hs	/^conflicts :: Ord n => Names' n -> Names' n$/;"	ft	signature:(Ord n => Names' n -> Names' n)	line:320	language:Haskell
cons	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^cons :: Applicative m => Branch0 m -> Branch m -> Branch m$/;"	ft	signature:(Applicative m => Branch0 m -> Branch m -> Branch m)	line:607	language:Haskell
cons	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^cons :: (Applicative m, Hashable e) => e -> Causal m h e -> Causal m h e$/;"	ft	signature:((Applicative m, Hashable e) => e -> Causal m h e -> Causal m h e)	line:316	language:Haskell
cons	./parser-typechecker/src/Unison/Codebase/Path.hs	/^cons :: NameSegment -> Path -> Path$/;"	ft	signature:(NameSegment -> Path -> Path)	line:255	language:Haskell
cons	./parser-typechecker/src/Unison/Util/Bytes.hs	/^cons :: B.ByteString -> Bytes -> Bytes$/;"	ft	signature:(B.ByteString -> Bytes -> Bytes)	line:39	language:Haskell
cons	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^cons :: [Int64]$/;"	ft	signature:([Int64] -> Causal M h [Int64] -> Causal M h [Int64])	line:249	language:Haskell
cons''	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^cons'' :: Hashable e1$/;"	ft	signature:(Hashable e1 => (Causal m1 h e2 -> m2 (Causal m2 h e1)) -> e1 -> Causal m1 h e2 -> Causal m2 h e1)	line:262	language:Haskell
consDistinct	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^consDistinct :: (Applicative m, Eq e, Hashable e) => e -> Causal m h e -> Causal m h e$/;"	ft	signature:((Applicative m, Eq e, Hashable e) => e -> Causal m h e -> Causal m h e)	line:320	language:Haskell
consoleHandles	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^consoleHandles :: MaybeT IO Handles$/;"	ft	signature:(MaybeT IO Handles)	line:64	language:Haskell
constructIoError	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^constructIoError :: IOError -> RT.Value$/;"	ft	signature:(IOError -> RT.Value)	line:250	language:Haskell
constructLeft	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^constructLeft :: RT.Value -> RT.Value$/;"	ft	signature:(RT.Value -> RT.Value)	line:172	language:Haskell
constructNone	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^constructNone :: RT.Value$/;"	ft	signature:(RT.Value)	line:181	language:Haskell
constructPair	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^constructPair :: RT.Value -> RT.Value -> RT.Value$/;"	ft	signature:(RT.Value -> RT.Value -> RT.Value)	line:197	language:Haskell
constructRight	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^constructRight :: RT.Value -> RT.Value$/;"	ft	signature:(RT.Value -> RT.Value)	line:175	language:Haskell
constructSome	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^constructSome :: RT.Value -> RT.Value$/;"	ft	signature:(RT.Value -> RT.Value)	line:178	language:Haskell
constructor	./unison-core/src/Unison/Term.hs	/^constructor :: Ord v => a -> Reference -> Int -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Reference -> Int -> Term2 vt at ap v a)	line:517	language:Haskell
constructorArities	./unison-core/src/Unison/DataDeclaration.hs	/^constructorArities :: DataDeclaration' v a -> [Int]$/;"	ft	signature:(DataDeclaration' v a -> [Int])	line:269	language:Haskell
constructorArity	./parser-typechecker/src/Unison/Runtime/IR.hs	/^constructorArity :: CompilationEnv e cont -> R.Reference -> Int -> Maybe Int$/;"	ft	signature:(CompilationEnv e cont -> R.Reference -> Int -> Maybe Int)	line:58	language:Haskell
constructorArity'	./parser-typechecker/src/Unison/Runtime/IR.hs	/^                   , constructorArity' :: Map (R.Reference, Int) Int }$/;"	c_a	cons:CompilationEnv.CompilationEnv	line:53	language:Haskell
constructorDependencies	./unison-core/src/Unison/Term.hs	/^constructorDependencies =$/;"	fi	line:827	language:Haskell
constructorExistingTermCollisions	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , constructorExistingTermCollisions :: Set v$/;"	c_a	cons:SlurpResult.SlurpResult	line:64	language:Haskell
constructorId	./parser-typechecker/src/Unison/Runtime/IR.hs	/^constructorId :: Value e cont -> Int$/;"	ft	signature:(Value e cont -> Int)	line:1050	language:Haskell
constructorId	./unison-core/src/Unison/DataDeclaration.hs	/^constructorId :: Reference -> Text -> Maybe Int$/;"	ft	signature:(Reference -> Text -> Maybe Int)	line:425	language:Haskell
constructorName	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^constructorName :: R.Reference -> DD.ConstructorId -> Text$/;"	ft	signature:(R.Reference -> DD.ConstructorId -> Text)	line:139	language:Haskell
constructorNamed	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^constructorNamed :: R.Reference -> Text -> DD.ConstructorId$/;"	ft	signature:(R.Reference -> Text -> DD.ConstructorId)	line:120	language:Haskell
constructorNames	./unison-core/src/Unison/DataDeclaration.hs	/^constructorNames :: Var v => DataDeclaration' v a -> [Text]$/;"	ft	signature:(Var v => DataDeclaration' v a -> [Text])	line:184	language:Haskell
constructorReplacements	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  , constructorReplacements :: Map (Reference, Int, ConstructorType)$/;"	c_a	cons:Edits.Edits	line:61	language:Haskell
constructorTerms	./unison-core/src/Unison/DataDeclaration.hs	/^constructorTerms hashCtor f rid dd =$/;"	fi	line:152	language:Haskell
constructorType	./parser-typechecker/src/Unison/Builtin.hs	/^constructorType :: R.Reference -> Maybe CT.ConstructorType$/;"	ft	signature:(R.Reference -> Maybe CT.ConstructorType)	line:81	language:Haskell
constructorType	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^constructorType :: TypeLookup v a -> Reference -> Maybe CT.ConstructorType$/;"	ft	signature:(TypeLookup v a -> Reference -> Maybe CT.ConstructorType)	line:35	language:Haskell
constructorType	./parser-typechecker/src/Unison/UnisonFile.hs	/^constructorType ::$/;"	ft	signature:(Var v => UnisonFile v a -> Reference -> Maybe CT.ConstructorType)	line:249	language:Haskell
constructorType	./unison-core/src/Unison/DataDeclaration.hs	/^constructorType :: Decl v a -> CT.ConstructorType$/;"	ft	signature:(Decl v a -> CT.ConstructorType)	line:66	language:Haskell
constructorTypes	./unison-core/src/Unison/DataDeclaration.hs	/^constructorTypes :: DataDeclaration' v a -> [Type v a]$/;"	ft	signature:(DataDeclaration' v a -> [Type v a])	line:172	language:Haskell
constructorVars	./unison-core/src/Unison/DataDeclaration.hs	/^constructorVars :: DataDeclaration' v a -> [v]$/;"	ft	signature:(DataDeclaration' v a -> [v])	line:181	language:Haskell
constructors	./unison-core/src/Unison/DataDeclaration.hs	/^constructors :: DataDeclaration' v a -> [(v, Type v a)]$/;"	ft	signature:(DataDeclaration' v a -> [(v, Type v a)])	line:178	language:Haskell
constructors'	./unison-core/src/Unison/DataDeclaration.hs	/^  constructors' :: [(a, v, Type v a)]$/;"	c_a	cons:DataDeclaration'.DataDeclaration	line:78	language:Haskell
constructorsFor	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^constructorsFor :: Var v => Set v -> UF.TypecheckedUnisonFile v Ann -> Set v$/;"	ft	signature:(Var v => Set v -> UF.TypecheckedUnisonFile v Ann -> Set v)	line:72	language:Haskell
constructorsForType0	./unison-core/src/Unison/Names3.hs	/^constructorsForType0 :: Reference -> Names0 -> [(Name,Referent)]$/;"	ft	signature:(Reference -> Names0 -> [(Name, Referent)])	line:192	language:Haskell
contains	./parser-typechecker/src/Unison/Util/Range.hs	/^contains :: Range -> Range -> Bool$/;"	ft	signature:(Range -> Range -> Bool)	line:6	language:Haskell
contains	./unison-core/src/Unison/Names2.hs	/^contains :: Names' n -> Reference -> Bool$/;"	ft	signature:(Names' n -> Reference -> Bool)	line:313	language:Haskell
context0	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^context0 :: Context v loc$/;"	ft	signature:(Context v loc)	line:338	language:Haskell
continuationConstructorId	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^continuationConstructorId :: Continuation -> Int$/;"	ft	signature:(Continuation -> Int)	line:844	language:Haskell
controlActions	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^simpleActions, controlActions :: InputKeyCmd InsertMode InsertMode$/;"	ft	signature:(InputKeyCmd InsertMode InsertMode)	line:35	language:Haskell
controlActions	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^controlActions = choiceCmd$/;"	fi	line:48	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO :: (RunIO m -> IO (m a)) -> m a$/;"	ft	signature:((RunIO m -> IO (m a)) -> m a)	class:MonadException	line:66	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = join $ f (RunIO (liftM return))$/;"	fi	instance:MonadException IO	line:139	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = ReaderT $ \\r -> controlIO $ \\(RunIO run) -> let$/;"	fi	instance:MonadException m => MonadException (ReaderT r m)	line:145	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = StateT $ \\s -> controlIO $ \\(RunIO run) -> let$/;"	fi	instance:MonadException m => MonadException (StateT s m)	line:150	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = MaybeT $ controlIO $ \\(RunIO run) -> let$/;"	fi	instance:MonadException m => MonadException (MaybeT m)	line:155	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = ErrorT $ controlIO $ \\(RunIO run) -> let$/;"	fi	instance:(MonadException m, Error e) => MonadException (ErrorT e m)	line:160	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = ListT $ controlIO $ \\(RunIO run) -> let$/;"	fi	instance:MonadException m => MonadException (ListT m)	line:165	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = WriterT $ controlIO $ \\(RunIO run) -> let$/;"	fi	instance:(Monoid w, MonadException m) => MonadException (WriterT w m)	line:170	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^    controlIO f = RWST $ \\r s -> controlIO $ \\(RunIO run) -> let$/;"	fi	instance:(Monoid w, MonadException m) => MonadException (RWST r w s m)	line:175	language:Haskell
controlIO	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    controlIO f = makeStateT $ \\s -> controlIO $ \\run ->$/;"	fi	instance:MonadException m => MonadException (StateT s m)	line:127	language:Haskell
controlKeyState	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^                          controlKeyState :: DWORD}$/;"	c_a	cons:InputEvent.KeyEvent	line:124	language:Haskell
convertErrorType	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^convertErrorType :: IOError -> IR.ConstructorId$/;"	ft	signature:(IOError -> IR.ConstructorId)	line:200	language:Haskell
convertMaybe	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^convertMaybe :: Maybe RT.Value -> RT.Value$/;"	ft	signature:(Maybe RT.Value -> RT.Value)	line:184	language:Haskell
convertNotes	./parser-typechecker/src/Unison/FileParsers.hs	/^convertNotes :: Ord v => Typechecker.Notes v ann -> Seq (Note v ann)$/;"	ft	signature:(Ord v => Typechecker.Notes v ann -> Seq (Note v ann))	line:48	language:Haskell
convertOptional	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^convertOptional :: RT.Value -> Maybe RT.Value$/;"	ft	signature:(RT.Value -> Maybe RT.Value)	line:188	language:Haskell
convertResult	./parser-typechecker/src/Unison/Typechecker.hs	/^convertResult :: Context.Result v loc a -> Result (Notes v loc) a$/;"	ft	signature:(Context.Result v loc a -> Result (Notes v loc) a)	line:56	language:Haskell
coordY	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data Coord = Coord {coordX, coordY :: Int}$/;"	c_a	cons:Coord.Coord	line:166	language:Haskell
copyDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^copyDir :: (FilePath -> Bool) -> FilePath -> FilePath -> IO ()$/;"	ft	signature:((FilePath -> Bool) -> FilePath -> FilePath -> IO ())	line:418	language:Haskell
copyFromArgHelper	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^copyFromArgHelper :: (MonadState KillRing m, Save s)$/;"	ft	signature:((MonadState KillRing m, Save s) => KillHelper -> Command m (ArgMode s) s)	line:70	language:Haskell
copyFromGit	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^copyFromGit :: MonadIO m => FilePath -> FilePath -> m ()$/;"	ft	signature:(MonadIO m => FilePath -> FilePath -> m ())	line:432	language:Haskell
copyPatch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^copyPatch :: InputPattern$/;"	ft	signature:(InputPattern)	line:532	language:Haskell
countHQ	./parser-typechecker/src/Unison/TermPrinter.hs	/^countHQ :: HQ.HashQualified -> PrintAnnotation$/;"	ft	signature:(HQ.HashQualified -> PrintAnnotation)	line:816	language:Haskell
countName	./parser-typechecker/src/Unison/TermPrinter.hs	/^countName :: Name -> PrintAnnotation$/;"	ft	signature:(Name -> PrintAnnotation)	line:819	language:Haskell
countPatternUsages	./parser-typechecker/src/Unison/TermPrinter.hs	/^countPatternUsages :: PrettyPrintEnv -> Pattern loc -> PrintAnnotation$/;"	ft	signature:(PrettyPrintEnv -> Pattern loc -> PrintAnnotation)	line:796	language:Haskell
countTypeUsages	./parser-typechecker/src/Unison/TermPrinter.hs	/^countTypeUsages :: (Var v, Ord v) => PrettyPrintEnv -> Type v a -> PrintAnnotation$/;"	ft	signature:((Var v, Ord v) => PrettyPrintEnv -> Type v a -> PrintAnnotation)	line:793	language:Haskell
cr	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^cr,crlf :: String$/;"	ft	signature:(String)	line:55	language:Haskell
cr	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^cr = "\\r"$/;"	fi	line:57	language:Haskell
cr	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                        nl, cr :: TermOutput,$/;"	c_a	cons:Actions.Actions	line:37	language:Haskell
cr	./yaks/haskeline/tests/Unit.hs	/^cr :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:273	language:Haskell
crash	./yaks/easytest/src/EasyTest.hs	/^crash :: HasCallStack => String -> Test a$/;"	ft	signature:(HasCallStack => String -> Test a)	line:349	language:Haskell
createPullRequest	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^createPullRequest :: InputPattern$/;"	ft	signature:(InputPattern)	line:701	language:Haskell
crlf	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^cr,crlf :: String$/;"	ft	signature:(String)	line:55	language:Haskell
crlf	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^crlf = "\\r\\n"$/;"	fi	line:56	language:Haskell
crlf	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^crlf :: String$/;"	ft	signature:(String)	line:346	language:Haskell
ctorTypeText	./unison-core/src/Unison/Referent.hs	/^ctorTypeText :: CT.ConstructorType -> Text$/;"	ft	signature:(CT.ConstructorType -> Text)	line:56	language:Haskell
ctrlChar	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^simpleChar, metaChar, ctrlChar :: Char -> Key$/;"	ft	signature:(Char -> Key)	line:53	language:Haskell
ctrlChar	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^ctrlChar = simpleChar . setControlBits$/;"	fi	line:57	language:Haskell
ctrlKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^ctrlKey :: Key -> Key$/;"	ft	signature:(Key -> Key)	line:50	language:Haskell
ctx	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Env v loc = Env { freshId :: Word64, ctx :: Context v loc }$/;"	c_a	cons:Env.Env	line:123	language:Haskell
currentHash	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  = One { currentHash :: RawHash h$/;"	c_a	cons:Causal.One	line:61	language:Haskell
currentHash	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | Cons { currentHash :: RawHash h$/;"	c_a	cons:Causal.Cons	line:64	language:Haskell
currentHash	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  | Merge { currentHash :: RawHash h$/;"	c_a	cons:Causal.Merge	line:69	language:Haskell
currentNames	./unison-core/src/Unison/Names3.hs	/^data Names = Names { currentNames :: Names0, oldNames :: Names0 } deriving Show$/;"	c_a	cons:Names.Names	line:28	language:Haskell
currentPath	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^currentPath :: Getter (LoopState m v) Path.Absolute$/;"	ft	signature:(Getter (LoopState m v) Path.Absolute)	line:172	language:Haskell
currentPath	./parser-typechecker/src/Unison/Codebase/Path.hs	/^currentPath :: Path'$/;"	ft	signature:(Path')	line:40	language:Haskell
currentPathNames0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^currentPathNames0 :: Functor m => Action' m v Names0$/;"	ft	signature:(Functor m => Action' m v Names0)	line:2495	language:Haskell
currentScope	./yaks/easytest/src/EasyTest.hs	/^currentScope :: Test String$/;"	ft	signature:(Test String)	line:327	language:Haskell
customBindings	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     customBindings :: Map.Map Key [Key],$/;"	c_a	cons:Prefs.Prefs	line:48	language:Haskell
customFailure	./parser-typechecker/src/Unison/TermParser.hs	/^customFailure :: P.MonadParsec e s m => e -> m a$/;"	ft	signature:(P.MonadParsec e s m => e -> m a)	line:709	language:Haskell
customKeySequences	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     customKeySequences :: [(Maybe String, String,Key)]$/;"	c_a	cons:Prefs.Prefs	line:50	language:Haskell
cyan	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
cyan	./parser-typechecker/src/Unison/Util/ColorText.hs	/^cyan = style Cyan$/;"	fi	line:31	language:Haskell
cyan	./parser-typechecker/src/Unison/Util/Pretty.hs	/^cyan = map CT.cyan$/;"	fi	line:674	language:Haskell
cycle	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | UnguardedLetRecCycle { cycle :: [v]$/;"	c_a	cons:TypeError.UnguardedLetRecCycle	line:64	language:Haskell
cycle	./unison-core/src/Unison/ABT.hs	/^cycle :: Term f v () -> Term f v ()$/;"	ft	signature:(Term f v () -> Term f v ())	line:223	language:Haskell
cycle	./unison-core/src/Unison/ShortHash.hs	/^  | ShortHash { prefix :: Text, cycle :: Maybe Text, cid :: Maybe Text }$/;"	c_a	cons:ShortHash.ShortHash	line:14	language:Haskell
cycle'	./unison-core/src/Unison/ABT.hs	/^cycle' :: a -> Term f v a -> Term f v a$/;"	ft	signature:(a -> Term f v a -> Term f v a)	line:226	language:Haskell
cycleLocs	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                         , cycleLocs :: [loc]$/;"	c_a	cons:TypeError.UnguardedLetRecCycle	line:65	language:Haskell
cycler	./unison-core/src/Unison/ABT.hs	/^cycler :: (Functor f, Foldable f, Var v) => [v] -> Term f (V v) () -> Term f (V v) ()$/;"	ft	signature:((Functor f, Foldable f, Var v) => [v] -> Term f (V v) () -> Term f (V v) ())	line:232	language:Haskell
cycler'	./unison-core/src/Unison/ABT.hs	/^cycler' :: (Functor f, Foldable f, Var v) => a -> [v] -> Term f (V v) a -> Term f (V v) a$/;"	ft	signature:((Functor f, Foldable f, Var v) => a -> [v] -> Term f (V v) a -> Term f (V v) a)	line:229	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  cyclicEq h1 h2 (FormClosure hash1 _ vs1) (FormClosure hash2 _ vs2) =$/;"	fi	instance:(CyclicEq e, CyclicEq cont) => CyclicEq (UnderapplyStrategy e cont)	line:994	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  cyclicEq h1 h2 (Req r1 c1 vs1 k1) (Req r2 c2 vs2 k2) =$/;"	fi	instance:(CyclicEq e, CyclicEq cont) => CyclicEq (Req e cont)	line:1003	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  cyclicEq _ _ (I x) (I y) = pure (x == y)$/;"	fi	instance:(CyclicEq e, CyclicEq cont) => CyclicEq (Value e cont)	line:1011	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  cyclicEq _ _ (ExternalFunction r _) (ExternalFunction r2 _) = pure (r == r2)$/;"	fi	instance:CyclicEq ExternalFunction	line:803	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  cyclicEq h1 h2 k1 k2 = do$/;"	fi	instance:CyclicEq Continuation	line:809	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^  cyclicEq :: CT.CycleTable Int Int -> CT.CycleTable Int Int -> a -> a -> IO Bool$/;"	ft	signature:(CT.CycleTable Int Int -> CT.CycleTable Int Int -> a -> a -> IO Bool)	class:CyclicEq	line:26	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^  cyclicEq h1 h2 (x:xs) (y:ys) = bothEq h1 h2 x y xs ys$/;"	fi	instance:CyclicEq a => CyclicEq [a]	line:42	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^  cyclicEq h1 h2 xs ys =$/;"	fi	instance:CyclicEq a => CyclicEq (S-Seq a)	line:47	language:Haskell
cyclicEq	./parser-typechecker/src/Unison/Util/CyclicEq.hs	/^  cyclicEq h1 h2 xs ys =$/;"	fi	instance:CyclicEq a => CyclicEq (Vector a)	line:52	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  cyclicOrd h1 h2 (FormClosure hash1 _ vs1) (FormClosure hash2 _ vs2) =$/;"	fi	instance:(CyclicOrd e, CyclicOrd cont) => CyclicOrd (UnderapplyStrategy e cont)	line:1071	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  cyclicOrd h1 h2 (Req r1 c1 vs1 k1) (Req r2 c2 vs2 k2) = case compare r1 r2 of$/;"	fi	instance:(CyclicOrd e, CyclicOrd cont) => CyclicOrd (Req e cont)	line:1079	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  cyclicOrd _ _ (I x) (I y) = pure (x `compare` y)$/;"	fi	instance:(CyclicOrd e, CyclicOrd cont) => CyclicOrd (Value e cont)	line:1091	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  cyclicOrd _ _ (ExternalFunction r _) (ExternalFunction r2 _) = pure (r `compare` r2)$/;"	fi	instance:CyclicOrd ExternalFunction	line:806	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  cyclicOrd h1 h2 k1 k2 = do$/;"	fi	instance:CyclicOrd Continuation	line:827	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^  cyclicOrd :: CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Ordering$/;"	ft	signature:(CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Ordering)	class:CyclicOrd	line:20	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^  cyclicOrd h1 h2 (x:xs) (y:ys) = bothOrd h1 h2 x y xs ys$/;"	fi	instance:CyclicOrd a => CyclicOrd [a]	line:37	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^  cyclicOrd h1 h2 xs ys = cyclicOrd h1 h2 (toList xs) (toList ys)$/;"	fi	instance:CyclicOrd a => CyclicOrd (S-Seq a)	line:43	language:Haskell
cyclicOrd	./parser-typechecker/src/Unison/Util/CyclicOrd.hs	/^  cyclicOrd h1 h2 xs ys = go 0 h1 h2 xs ys$/;"	fi	instance:CyclicOrd a => CyclicOrd (Vector a)	line:46	language:Haskell
d1	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^d1 Doc.++ d2 =$/;"	fi	line:160	language:Haskell
d1	./parser-typechecker/src/Unison/Util/Star3.hs	/^          , d1 :: Relation fact d1$/;"	c_a	cons:Star3.Star3	line:16	language:Haskell
d1	./unison-core/src/Unison/Util/Relation3.hs	/^  { d1 :: Map a (Relation b c)$/;"	c_a	cons:Relation3.Relation3	line:16	language:Haskell
d1	./unison-core/src/Unison/Util/Relation4.hs	/^  { d1 :: Map a (Relation3 b c d)$/;"	c_a	cons:Relation4.Relation4	line:20	language:Haskell
d12	./unison-core/src/Unison/Util/Relation4.hs	/^d12 :: (Ord a, Ord b) => Relation4 a b c d -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation4 a b c d -> Relation a b)	line:66	language:Haskell
d12s	./parser-typechecker/src/Unison/Util/Star3.hs	/^d12s :: (Ord fact, Ord d1, Ord d2)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2) => Star3 fact d1 d2 d3 -> [(fact, d1, d2)])	line:57	language:Haskell
d12s	./unison-core/src/Unison/Util/Relation4.hs	/^d12s :: (Ord a, Ord b) => Relation4 a b c d -> [(a,b)]$/;"	ft	signature:((Ord a, Ord b) => Relation4 a b c d -> [(a, b)])	line:73	language:Haskell
d13s	./parser-typechecker/src/Unison/Util/Star3.hs	/^d13s :: (Ord fact, Ord d1, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d1, d3)])	line:64	language:Haskell
d1s	./unison-core/src/Unison/Util/Relation3.hs	/^d1s :: Relation3 a b c -> Set a$/;"	ft	signature:(Relation3 a b c -> Set a)	line:24	language:Haskell
d1set	./unison-core/src/Unison/Util/Relation4.hs	/^d1set :: Ord a => Relation4 a b c d -> Set a$/;"	ft	signature:(Ord a => Relation4 a b c d -> Set a)	line:63	language:Haskell
d2	./parser-typechecker/src/Unison/Util/Star3.hs	/^          , d2 :: Relation fact d2$/;"	c_a	cons:Star3.Star3	line:17	language:Haskell
d2	./unison-core/src/Unison/Util/Relation3.hs	/^  , d2 :: Map b (Relation a c)$/;"	c_a	cons:Relation3.Relation3	line:17	language:Haskell
d2	./unison-core/src/Unison/Util/Relation4.hs	/^  , d2 :: Map b (Relation3 a c d)$/;"	c_a	cons:Relation4.Relation4	line:21	language:Haskell
d23s	./parser-typechecker/src/Unison/Util/Star3.hs	/^d23s :: (Ord fact, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d2, d3)])	line:43	language:Haskell
d23s'	./parser-typechecker/src/Unison/Util/Star3.hs	/^d23s' :: (Ord fact, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(d2, d3)])	line:50	language:Haskell
d2s	./unison-core/src/Unison/Util/Relation3.hs	/^d2s :: Relation3 a b c -> Set b$/;"	ft	signature:(Relation3 a b c -> Set b)	line:27	language:Haskell
d3	./parser-typechecker/src/Unison/Util/Star3.hs	/^          , d3 :: Relation fact d3 } deriving (Eq,Ord,Show)$/;"	c_a	cons:Star3.Star3	line:18	language:Haskell
d3	./unison-core/src/Unison/Util/Relation3.hs	/^  , d3 :: Map c (Relation a b)$/;"	c_a	cons:Relation3.Relation3	line:18	language:Haskell
d3	./unison-core/src/Unison/Util/Relation4.hs	/^  , d3 :: Map c (Relation3 a b d)$/;"	c_a	cons:Relation4.Relation4	line:22	language:Haskell
d34	./unison-core/src/Unison/Util/Relation4.hs	/^d34 :: (Ord c, Ord d) => Relation4 a b c d -> Relation c d$/;"	ft	signature:((Ord c, Ord d) => Relation4 a b c d -> Relation c d)	line:69	language:Haskell
d3s	./unison-core/src/Unison/Util/Relation3.hs	/^d3s :: Relation3 a b c -> Set c$/;"	ft	signature:(Relation3 a b c -> Set c)	line:30	language:Haskell
d4	./unison-core/src/Unison/Util/Relation4.hs	/^  , d4 :: Map d (Relation3 a b c)$/;"	c_a	cons:Relation4.Relation4	line:23	language:Haskell
dashed	./parser-typechecker/src/Unison/Util/Pretty.hs	/^dashed = prefixed "- " "  "$/;"	fi	line:403	language:Haskell
dataConstructor	./unison-core/src/Unison/LabeledDependency.hs	/^dataConstructor :: Reference -> Int -> LabeledDependency$/;"	ft	signature:(Reference -> Int -> LabeledDependency)	line:18	language:Haskell
dataConstructor	./unison-core/src/Unison/LabeledDependency.hs	/^dataConstructor r cid = X . Right $ Con r cid Data$/;"	fi	line:26	language:Haskell
dataConstructorTerms	./unison-core/src/Unison/DataDeclaration.hs	/^dataConstructorTerms = constructorTerms Term.hashConstructor Term.constructor$/;"	fi	line:162	language:Haskell
dataDeclToNames	./unison-core/src/Unison/DataDeclaration.hs	/^dataDeclToNames :: Var v => v -> Reference -> DataDeclaration' v a -> Names0$/;"	ft	signature:(Var v => v -> Reference -> DataDeclaration' v a -> Names0)	line:226	language:Haskell
dataDeclToNames'	./unison-core/src/Unison/DataDeclaration.hs	/^dataDeclToNames' :: Var v => (v, (Reference, DataDeclaration' v a)) -> Names0$/;"	ft	signature:(Var v => (v, (Reference, DataDeclaration' v a)) -> Names0)	line:232	language:Haskell
dataDeclaration	./parser-typechecker/src/Unison/FileParser.hs	/^dataDeclaration mod = do$/;"	fi	line:201	language:Haskell
dataDeclarations	./parser-typechecker/src/Unison/UnisonFile.hs	/^  dataDeclarations   :: Map v (Reference, DataDeclaration' v a),$/;"	c_a	cons:UnisonFile.UnisonFile	line:42	language:Haskell
dataDeclarations'	./parser-typechecker/src/Unison/UnisonFile.hs	/^    dataDeclarations'   :: Map v (Reference, DataDeclaration' v a),$/;"	c_a	cons:TypecheckedUnisonFile.TypecheckedUnisonFile	line:82	language:Haskell
dataDecls	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  dataDecls :: DataDeclarations v loc, -- Data declarations in scope$/;"	c_a	cons:MEnv.MEnv	line:319	language:Haskell
dataDecls	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^             , dataDecls :: Map Reference (DataDeclaration v a)$/;"	c_a	cons:TypeLookup.TypeLookup	line:19	language:Haskell
datas	./parser-typechecker/src/Unison/UnisonFile.hs	/^  { datas   :: Map v (Reference, DataDeclaration' v a)$/;"	c_a	cons:Env.Env	line:255	language:Haskell
deannotate	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^deannotate :: AnnotatedText a -> AnnotatedText b$/;"	ft	signature:(AnnotatedText a -> AnnotatedText b)	line:88	language:Haskell
debug	./parser-typechecker/src/Unison/Parser.hs	/^debug :: Bool$/;"	ft	signature:(Bool)	line:43	language:Haskell
debug	./parser-typechecker/src/Unison/Util/Logger.hs	/^error, warn, info, debug, trace :: Logger -> String -> IO ()$/;"	ft	signature:(Logger -> String -> IO ())	line:81	language:Haskell
debug	./parser-typechecker/src/Unison/Util/Logger.hs	/^debug l = logAt l debugLevel$/;"	fi	line:85	language:Haskell
debug'	./parser-typechecker/src/Unison/Util/Logger.hs	/^error', warn', info', debug', trace' :: Logger -> IO String -> IO ()$/;"	ft	signature:(Logger -> IO String -> IO ())	line:88	language:Haskell
debug'	./parser-typechecker/src/Unison/Util/Logger.hs	/^debug' l = logAt' l debugLevel$/;"	fi	line:92	language:Haskell
debugBranchHistory	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^debugBranchHistory :: InputPattern$/;"	ft	signature:(InputPattern)	line:1114	language:Haskell
debugEnabled	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^debugEnabled :: Bool$/;"	ft	signature:(Bool)	line:431	language:Haskell
debugLevel	./parser-typechecker/src/Unison/Util/Logger.hs	/^errorLevel, warnLevel, infoLevel, debugLevel, traceLevel :: Level$/;"	ft	signature:(Level)	line:95	language:Haskell
debugLex'	./parser-typechecker/src/Unison/Lexer.hs	/^debugLex' :: String -> String$/;"	ft	signature:(String -> String)	line:767	language:Haskell
debugLex''	./parser-typechecker/src/Unison/Lexer.hs	/^debugLex'' :: [Token Lexeme] -> String$/;"	ft	signature:([Token Lexeme] -> String)	line:764	language:Haskell
debugLex'''	./parser-typechecker/src/Unison/Lexer.hs	/^debugLex''' :: String -> String -> String$/;"	ft	signature:(String -> String -> String)	line:770	language:Haskell
debugNoteLoc	./unison-core/src/Unison/Settings.hs	/^debugNoteLoc,debugNoteSummary,debugRevealForalls :: Bool$/;"	ft	signature:(Bool)	line:3	language:Haskell
debugNoteSummary	./unison-core/src/Unison/Settings.hs	/^debugNoteLoc,debugNoteSummary,debugRevealForalls :: Bool$/;"	ft	signature:(Bool)	line:3	language:Haskell
debugNoteSummary	./unison-core/src/Unison/Settings.hs	/^debugNoteSummary = False$/;"	fi	line:5	language:Haskell
debugNumberedArgs	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^debugNumberedArgs :: InputPattern$/;"	ft	signature:(InputPattern)	line:1109	language:Haskell
debugPaths	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^debugPaths :: Branch m -> Set (Path, Hash)$/;"	ft	signature:(Branch m -> Set (Path, Hash))	line:424	language:Haskell
debugPatternsEnabled	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^debugPatternsEnabled :: Bool$/;"	ft	signature:(Bool)	line:434	language:Haskell
debugRevealForalls	./unison-core/src/Unison/Settings.hs	/^debugNoteLoc,debugNoteSummary,debugRevealForalls :: Bool$/;"	ft	signature:(Bool)	line:3	language:Haskell
debugRevealForalls	./unison-core/src/Unison/Settings.hs	/^debugRevealForalls = False$/;"	fi	line:6	language:Haskell
declDependencies	./unison-core/src/Unison/DataDeclaration.hs	/^declDependencies :: Ord v => Decl v a -> Set Reference$/;"	ft	signature:(Ord v => Decl v a -> Set Reference)	line:63	language:Haskell
declDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termDir, declDir :: CodebasePath -> Reference.Id -> FilePath$/;"	ft	signature:(CodebasePath -> Reference.Id -> FilePath)	line:193	language:Haskell
declDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^declDir root r = typesDir root <\/> componentIdToString r$/;"	fi	line:195	language:Haskell
declOrBuiltin	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^declOrBuiltin :: Reference -> Action m i v (Maybe (DD.DeclOrBuiltin v Ann))$/;"	ft	signature:(Reference -> Action m i v (Maybe (DD.DeclOrBuiltin v Ann)))	line:2606	language:Haskell
declPath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termPath, typePath, declPath :: CodebasePath -> Reference.Id -> FilePath$/;"	ft	signature:(CodebasePath -> Reference.Id -> FilePath)	line:260	language:Haskell
declPath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^declPath path r = declDir path r <\/> "compiled.ub"$/;"	fi	line:263	language:Haskell
declaration	./parser-typechecker/src/Unison/FileParser.hs	/^declaration :: Var v$/;"	ft	signature:(Var v => P v (Either (v, DataDeclaration' v Ann, Accessors v) (v, EffectDeclaration' v Ann)))	line:189	language:Haskell
declarationPPE	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^declarationPPE :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnv$/;"	ft	signature:(PrettyPrintEnvDecl -> Reference -> PrettyPrintEnv)	line:69	language:Haskell
declarations	./parser-typechecker/src/Unison/FileParser.hs	/^declarations :: Var v => P v$/;"	ft	signature:(Var v => P v (Map v (DataDeclaration' v Ann), Map v (EffectDeclaration' v Ann), Accessors v))	line:152	language:Haskell
declsToTypeLookup	./parser-typechecker/src/Unison/UnisonFile.hs	/^declsToTypeLookup :: Var v => UnisonFile v a -> TL.TypeLookup v a$/;"	ft	signature:(Var v => UnisonFile v a -> TL.TypeLookup v a)	line:181	language:Haskell
decodeFileName	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^decodeFileName :: FilePath -> String$/;"	ft	signature:(FilePath -> String)	line:216	language:Haskell
decodeResult	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^decodeResult source (Result notes Nothing) =$/;"	fi	line:109	language:Haskell
decompile	./parser-typechecker/src/Unison/Runtime/IR.hs	/^decompile :: (External e, External cont) => Value e cont -> IO (Term Symbol)$/;"	ft	signature:((External e, External cont) => Value e cont -> IO (Term Symbol))	line:594	language:Haskell
decompileExternal	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  decompileExternal :: e -> IO (Term Symbol)$/;"	ft	signature:(e -> IO (Term Symbol))	class:External	line:707	language:Haskell
decompileExternal	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  decompileExternal k = runDS $ Term.lam() paramName <$> go [paramName] k$/;"	fi	instance:External Continuation	line:69	language:Haskell
decompileExternal	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  decompileExternal (ExternalFunction r _) = pure $ Term.ref () r$/;"	fi	instance:External ExternalFunction	line:103	language:Haskell
decompileIR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^decompileIR stack = \\case$/;"	fi	line:711	language:Haskell
decompileImpl	./parser-typechecker/src/Unison/Runtime/IR.hs	/^decompileImpl ::$/;"	ft	signature:((External e, External cont) => Value e cont -> DS (Term Symbol))	line:597	language:Haskell
decompileUnderapplied	./parser-typechecker/src/Unison/Runtime/IR.hs	/^decompileUnderapplied :: (External e, External cont) => UnderapplyStrategy e cont -> DS (Term Symbol)$/;"	ft	signature:((External e, External cont) => UnderapplyStrategy e cont -> DS (Term Symbol))	line:161	language:Haskell
decrement	./parser-typechecker/src/Unison/Util/Logger.hs	/^decrement :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:108	language:Haskell
decrementFrees	./parser-typechecker/src/Unison/Runtime/IR.hs	/^decrementFrees :: Set Int -> Set Int$/;"	ft	signature:(Set Int -> Set Int)	line:856	language:Haskell
decrementFreesBy	./parser-typechecker/src/Unison/Runtime/IR.hs	/^decrementFreesBy :: Int -> Set Int -> Set Int$/;"	ft	signature:(Int -> Set Int -> Set Int)	line:852	language:Haskell
deepEdits	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , deepEdits :: Map Name EditHash$/;"	c_a	cons:Branch0.Branch0	line:173	language:Haskell
deepEdits'	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deepEdits' :: Branch0 m -> Map Name (EditHash, m Patch)$/;"	ft	signature:(Branch0 m -> Map Name (EditHash, m Patch))	line:333	language:Haskell
deepPaths	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , deepPaths :: Set Path$/;"	c_a	cons:Branch0.Branch0	line:172	language:Haskell
deepReferents	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deepReferents :: Branch0 m -> Set Referent$/;"	ft	signature:(Branch0 m -> Set Referent)	line:270	language:Haskell
deepTermMetadata	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , deepTermMetadata :: Metadata.R4 Referent Name$/;"	c_a	cons:Branch0.Branch0	line:170	language:Haskell
deepTerms	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , deepTerms :: Relation Referent Name$/;"	c_a	cons:Branch0.Branch0	line:168	language:Haskell
deepTypeMetadata	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , deepTypeMetadata :: Metadata.R4 Reference Name$/;"	c_a	cons:Branch0.Branch0	line:171	language:Haskell
deepTypeReferences	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deepTypeReferences :: Branch0 m -> Set Reference$/;"	ft	signature:(Branch0 m -> Set Reference)	line:273	language:Haskell
deepTypes	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , deepTypes :: Relation Reference Name$/;"	c_a	cons:Branch0.Branch0	line:169	language:Haskell
deepr4ToSlice	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^deepr4ToSlice :: Ord r$/;"	ft	signature:(Ord r => R.Relation r Name -> Metadata.R4 r Name -> NamespaceSlice r)	line:78	language:Haskell
defaultBehavior	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^defaultBehavior :: Behavior$/;"	ft	signature:(Behavior)	line:170	language:Haskell
defaultColors	./parser-typechecker/src/Unison/Util/ColorText.hs	/^defaultColors :: ST.Element -> Maybe Color$/;"	ft	signature:(ST.Element -> Maybe Color)	line:101	language:Haskell
defaultPatchNameSegment	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^defaultPatchNameSegment :: NameSegment$/;"	ft	signature:(NameSegment)	line:180	language:Haskell
defaultPrefs	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^defaultPrefs :: Prefs$/;"	ft	signature:(Prefs)	line:69	language:Haskell
defaultRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^defaultRunTerm :: IO RunTerm$/;"	ft	signature:(IO RunTerm)	line:20	language:Haskell
defaultSettings	./yaks/haskeline/System/Console/Haskeline.hs	/^defaultSettings :: MonadIO m => Settings m$/;"	ft	signature:(MonadIO m => Settings m)	line:107	language:Haskell
defaultWidth	./parser-typechecker/src/Unison/PrintError.hs	/^defaultWidth :: Pr.Width$/;"	ft	signature:(Pr.Width)	line:71	language:Haskell
definitionNameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^wordyNameSegment, definitionNameSegment :: String -> Either String NameSegment$/;"	ft	signature:(String -> Either String NameSegment)	line:137	language:Haskell
definitionNameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^definitionNameSegment s = wordyNameSegment s <> symbolyNameSegment s$/;"	fi	line:148	language:Haskell
definitions	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^    { definitions :: [(v, Type v loc, RedundantTypeAnnotation)] }$/;"	c_a	cons:TypeInfo.TopLevelComponent	line:87	language:Haskell
defns	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | DuplicateDefinitions { defns :: NonEmpty (v, [loc])$/;"	c_a	cons:TypeError.DuplicateDefinitions	line:77	language:Haskell
defsWithBlockedDependencies	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , defsWithBlockedDependencies :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:68	language:Haskell
delayQuote	./parser-typechecker/src/Unison/TermParser.hs	/^delayQuote :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:609	language:Haskell
delayTerm	./unison-core/src/Unison/DataDeclaration.hs	/^delayTerm :: Var v => a -> Term v a -> Term v a$/;"	ft	signature:(Var v => a -> Term v a -> Term v a)	line:578	language:Haskell
delayed	./parser-typechecker/src/Unison/TypeParser.hs	/^delayed :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:56	language:Haskell
delete	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^delete :: (Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n$/;"	ft	signature:((Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n)	line:45	language:Haskell
delete	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^delete :: InputPattern$/;"	ft	signature:(InputPattern)	line:382	language:Haskell
delete	./unison-core/src/Unison/Util/Relation.hs	/^delete :: (Ord a, Ord b) => a -> b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => a -> b -> Relation a b -> Relation a b)	line:203	language:Haskell
delete	./unison-core/src/Unison/Util/Relation3.hs	/^delete a b c Relation3{..} =$/;"	fi	line:97	language:Haskell
delete	./unison-core/src/Unison/Util/Relation4.hs	/^delete a b c d Relation4{..} =$/;"	fi	line:89	language:Haskell
deleteAll	./unison-core/src/Unison/Util/Relation3.hs	/^insertAll, deleteAll :: Foldable f => Ord a => Ord b => Ord c$/;"	ft	signature:(Foldable f => Ord a => Ord b => Ord c => f (a, b, c) -> Relation3 a b c -> Relation3 a b c)	line:85	language:Haskell
deleteAll	./unison-core/src/Unison/Util/Relation3.hs	/^deleteAll f r = foldl' (\\r x -> uncurry3 delete x r) r f$/;"	fi	line:88	language:Haskell
deleteAt	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deleteAt :: Applicative m => Path -> Branch m -> Branch m$/;"	ft	signature:(Applicative m => Path -> Branch m -> Branch m)	line:562	language:Haskell
deleteBranch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^deleteBranch :: InputPattern$/;"	ft	signature:(InputPattern)	line:504	language:Haskell
deleteChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^deleteChar :: CommandMode -> CommandMode$/;"	ft	signature:(CommandMode -> CommandMode)	line:295	language:Haskell
deleteComponent	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^deleteComponent :: Reference.Id -> Set Reference -> Set Reference$/;"	ft	signature:(Reference.Id -> Set Reference -> Set Reference)	line:752	language:Haskell
deleteD23	./parser-typechecker/src/Unison/Util/Star3.hs	/^deleteD23 :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3)	line:163	language:Haskell
deleteDom	./unison-core/src/Unison/Util/Relation.hs	/^deleteDom :: (Ord a, Ord b) => a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => a -> Relation a b -> Relation a b)	line:421	language:Haskell
deleteDomWhere	./unison-core/src/Unison/Util/Relation.hs	/^deleteDomWhere :: (Ord a, Ord b) => (a -> Bool) -> b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => (a -> Bool) -> b -> Relation a b -> Relation a b)	line:428	language:Haskell
deleteEdit	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^deleteEdit :: InputPattern$/;"	ft	signature:(InputPattern)	line:418	language:Haskell
deleteFact	./parser-typechecker/src/Unison/Util/Star3.hs	/^deleteFact :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => Set fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3)	line:171	language:Haskell
deleteFromDiff'	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^deleteFromDiff' :: InsertMode -> InsertMode -> ([Grapheme],InsertMode)$/;"	ft	signature:(InsertMode -> InsertMode -> ([Grapheme], InsertMode))	line:48	language:Haskell
deleteMatchingBrace	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^deleteMatchingBrace :: InsertMode -> ([Grapheme],InsertMode)$/;"	ft	signature:(InsertMode -> ([Grapheme], InsertMode))	line:325	language:Haskell
deleteNext	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^deleteNext, deletePrev :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:229	language:Haskell
deletePasswordChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^deletePasswordChar :: Password -> Password$/;"	ft	signature:(Password -> Password)	line:403	language:Haskell
deletePatch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deletePatch :: NameSegment -> Branch0 m -> Branch0 m$/;"	ft	signature:(NameSegment -> Branch0 m -> Branch0 m)	line:686	language:Haskell
deletePatch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^deletePatch :: InputPattern$/;"	ft	signature:(InputPattern)	line:516	language:Haskell
deletePrev	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^deleteNext, deletePrev :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:229	language:Haskell
deletePrev	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^deletePrev im@(IMode [] _) = im$/;"	fi	line:233	language:Haskell
deletePrimaryD1	./parser-typechecker/src/Unison/Util/Star3.hs	/^deletePrimaryD1 :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d1) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3)	line:115	language:Haskell
deleteRan	./unison-core/src/Unison/Util/Relation.hs	/^deleteRan :: (Ord a, Ord b) => b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => b -> Relation a b -> Relation a b)	line:418	language:Haskell
deleteRanWhere	./unison-core/src/Unison/Util/Relation.hs	/^deleteRanWhere :: (Ord a, Ord b) => (b -> Bool) -> a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => (b -> Bool) -> a -> Relation a b -> Relation a b)	line:424	language:Haskell
deleteTerm	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^deleteTerm :: InputPattern$/;"	ft	signature:(InputPattern)	line:394	language:Haskell
deleteTermName	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deleteTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m$/;"	ft	signature:(Referent -> NameSegment -> Branch0 m -> Branch0 m)	line:782	language:Haskell
deleteTerms0	./unison-core/src/Unison/Names3.hs	/^deleteTerms0 :: [Name] -> Names0 -> Names0$/;"	ft	signature:([Name] -> Names0 -> Names0)	line:239	language:Haskell
deleteType	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^deleteType :: InputPattern$/;"	ft	signature:(InputPattern)	line:406	language:Haskell
deleteTypeName	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^deleteTypeName :: Reference -> NameSegment -> Branch0 m -> Branch0 m$/;"	ft	signature:(Reference -> NameSegment -> Branch0 m -> Branch0 m)	line:787	language:Haskell
deleteUnisonHandle	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^deleteUnisonHandle :: Text -> UIO ()$/;"	ft	signature:(Text -> UIO ())	line:149	language:Haskell
deletionCmd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^deletionCmd :: InputCmd (ArgMode CommandMode) CommandMode$/;"	ft	signature:(InputCmd (ArgMode CommandMode) CommandMode)	line:213	language:Haskell
deletionToInsertCmd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^deletionToInsertCmd :: InputCmd (ArgMode CommandMode) EitherMode$/;"	ft	signature:(InputCmd (ArgMode CommandMode) EitherMode)	line:221	language:Haskell
delimiters	./parser-typechecker/src/Unison/Lexer.hs	/^delimiters :: Set Char$/;"	ft	signature:(Set Char)	line:745	language:Haskell
delta	./parser-typechecker/src/Unison/Util/Pretty.hs	/^data Pretty s = Pretty { delta :: Delta, out :: F s (Pretty s) } deriving Eq$/;"	c_a	cons:Pretty.Pretty	line:125	language:Haskell
demoHideVarNumber	./unison-core/src/Unison/Settings.hs	/^demoHideVarNumber :: Bool$/;"	ft	signature:(Bool)	line:11	language:Haskell
dependencies	./parser-typechecker/src/Unison/UnisonFile.hs	/^dependencies :: (Monoid a, Var v) => UnisonFile v a -> Set Reference$/;"	ft	signature:((Monoid a, Var v) => UnisonFile v a -> Set Reference)	line:172	language:Haskell
dependencies	./unison-core/src/Unison/DataDeclaration.hs	/^dependencies :: Ord v => DataDeclaration' v a -> Set Reference$/;"	ft	signature:(Ord v => DataDeclaration' v a -> Set Reference)	line:208	language:Haskell
dependencies	./unison-core/src/Unison/Term.hs	/^dependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference$/;"	ft	signature:((Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference)	line:816	language:Haskell
dependencies	./unison-core/src/Unison/Type.hs	/^dependencies :: Ord v => Type v a -> Set Reference$/;"	ft	signature:(Ord v => Type v a -> Set Reference)	line:388	language:Haskell
dependencies'	./parser-typechecker/src/Unison/UnisonFile.hs	/^dependencies' ::$/;"	ft	signature:(forall v a. Var v => TypecheckedUnisonFile v a -> Relation Reference Reference)	line:148	language:Haskell
dependents	./parser-typechecker/src/Unison/Codebase.hs	/^dependents :: Functor m => Codebase m v a -> Reference -> m (Set Reference)$/;"	ft	signature:(Functor m => Codebase m v a -> Reference -> m (Set Reference))	line:253	language:Haskell
dependentsDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^dependentsDir :: CodebasePath -> Reference -> FilePath$/;"	ft	signature:(CodebasePath -> Reference -> FilePath)	line:202	language:Haskell
dependentsImpl	./parser-typechecker/src/Unison/Codebase.hs	/^           , dependentsImpl     :: Reference -> m (Set Reference.Id)$/;"	c_a	cons:Codebase.Codebase	line:60	language:Haskell
dequeue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^dequeue :: TQueue a -> STM a$/;"	ft	signature:(TQueue a -> STM a)	line:33	language:Haskell
dequeueN	./parser-typechecker/src/Unison/Util/TQueue.hs	/^dequeueN :: TQueue a -> Int -> STM [a]$/;"	ft	signature:(TQueue a -> Int -> STM [a])	line:47	language:Haskell
derivedBase32Hex	./unison-core/src/Unison/Reference.hs	/^derivedBase32Hex :: Text -> Pos -> Size -> Reference$/;"	ft	signature:(Text -> Pos -> Size -> Reference)	line:123	language:Haskell
derivedBase32Hex	./unison-core/src/Unison/Type.hs	/^derivedBase32Hex :: Ord v => Reference -> a -> Type v a$/;"	ft	signature:(Ord v => Reference -> a -> Type v a)	line:206	language:Haskell
derivedTerm	./unison-core/src/Unison/LabeledDependency.hs	/^derivedType, derivedTerm :: Id -> LabeledDependency$/;"	ft	signature:(Id -> LabeledDependency)	line:15	language:Haskell
derivedTerm	./unison-core/src/Unison/LabeledDependency.hs	/^derivedTerm = X . Right . Ref . DerivedId$/;"	fi	line:22	language:Haskell
derivedType	./unison-core/src/Unison/LabeledDependency.hs	/^derivedType, derivedTerm :: Id -> LabeledDependency$/;"	ft	signature:(Id -> LabeledDependency)	line:15	language:Haskell
derivedType	./unison-core/src/Unison/LabeledDependency.hs	/^derivedType = X . Left . DerivedId$/;"	fi	line:21	language:Haskell
describeStyle	./parser-typechecker/src/Unison/PrintError.hs	/^describeStyle :: Color -> Pretty ColorText$/;"	ft	signature:(Color -> Pretty ColorText)	line:113	language:Haskell
diff	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^diff :: Patch -> Patch -> PatchDiff$/;"	ft	signature:(Patch -> Patch -> PatchDiff)	line:41	language:Haskell
diff0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^diff0 :: Monad m => Branch0 m -> Branch0 m -> m BranchDiff$/;"	ft	signature:(Monad m => Branch0 m -> Branch0 m -> m BranchDiff)	line:798	language:Haskell
diff0	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^diff0 :: forall m. Monad m => Branch0 m -> Branch0 m -> m BranchDiff$/;"	ft	signature:(forall m. Monad m => Branch0 m -> Branch0 m -> m BranchDiff)	line:47	language:Haskell
diff0	./unison-core/src/Unison/Names3.hs	/^diff0 :: Names0 -> Names0 -> Diff$/;"	ft	signature:(Names0 -> Names0 -> Diff)	line:64	language:Haskell
diffHelper	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^diffHelper :: Monad m$/;"	ft	signature:(Monad m => Branch0 m -> Branch0 m -> Action' m v (PPE.PrettyPrintEnv, OBranchDiff.BranchDiffOutput v Ann))	line:2577	language:Haskell
diffNamespace	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^diffNamespace :: InputPattern$/;"	ft	signature:(InputPattern)	line:767	language:Haskell
difference	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^difference :: Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v$/;"	ft	signature:(Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v)	line:26	language:Haskell
difference	./parser-typechecker/src/Unison/Util/Star3.hs	/^difference a b = Star3 facts d1s d2s d3s$/;"	fi	line:36	language:Haskell
difference	./unison-core/src/Unison/Names2.hs	/^difference :: Ord n => Names' n -> Names' n -> Names' n$/;"	ft	signature:(Ord n => Names' n -> Names' n -> Names' n)	line:309	language:Haskell
difference	./unison-core/src/Unison/Util/Relation.hs	/^difference :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b)	line:43	language:Haskell
difference	./unison-core/src/Unison/Util/Relation3.hs	/^difference :: (Ord a, Ord b, Ord c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation3 a b c -> Relation3 a b c -> Relation3 a b c)	line:91	language:Haskell
directTTY	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^directTTY :: MaybeT IO RunTerm$/;"	ft	signature:(MaybeT IO RunTerm)	line:34	language:Haskell
direction	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^                              direction :: Direction}$/;"	c_a	cons:SearchMode.SearchMode	line:80	language:Haskell
directionName	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^directionName :: Direction -> String$/;"	ft	signature:(Direction -> String)	line:86	language:Haskell
disallowUpdates	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^disallowUpdates :: forall v. Var v => SlurpResult v -> SlurpResult v$/;"	ft	signature:(forall v. Var v => SlurpResult v -> SlurpResult v)	line:119	language:Haskell
discardTypes	./parser-typechecker/src/Unison/UnisonFile.hs	/^discardTypes :: TypecheckedUnisonFile v a -> UnisonFile v a$/;"	ft	signature:(TypecheckedUnisonFile v a -> UnisonFile v a)	line:175	language:Haskell
display	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^display :: InputPattern$/;"	ft	signature:(InputPattern)	line:265	language:Haskell
display	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^                        display  :: String,$/;"	c_a	cons:Completion.Completion	line:36	language:Haskell
displayDefinitions	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^displayDefinitions :: Var v => Ord a1 =>$/;"	ft	signature:(Var v => Ord a1 => Maybe FilePath -> PPE.PrettyPrintEnvDecl -> Map Reference.Reference (DisplayThing (DD.Decl v a1)) -> Map Reference.Reference (DisplayThing (Term v a1)) -> IO Pretty)	line:1032	language:Haskell
displayDefinitions'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^displayDefinitions' :: Var v => Ord a1$/;"	ft	signature:(Var v => Ord a1 => PPE.PrettyPrintEnvDecl -> Map Reference.Reference (DisplayThing (DD.Decl v a1)) -> Map Reference.Reference (DisplayThing (Term v a1)) -> Pretty)	line:975	language:Haskell
displayDoc	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^displayDoc :: forall v m a. (Var v, Monad m)$/;"	ft	signature:(forall v m a. (Var v, Monad m) => PPE.PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v a))) -> (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (Term v a))) -> (Reference -> m (Maybe (DD.Decl v a))) -> Term v a -> m Pretty)	line:43	language:Haskell
displayDoc	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^displayDoc pped terms typeOf evaluated types = go$/;"	fi	line:51	language:Haskell
displayRendered	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^displayRendered :: Maybe FilePath -> Pretty -> IO Pretty$/;"	ft	signature:(Maybe FilePath -> Pretty -> IO Pretty)	line:1009	language:Haskell
displayTerm	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^displayTerm :: (Var v, Monad m)$/;"	ft	signature:((Var v, Monad m) => PPE.PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v a))) -> (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (Term v a))) -> (Reference -> m (Maybe (DD.Decl v a))) -> Term v a -> m Pretty)	line:28	language:Haskell
displayTerm	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^displayTerm pped terms typeOf eval types tm = case tm of$/;"	fi	line:36	language:Haskell
displayTestResults	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^displayTestResults :: Bool -- whether to show the tip$/;"	ft	signature:(Bool -> PPE.PrettyPrintEnv -> [(Reference, Text)] -> [(Reference, Text)] -> Pretty)	line:1070	language:Haskell
displayTo	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^displayTo :: InputPattern$/;"	ft	signature:(InputPattern)	line:272	language:Haskell
distinct	./unison-core/src/Unison/ABT.hs	/^distinct :: forall f v h a proxy . (Functor f, Hashable1 f, Eq v, Show v, Var v, Ord h, Accumulate h)$/;"	ft	signature:(forall f v h a proxy . (Functor f, Hashable1 f, Eq v, Show v, Var v, Ord h, Accumulate h) => proxy h -> [Term f v a] -> [Term f v a])	line:683	language:Haskell
doBefore	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^doBefore :: Monad m => Command m s t -> KeyCommand m t u -> KeyCommand m s u$/;"	ft	signature:(Monad m => Command m s t -> KeyCommand m t u -> KeyCommand m s u)	line:165	language:Haskell
doDisplay	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^doDisplay :: Var v => OutputLocation -> Names -> Referent -> Action' m v ()$/;"	ft	signature:(Var v => OutputLocation -> Names -> Referent -> Action' m v ())	line:1574	language:Haskell
doSearch	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^doSearch :: MonadState HistLog m => Bool -> SearchMode -> m (Either Effect SearchMode)$/;"	ft	signature:(MonadState HistLog m => Bool -> SearchMode -> m (Either Effect SearchMode))	line:138	language:Haskell
doShowTodoOutput	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^doShowTodoOutput :: Monad m => Patch -> Path.Absolute -> Action' m v ()$/;"	ft	signature:(Monad m => Patch -> Path.Absolute -> Action' m v ())	line:1659	language:Haskell
doSlurpAdds	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^doSlurpAdds :: forall m v. (Monad m, Var v)$/;"	ft	signature:(forall m v. (Monad m, Var v) => SlurpComponent v -> UF.TypecheckedUnisonFile v Ann -> (Branch0 m -> Branch0 m))	line:2244	language:Haskell
doSlurpUpdates	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^doSlurpUpdates :: Monad m$/;"	ft	signature:(Monad m => Map Name (Reference, Reference) -> Map Name (Reference, Reference) -> [(Name, Referent)] -> (Branch0 m -> Branch0 m))	line:2278	language:Haskell
docBlobId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
docBlock	./parser-typechecker/src/Unison/TermParser.hs	/^docBlock :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:319	language:Haskell
docContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^  , docContext :: DocLiteralContext$/;"	c_a	cons:AmbientContext.AmbientContext	line:68	language:Haskell
docEvaluateId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
docJoinId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
docLinkId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
docNormalize	./parser-typechecker/src/Unison/TermParser.hs	/^docNormalize :: (Ord v, Show v) => Term v a -> Term v a$/;"	ft	signature:((Ord v, Show v) => Term v a -> Term v a)	line:405	language:Haskell
docRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef :: Reference$/;"	ft	signature:(Reference)	line:409	language:Haskell
docSignatureId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
docSourceId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
docs	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^docs :: InputPattern$/;"	ft	signature:(InputPattern)	line:280	language:Haskell
doesDirectoryExist	./yaks/haskeline/System/Console/Haskeline/Directory.hsc	/^doesDirectoryExist :: FilePath -> IO Bool$/;"	ft	signature:(FilePath -> IO Bool)	line:51	language:Haskell
dom	./unison-core/src/Unison/Util/Relation.hs	/^dom :: Relation a b -> Set a$/;"	ft	signature:(Relation a b -> Set a)	line:267	language:Haskell
domain	./unison-core/src/Unison/Util/Relation.hs	/^data Relation a b  = Relation { domain ::  M.Map a (Set b)$/;"	c_a	cons:Relation.Relation	line:33	language:Haskell
done	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^done :: Value -> IO Result$/;"	ft	signature:(Value -> IO Result)	line:216	language:Haskell
done	./yaks/easytest/src/EasyTest.hs	/^done :: Test a$/;"	ft	signature:(Test a)	line:341	language:Haskell
dotConcat	./parser-typechecker/src/Unison/TermPrinter.hs	/^dotConcat :: [Text] -> Text$/;"	ft	signature:([Text] -> Text)	line:833	language:Haskell
double	./yaks/easytest/src/EasyTest.hs	/^double :: Test Double$/;"	ft	signature:(Test Double)	line:229	language:Haskell
double'	./yaks/easytest/src/EasyTest.hs	/^double' :: Double -> Double -> Test Double$/;"	ft	signature:(Double -> Double -> Test Double)	line:248	language:Haskell
drawEffect	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^drawEffect :: (Term m, MonadReader Prefs m)$/;"	ft	signature:((Term m, MonadReader Prefs m) => Prefix -> LineChars -> Effect -> m LineChars)	line:77	language:Haskell
drawLine	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^drawLine, clearLine :: Term m => LineChars -> m ()$/;"	ft	signature:(Term m => LineChars -> m ())	line:28	language:Haskell
drawLineDiff	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    drawLineDiff = drawLineDiff'$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	line:40	language:Haskell
drawLineDiff	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    drawLineDiff xs ys = runActionT $ drawLineDiffT xs ys$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:354	language:Haskell
drawLineDiff	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    drawLineDiff (xs1,ys1) (xs2,ys2) = let$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:350	language:Haskell
drawLineDiff	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    drawLineDiff :: LineChars -> LineChars -> m ()$/;"	ft	signature:(LineChars -> LineChars -> m ())	class:Term	line:24	language:Haskell
drawLineDiff'	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^drawLineDiff' :: LineChars -> LineChars -> DumbTermM ()$/;"	ft	signature:(LineChars -> LineChars -> DumbTermM ())	line:73	language:Haskell
drawLineDiffT	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^drawLineDiffT :: LineChars -> LineChars -> ActionM ()$/;"	ft	signature:(LineChars -> LineChars -> ActionM ())	line:296	language:Haskell
drawLineDiffWin	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^drawLineDiffWin :: LineChars -> LineChars -> DrawM ()$/;"	ft	signature:(LineChars -> LineChars -> DrawM ())	line:299	language:Haskell
drawReposition	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^drawReposition :: (Term n, MonadState Layout m)$/;"	ft	signature:((Term n, MonadState Layout m) => (forall a . m a -> n a) -> TermOps -> LineChars -> n ())	line:69	language:Haskell
drop	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  drop n (AnnotatedText at) = case at of$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:70	language:Haskell
drop	./parser-typechecker/src/Unison/Util/Bytes.hs	/^drop :: Int -> Bytes -> Bytes$/;"	ft	signature:(Int -> Bytes -> Bytes)	line:58	language:Haskell
dropWhile	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  dropWhile f (AnnotatedText at) = case at of$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:59	language:Haskell
dumbTests	./yaks/haskeline/tests/Unit.hs	/^dumbTests i = "dumb term" ~:$/;"	fi	line:237	language:Haskell
duplicateDefinitions	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^duplicateDefinitions :: ErrorExtractor v loc (NonEmpty (v, [loc]))$/;"	ft	signature:(ErrorExtractor v loc (NonEmpty (v, [loc])))	line:227	language:Haskell
duplicateDefinitions	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^duplicateDefinitions :: Ex.ErrorExtractor v a (TypeError v a)$/;"	ft	signature:(Ex.ErrorExtractor v a (TypeError v a))	line:136	language:Haskell
duplicates	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , duplicates :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:50	language:Haskell
eH	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^                        , eH :: Handle$/;"	c_a	cons:ExternalHandle.ExternalHandle	line:34	language:Haskell
easyCombine	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^easyCombine comb _    _    Nothing l r = comb l r$/;"	fi	line:201	language:Haskell
edit	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^edit :: InputPattern$/;"	ft	signature:(InputPattern)	line:871	language:Haskell
editConflicts	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^  , editConflicts :: Patch$/;"	c_a	cons:TodoOutput.TodoOutput	line:32	language:Haskell
editFunctionResult	./unison-core/src/Unison/Type.hs	/^editFunctionResult f = go$/;"	fi	line:483	language:Haskell
editMode	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     editMode :: !EditMode,$/;"	c_a	cons:Prefs.Prefs	line:33	language:Haskell
editedPatchRemoved	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , editedPatchRemoved :: [Name]$/;"	c_a	cons:BranchAttentions.BranchAttentions	line:819	language:Haskell
editsDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^editsDir root = root <\/> "patches"$/;"	fi	line:191	language:Haskell
editsPath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^editsPath :: CodebasePath -> Hash.Hash -> FilePath$/;"	ft	signature:(CodebasePath -> Hash.Hash -> FilePath)	line:268	language:Haskell
effect	./parser-typechecker/src/Unison/TypeParser.hs	/^effect :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:71	language:Haskell
effect	./unison-core/src/Unison/Type.hs	/^effect :: Ord v => a -> [Type v a] -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> [Type v a] -> Type v a -> Type v a)	line:334	language:Haskell
effect	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^effect :: Effect -> CmdM m ()$/;"	ft	signature:(Effect -> CmdM m ())	line:138	language:Haskell
effect1	./unison-core/src/Unison/Type.hs	/^effect1 :: Ord v => a -> Type v a -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a -> Type v a -> Type v a)	line:343	language:Haskell
effectConstructor	./unison-core/src/Unison/LabeledDependency.hs	/^effectConstructor :: Reference -> Int -> LabeledDependency$/;"	ft	signature:(Reference -> Int -> LabeledDependency)	line:19	language:Haskell
effectConstructor	./unison-core/src/Unison/LabeledDependency.hs	/^effectConstructor r cid = X . Right $ Con r cid Effect$/;"	fi	line:27	language:Haskell
effectConstructorTerms	./unison-core/src/Unison/DataDeclaration.hs	/^effectConstructorTerms rid ed =$/;"	fi	line:169	language:Haskell
effectConstructorWrongArgCount	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^effectConstructorWrongArgCount = cause >>= \\case$/;"	fi	line:266	language:Haskell
effectDeclToNames	./unison-core/src/Unison/DataDeclaration.hs	/^effectDeclToNames :: Var v => v -> Reference -> EffectDeclaration' v a -> Names0$/;"	ft	signature:(Var v => v -> Reference -> EffectDeclaration' v a -> Names0)	line:229	language:Haskell
effectDeclToNames'	./unison-core/src/Unison/DataDeclaration.hs	/^effectDeclToNames' :: Var v => (v, (Reference, EffectDeclaration' v a)) -> Names0$/;"	ft	signature:(Var v => (v, (Reference, EffectDeclaration' v a)) -> Names0)	line:235	language:Haskell
effectDeclaration	./parser-typechecker/src/Unison/FileParser.hs	/^effectDeclaration mod = do$/;"	fi	line:245	language:Haskell
effectDeclarations	./parser-typechecker/src/Unison/UnisonFile.hs	/^  effectDeclarations :: Map v (Reference, EffectDeclaration' v a),$/;"	c_a	cons:UnisonFile.UnisonFile	line:43	language:Haskell
effectDeclarations'	./parser-typechecker/src/Unison/UnisonFile.hs	/^    effectDeclarations' :: Map v (Reference, EffectDeclaration' v a),$/;"	c_a	cons:TypecheckedUnisonFile.TypecheckedUnisonFile	line:83	language:Haskell
effectDecls	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  effectDecls :: EffectDeclarations v loc, -- Effect declarations in scope$/;"	c_a	cons:MEnv.MEnv	line:320	language:Haskell
effectDecls	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^             , effectDecls :: Map Reference (EffectDeclaration v a) }$/;"	c_a	cons:TypeLookup.TypeLookup	line:20	language:Haskell
effectList	./parser-typechecker/src/Unison/TypeParser.hs	/^effectList :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:77	language:Haskell
effectRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
effectRef	./unison-core/src/Unison/Type.hs	/^effectRef = Reference.Builtin "Effect"$/;"	fi	line:221	language:Haskell
effectType	./unison-core/src/Unison/Type.hs	/^effectType :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:252	language:Haskell
effectV	./unison-core/src/Unison/Type.hs	/^effectV :: Ord v => a -> (a, Type v a) -> (a, Type v a) -> Type v a$/;"	ft	signature:(Ord v => a -> (a, Type v a) -> (a, Type v a) -> Type v a)	line:355	language:Haskell
effects	./parser-typechecker/src/Unison/UnisonFile.hs	/^  , effects :: Map v (Reference, EffectDeclaration' v a)$/;"	c_a	cons:Env.Env	line:257	language:Haskell
effects	./unison-core/src/Unison/Type.hs	/^effects :: Ord v => a -> [Type v a] -> Type v a$/;"	ft	signature:(Ord v => a -> [Type v a] -> Type v a)	line:340	language:Haskell
ehIn	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^ehIn, ehOut :: Handles -> Handle$/;"	ft	signature:(Handles -> Handle)	line:55	language:Haskell
ehOut	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^ehIn, ehOut :: Handles -> Handle$/;"	ft	signature:(Handles -> Handle)	line:55	language:Haskell
ehOut	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^ehOut = eH . hOut$/;"	fi	line:57	language:Haskell
eitherHash	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioHash, eitherHash, ioModeHash :: R.Id$/;"	ft	signature:(R.Id)	line:63	language:Haskell
eitherHash	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherHash = R.unsafeId eitherReference$/;"	fi	line:65	language:Haskell
eitherLeftId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
eitherReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherReference = typeNamed "Either"$/;"	fi	line:72	language:Haskell
eitherRightId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
eitherRightId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherRightId = constructorNamed eitherReference "Either.Right"$/;"	fi	line:94	language:Haskell
elements	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^                 , elements :: !(UV.Vector a) }$/;"	c_a	cons:SparseVector.SparseVector	line:19	language:Haskell
elideFQN	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^elideFQN :: Imports -> HQ.HashQualified -> HQ.HashQualified$/;"	ft	signature:(Imports -> HQ.HashQualified -> HQ.HashQualified)	line:133	language:Haskell
emacsCommands	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^emacsCommands :: InputKeyCmd InsertMode (Maybe String)$/;"	ft	signature:(InputKeyCmd InsertMode (Maybe String))	line:18	language:Haskell
emitAsPlainTextTo	./unison-src/parser-tests/GenerateErrors.hs	/^emitAsPlainTextTo :: Var v => String -> Err v -> FilePath -> IO ()$/;"	ft	signature:(Var v => String -> Err v -> FilePath -> IO ())	line:29	language:Haskell
emojiNote	./parser-typechecker/src/Unison/CommandLine.hs	/^emojiNote :: (ListLike s Char, IsString s) => String -> P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => String -> P.Pretty s -> P.Pretty s)	line:100	language:Haskell
empty	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^empty :: Branch m$/;"	ft	signature:(Branch m)	line:585	language:Haskell
empty	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^empty :: Ord v => SlurpComponent v$/;"	ft	signature:(Ord v => SlurpComponent v)	line:23	language:Haskell
empty	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^empty :: Metadata$/;"	ft	signature:(Metadata)	line:56	language:Haskell
empty	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^empty :: Patch$/;"	ft	signature:(Patch)	line:58	language:Haskell
empty	./parser-typechecker/src/Unison/Codebase/Path.hs	/^empty :: Path$/;"	ft	signature:(Path)	line:317	language:Haskell
empty	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  empty = mzero$/;"	fi	instance:Alternative (SubseqExtractor' n)	line:335	language:Haskell
empty	./parser-typechecker/src/Unison/Util/Bytes.hs	/^empty :: Bytes$/;"	ft	signature:(Bytes)	line:24	language:Haskell
empty	./unison-core/src/Unison/Util/Relation.hs	/^empty   ::  Relation a b$/;"	ft	signature:(Relation a b)	line:55	language:Haskell
empty	./unison-core/src/Unison/Util/Relation3.hs	/^empty :: (Ord a, Ord b, Ord c) => Relation3 a b c$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation3 a b c)	line:71	language:Haskell
empty	./unison-core/src/Unison/Util/Relation4.hs	/^empty :: (Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d)	line:41	language:Haskell
empty	./yaks/easytest/src/EasyTest.hs	/^  empty = Test (pure Nothing)$/;"	fi	instance:Alternative Test	line:407	language:Haskell
empty0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^empty0 :: Branch0 m$/;"	ft	signature:(Branch0 m)	line:591	language:Haskell
emptyBlockTest	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  emptyBlockTest :: Test ()$/;"	ft	signature:(Test ())	line:94	language:Haskell
emptyCausal	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^emptyCausal :: Causal Identity Hash (Set Int64)$/;"	ft	signature:(Causal Identity Hash (Set Int64))	line:219	language:Haskell
emptyHistory	./yaks/haskeline/System/Console/Haskeline/History.hs	/^emptyHistory :: History$/;"	ft	signature:(History)	line:49	language:Haskell
emptyIM	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^emptyIM :: InsertMode$/;"	ft	signature:(InsertMode)	line:212	language:Haskell
emptyStack	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^emptyStack :: Stack a$/;"	ft	signature:(Stack a)	line:14	language:Haskell
emptyTreeMap	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^emptyTreeMap :: TreeMap a b$/;"	ft	signature:(TreeMap a b)	line:157	language:Haskell
emptyViState	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^emptyViState :: Monad m => ViState m$/;"	ft	signature:(Monad m => ViState m)	line:25	language:Haskell
emptyWatchTest	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  emptyWatchTest :: Test ()$/;"	ft	signature:(Test ())	line:76	language:Haskell
encodeDecode	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^encodeDecode :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:31	language:Haskell
encodeFileName	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^encodeFileName :: String -> FilePath$/;"	ft	signature:(String -> FilePath)	line:239	language:Haskell
end	./parser-typechecker/src/Unison/Lexer.hs	/^  end :: Pos$/;"	c_a	cons:Token.Token	line:74	language:Haskell
end	./parser-typechecker/src/Unison/Parser.hs	/^  | Ann { start :: L.Pos, end :: L.Pos }$/;"	c_a	cons:Ann.Ann	line:112	language:Haskell
end	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  | Ranged { get :: a, start :: Int, end :: Int }$/;"	c_a	cons:Ranged.Ranged	line:66	language:Haskell
end	./parser-typechecker/src/Unison/Util/Range.hs	/^data Range = Range { start :: Pos, end :: Pos } deriving (Eq, Ord, Show)$/;"	c_a	cons:Range.Range	line:18	language:Haskell
end	./yaks/haskeline/tests/Unit.hs	/^end :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:270	language:Haskell
enders	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^enders :: InputKeyCmd InsertMode (Maybe String)$/;"	ft	signature:(InputKeyCmd InsertMode (Maybe String))	line:24	language:Haskell
enqueue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^enqueue :: TQueue a -> a -> STM ()$/;"	ft	signature:(TQueue a -> a -> STM ())	line:62	language:Haskell
enqueueCount	./parser-typechecker/src/Unison/Util/TQueue.hs	/^enqueueCount :: TQueue a -> STM Word64$/;"	ft	signature:(TQueue a -> STM Word64)	line:53	language:Haskell
ensureGuardedCycle	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^ensureGuardedCycle :: Var v => [(v, Term v loc)] -> M v loc ()$/;"	ft	signature:(Var v => [(v, Term v loc)] -> M v loc ())	line:1233	language:Haskell
ensureSize	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^ensureSize :: Size -> Stack -> IO Stack$/;"	ft	signature:(Size -> Stack -> IO Stack)	line:197	language:Haskell
enterCommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^enterCommandMode, enterCommandModeRight :: InsertMode -> CommandMode$/;"	ft	signature:(InsertMode -> CommandMode)	line:316	language:Haskell
enterCommandModeRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^enterCommandMode, enterCommandModeRight :: InsertMode -> CommandMode$/;"	ft	signature:(InsertMode -> CommandMode)	line:316	language:Haskell
enterCommandModeRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^enterCommandModeRight (IMode xs (y:ys)) = CMode xs y ys$/;"	fi	line:321	language:Haskell
entryState	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^                    entryState :: InsertMode,$/;"	c_a	cons:SearchEntry.SearchEntry	line:401	language:Haskell
env	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  env :: Env v loc,                    -- The typechecking state$/;"	c_a	cons:MEnv.MEnv	line:317	language:Haskell
envLayout	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^envLayout :: IO (Maybe Layout)$/;"	ft	signature:(IO (Maybe Layout))	line:86	language:Haskell
environment	./yaks/haskeline/tests/RunTTY.hs	/^            , environment :: [(String,String)]$/;"	c_a	cons:Invocation.Invocation	line:30	language:Haskell
environmentFor	./parser-typechecker/src/Unison/UnisonFile.hs	/^environmentFor names dataDecls0 effectDecls0 = do$/;"	fi	line:281	language:Haskell
eofId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eofId = mkErrorType "io.ErrorType.EOF"$/;"	fi	line:115	language:Haskell
eofIfEmpty	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^eofIfEmpty :: (Monad m, Save s, Result s) => Command m s (Maybe String)$/;"	ft	signature:((Monad m, Save s, Result s) => Command m s (Maybe String))	line:79	language:Haskell
epochTimeId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
epochTimeId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^epochTimeId = constructorNamed epochTimeReference "io.EpochTime.EpochTime"$/;"	fi	line:101	language:Haskell
epochTimeReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^epochTimeReference = typeNamed "io.EpochTime"$/;"	fi	line:81	language:Haskell
eq	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^eq :: a -> a -> Bool$/;"	ft	signature:(a -> a -> Bool)	line:126	language:Haskell
err	./yaks/haskeline/tests/Unit.hs	/^err :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:295	language:Haskell
error	./parser-typechecker/src/Unison/Util/Logger.hs	/^error, warn, info, debug, trace :: Logger -> String -> IO ()$/;"	ft	signature:(Logger -> String -> IO ())	line:81	language:Haskell
error'	./parser-typechecker/src/Unison/Util/Logger.hs	/^error', warn', info', debug', trace' :: Logger -> IO String -> IO ()$/;"	ft	signature:(Logger -> IO String -> IO ())	line:88	language:Haskell
errorFileName	./unison-src/parser-tests/GenerateErrors.hs	/^errorFileName :: String -> String$/;"	ft	signature:(String -> String)	line:26	language:Haskell
errorLevel	./parser-typechecker/src/Unison/Util/Logger.hs	/^errorLevel, warnLevel, infoLevel, debugLevel, traceLevel :: Level$/;"	ft	signature:(Level)	line:95	language:Haskell
errorNote	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^errorNote :: ErrorExtractor v loc (C.ErrorNote v loc)$/;"	ft	signature:(ErrorExtractor v loc (C.ErrorNote v loc))	line:283	language:Haskell
errorReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^errorReference = typeNamed "io.Error"$/;"	fi	line:75	language:Haskell
errorTerms	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^errorTerms :: ErrorNote v loc -> [Term v loc]$/;"	ft	signature:(ErrorNote v loc -> [Term v loc])	line:294	language:Haskell
errorTypeReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^errorTypeReference = typeNamed "io.ErrorType"$/;"	fi	line:76	language:Haskell
errors	./parser-typechecker/src/Unison/Typechecker.hs	/^  errors :: Seq (Context.ErrorNote v loc),$/;"	c_a	cons:Notes.Notes	line:46	language:Haskell
escapeChars	./parser-typechecker/src/Unison/Lexer.hs	/^escapeChars :: [(Char, Char)]$/;"	ft	signature:([(Char, Char)])	line:571	language:Haskell
escapeReplacement	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^escapeReplacement :: Maybe Char -> String -> Completion -> Completion$/;"	ft	signature:(Maybe Char -> String -> Completion -> Completion)	line:108	language:Haskell
etaNormalForm	./unison-core/src/Unison/Term.hs	/^etaNormalForm :: Eq v => Term0 v -> Term0 v$/;"	ft	signature:(Eq v => Term0 v -> Term0 v)	line:907	language:Haskell
eval	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^eval :: Command m i v a -> Action m i v a$/;"	ft	signature:(Command m i v a -> Action m i v a)	line:1746	language:Haskell
eval	./parser-typechecker/src/Unison/Util/Free.hs	/^eval :: f a -> Free f a$/;"	ft	signature:(f a -> Free f a)	line:15	language:Haskell
evalDraw	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^evalDraw :: forall m . (MonadReader Layout m, CommandMonad m) => Terminal -> Actions -> EvalTerm (PosixT m)$/;"	ft	signature:(forall m . (MonadReader Layout m, CommandMonad m) => Terminal -> Actions -> EvalTerm (PosixT m))	line:116	language:Haskell
evalDumb	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^evalDumb :: (MonadReader Layout m, CommandMonad m) => EvalTerm (PosixT m)$/;"	ft	signature:((MonadReader Layout m, CommandMonad m) => EvalTerm (PosixT m))	line:32	language:Haskell
evalStateT'	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^evalStateT' :: Monad m => s -> StateT s m a -> m a$/;"	ft	signature:(Monad m => s -> StateT s m a -> m a)	line:123	language:Haskell
evalTerm	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    , evalTerm :: forall m . CommandMonad m => EvalTerm m$/;"	c_a	cons:TermOps.TermOps	line:45	language:Haskell
evaluate	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^  , evaluate$/;"	c_a	cons:Runtime.Runtime	line:30	language:Haskell
evaluateTerm	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^evaluateTerm codeLookup ppe rt tm = do$/;"	fi	line:121	language:Haskell
evaluateWatches	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^evaluateWatches code ppe evaluationCache rt uf = do$/;"	fi	line:64	language:Haskell
eventReader	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^eventReader :: HANDLE -> IO [Event]$/;"	ft	signature:(HANDLE -> IO [Event])	line:52	language:Haskell
ex	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^ex :: P.Pretty P.ColorText$/;"	ft	signature:(P.Pretty P.ColorText)	line:368	language:Haskell
ex	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^ex :: Ord a => AnnotatedExcerpt a$/;"	ft	signature:(Ord a => AnnotatedExcerpt a)	line:52	language:Haskell
ex2	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^ex2 :: AnnotatedExcerpt Color$/;"	ft	signature:(AnnotatedExcerpt Color)	line:30	language:Haskell
ex3	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^ex3 :: AnnotatedExcerpt Color$/;"	ft	signature:(AnnotatedExcerpt Color)	line:42	language:Haskell
ex4	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^ex4 :: AnnotatedExcerpt Color$/;"	ft	signature:(AnnotatedExcerpt Color)	line:47	language:Haskell
ex4e	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^ex4e :: String$/;"	ft	signature:(String)	line:22	language:Haskell
ex4t	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^ex4t :: String$/;"	ft	signature:(String)	line:26	language:Haskell
exactComplete	./parser-typechecker/src/Unison/CommandLine.hs	/^exactComplete :: String -> [String] -> [Line.Completion]$/;"	ft	signature:(String -> [String] -> [Line.Completion])	line:139	language:Haskell
exactDefinitionOrPathArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^exactDefinitionOrPathArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1220	language:Haskell
exactDefinitionQueryArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^exactDefinitionQueryArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1230	language:Haskell
exactDefinitionTermQueryArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^exactDefinitionTermQueryArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1240	language:Haskell
exactDefinitionTypeQueryArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^exactDefinitionTypeQueryArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1236	language:Haskell
excerptColumn2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^excerptColumn2 max cols = case max of$/;"	fi	line:457	language:Haskell
excerptColumn2Headed	./parser-typechecker/src/Unison/Util/Pretty.hs	/^excerptColumn2Headed max hd cols = case max of$/;"	fi	line:446	language:Haskell
excerptSep	./parser-typechecker/src/Unison/Util/Pretty.hs	/^excerptSep :: IsString s => Maybe Int -> Pretty s -> [Pretty s] -> Pretty s$/;"	ft	signature:(IsString s => Maybe Int -> Pretty s -> [Pretty s] -> Pretty s)	line:353	language:Haskell
excerptSep'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^excerptSep' maxCount summarize s ps = case maxCount of$/;"	fi	line:364	language:Haskell
excerptToText	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^excerptToText :: forall a. AnnotatedExcerpt a -> AnnotatedText a$/;"	ft	signature:(forall a. AnnotatedExcerpt a -> AnnotatedText a)	line:124	language:Haskell
execInputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^execInputT :: MonadException m => Prefs -> Settings m -> RunTerm$/;"	ft	signature:(MonadException m => Prefs -> Settings m -> RunTerm -> InputT m a -> m a)	line:150	language:Haskell
execute	./parser-typechecker/src/Unison/Codebase/Execute.hs	/^execute codebase runtime mainName =$/;"	fi	line:37	language:Haskell
execute	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^execute :: InputPattern$/;"	ft	signature:(InputPattern)	line:1125	language:Haskell
executePPE	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^executePPE unisonFile =$/;"	fi	line:2570	language:Haskell
existential	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^existential :: v -> Element v loc$/;"	ft	signature:(v -> Element v loc)	line:97	language:Haskell
existential'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^existential' :: Ord v => a -> B.Blank loc -> v -> Type.Type (TypeVar v loc) a$/;"	ft	signature:(Ord v => a -> B.Blank loc -> v -> Type.Type (TypeVar v loc) a)	line:100	language:Haskell
existentialFunctionTypeFor	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^existentialFunctionTypeFor :: Var v => Term v loc -> M v loc (Type v loc)$/;"	ft	signature:(Var v => Term v loc -> M v loc (Type v loc))	line:1245	language:Haskell
existentialMismatch0	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^existentialMismatch0 em getExpectedLoc = do$/;"	fi	line:215	language:Haskell
existentialVars	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Info { existentialVars :: Set v -- set of existentials seen so far$/;"	c_a	cons:Info.Info	line:329	language:Haskell
existentializeArrows	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^existentializeArrows :: Var v => Type v loc -> M v loc (Type v loc)$/;"	ft	signature:(Var v => Type v loc -> M v loc (Type v loc))	line:1257	language:Haskell
existentializeArrows	./unison-core/src/Unison/Type.hs	/^existentializeArrows :: (Ord v, Monad m) => m v -> Type v a -> m (Type v a)$/;"	ft	signature:((Ord v, Monad m) => m v -> Type v a -> m (Type v a))	line:423	language:Haskell
existentialp	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^existentialp :: Ord v => a -> v -> Type v a$/;"	ft	signature:(Ord v => a -> v -> Type v a)	line:103	language:Haskell
existentials	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^existentials :: Ord v => Context v loc -> Set v$/;"	ft	signature:(Ord v => Context v loc -> Set v)	line:496	language:Haskell
exists	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^exists :: MonadIO m => CodebasePath -> m Bool$/;"	ft	signature:(MonadIO m => CodebasePath -> m Bool)	line:297	language:Haskell
exitingCommands	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^exitingCommands :: InputKeyCmd CommandMode InsertMode$/;"	ft	signature:(InputKeyCmd CommandMode InsertMode)	line:97	language:Haskell
expandNumber	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^expandNumber :: [String] -> String -> [String]$/;"	ft	signature:([String] -> String -> [String])	line:51	language:Haskell
expandWildcardImport	./unison-core/src/Unison/Names3.hs	/^expandWildcardImport :: Name -> Names0 -> [(Name,Name)]$/;"	ft	signature:(Name -> Names0 -> [(Name, Name)])	line:230	language:Haskell
expect	./yaks/easytest/src/EasyTest.hs	/^expect :: HasCallStack => Bool -> Test ()$/;"	ft	signature:(HasCallStack => Bool -> Test ())	line:60	language:Haskell
expect'	./yaks/easytest/src/EasyTest.hs	/^expect' :: HasCallStack => Bool -> Test ()$/;"	ft	signature:(HasCallStack => Bool -> Test ())	line:56	language:Haskell
expectEqual	./yaks/easytest/src/EasyTest.hs	/^expectEqual :: (Eq a, Show a) => a -> a -> Test ()$/;"	ft	signature:((Eq a, Show a) => a -> a -> Test ())	line:64	language:Haskell
expectFileParseFailure	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  expectFileParseFailure :: String -> (P.Error Symbol -> Test ()) -> Test ()$/;"	ft	signature:(String -> (P.Error Symbol -> Test ()) -> Test ())	line:64	language:Haskell
expectJust	./yaks/easytest/src/EasyTest.hs	/^expectJust :: HasCallStack => Maybe a -> Test a$/;"	ft	signature:(HasCallStack => Maybe a -> Test a)	line:73	language:Haskell
expectLeft	./yaks/easytest/src/EasyTest.hs	/^expectLeft :: HasCallStack => Either e a -> Test e$/;"	ft	signature:(HasCallStack => Either e a -> Test e)	line:81	language:Haskell
expectNotEqual	./yaks/easytest/src/EasyTest.hs	/^expectNotEqual :: (Eq a, Show a) => a -> a -> Test ()$/;"	ft	signature:((Eq a, Show a) => a -> a -> Test ())	line:68	language:Haskell
expectRight	./yaks/easytest/src/EasyTest.hs	/^expectRight :: HasCallStack => Either e a -> Test a$/;"	ft	signature:(HasCallStack => Either e a -> Test a)	line:77	language:Haskell
expectRight'	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^expectRight' :: Either String a -> Test a$/;"	ft	signature:(Either String a -> Test a)	line:61	language:Haskell
expectedBlockOpenTest	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  expectedBlockOpenTest :: Test ()$/;"	ft	signature:(Test ())	line:103	language:Haskell
expectedLeaf	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^             , expectedLeaf :: C.Type v loc -- leaf2$/;"	c_a	cons:TypeError.Mismatch	line:29	language:Haskell
expectedLoc	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , expectedLoc            :: loc$/;"	c_a	cons:TypeError.ExistentialMismatch	line:40	language:Haskell
expectedType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^             , expectedType :: C.Type v loc -- overallType2$/;"	c_a	cons:TypeError.Mismatch	line:27	language:Haskell
expectedType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , expectedType           :: C.Type v loc$/;"	c_a	cons:TypeError.ExistentialMismatch	line:39	language:Haskell
expectedType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , expectedType :: C.Type v loc$/;"	c_a	cons:TypeError.FunctionApplication	line:50	language:Haskell
expectedType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                , expectedType :: C.Type v loc$/;"	c_a	cons:TypeError.UnknownTerm	line:74	language:Haskell
expectingError	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^expectingError :: P ExpectingError$/;"	ft	signature:(P ExpectingError)	line:382	language:Haskell
extend	./parser-typechecker/src/Unison/Path.hs	/^  extend :: p -> p -> p$/;"	ft	signature:(p -> p -> p)	class:Path	line:20	language:Haskell
extend	./parser-typechecker/src/Unison/Path.hs	/^  extend = (<|>)$/;"	fi	instance:Eq a => Path (Maybe a)	line:37	language:Haskell
extend	./parser-typechecker/src/Unison/Path.hs	/^  extend = (++)$/;"	fi	instance:Eq a => Path [a]	line:44	language:Haskell
extend	./parser-typechecker/src/Unison/Path.hs	/^  extend _ _ = ()$/;"	fi	instance:Path ()	line:53	language:Haskell
extend	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extend :: Var v => Element v loc -> Context v loc -> M v loc (Context v loc)$/;"	ft	signature:(Var v => Element v loc -> Context v loc -> M v loc (Context v loc))	line:594	language:Haskell
extend	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^extend 0 ca = pure ca$/;"	fi	line:122	language:Haskell
extend'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extend' :: Var v => Element v loc -> Context v loc -> Either (CompilerBug v loc) (Context v loc)$/;"	ft	signature:(Var v => Element v loc -> Context v loc -> Either (CompilerBug v loc) (Context v loc))	line:560	language:Haskell
extendContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extendContext :: Var v => Element v loc -> M v loc ()$/;"	ft	signature:(Var v => Element v loc -> M v loc ())	line:464	language:Haskell
extendExistential	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extendExistential :: (Var v) => v -> M v loc v$/;"	ft	signature:((Var v) => v -> M v loc v)	line:684	language:Haskell
extendExistentialTV	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extendExistentialTV :: Var v => v -> M v loc (TypeVar v loc)$/;"	ft	signature:(Var v => v -> M v loc (TypeVar v loc))	line:690	language:Haskell
extendN	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extendN :: Var v => Context v loc -> [Element v loc] -> M v loc (Context v loc)$/;"	ft	signature:(Var v => Context v loc -> [Element v loc] -> M v loc (Context v loc))	line:599	language:Haskell
extendUniversal	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^extendUniversal :: (Var v) => v -> M v loc v$/;"	ft	signature:((Var v) => v -> M v loc v)	line:678	language:Haskell
externalHandle	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^externalHandle :: Handle -> ExternalHandle$/;"	ft	signature:(Handle -> ExternalHandle)	line:39	language:Haskell
externalMode	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^                        { externalMode :: ExternalMode$/;"	c_a	cons:ExternalHandle.ExternalHandle	line:33	language:Haskell
externalPrint	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    , externalPrint :: String -> IO ()$/;"	c_a	cons:TermOps.TermOps	line:47	language:Haskell
extraDefinitions	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , extraDefinitions :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:46	language:Haskell
extraMap	./unison-core/src/Unison/ABT.hs	/^extraMap :: Functor g => (forall k . f k -> g k) -> Term f v a -> Term g v a$/;"	ft	signature:(Functor g => (forall k . f k -> g k) -> Term f v a -> Term g v a)	line:159	language:Haskell
extraMap	./unison-core/src/Unison/Term.hs	/^extraMap vtf atf apf = \\case$/;"	fi	line:237	language:Haskell
extraMap'	./unison-core/src/Unison/Term.hs	/^extraMap' vtf atf apf = ABT.extraMap (extraMap vtf atf apf)$/;"	fi	line:228	language:Haskell
extract	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^extract :: Extractor e a -> e -> Maybe a$/;"	ft	signature:(Extractor e a -> e -> Maybe a)	line:38	language:Haskell
extractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^extractor :: (e -> Maybe a) -> Extractor e a$/;"	ft	signature:((e -> Maybe a) -> Extractor e a)	line:35	language:Haskell
f	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | FunctionApplication { f            :: C.Term v loc$/;"	c_a	cons:TypeError.FunctionApplication	line:45	language:Haskell
f	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | NotFunctionApplication { f    :: C.Term v loc$/;"	c_a	cons:TypeError.NotFunctionApplication	line:55	language:Haskell
f	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^f >|> g = \\x -> f x >>= g$/;"	fi	line:117	language:Haskell
fact	./parser-typechecker/src/Unison/Util/Star3.hs	/^  = Star3 { fact :: Set fact$/;"	c_a	cons:Star3.Star3	line:15	language:Haskell
factor	./parser-typechecker/src/Unison/Path.hs	/^  factor :: p -> p -> (p,(p,p))$/;"	ft	signature:(p -> p -> (p, (p, p)))	class:Path	line:22	language:Haskell
factor	./parser-typechecker/src/Unison/Path.hs	/^  factor p1 p2 | p1 == p2 = (p1, (Nothing, Nothing))$/;"	fi	instance:Eq a => Path (Maybe a)	line:39	language:Haskell
factor	./parser-typechecker/src/Unison/Path.hs	/^  factor p1 p2 = (take shared p1, (drop shared p1, drop shared p2))$/;"	fi	instance:Eq a => Path [a]	line:47	language:Haskell
factor	./parser-typechecker/src/Unison/Path.hs	/^  factor u _ = (u,(u,u))$/;"	fi	instance:Path ()	line:54	language:Haskell
fail	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  fail = error$/;"	fi	instance:Monad f => MonadFail-MonadFail (MT v loc f)	line:1802	language:Haskell
fail	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  fail _ = mzero$/;"	fi	instance:MonadFail (SubseqExtractor' n)	line:316	language:Haskell
fail	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  fail = Control.Monad.Fail.fail$/;"	fi	instance:Monad (SubseqExtractor' n)	line:319	language:Haskell
fail	./yaks/easytest/src/EasyTest.hs	/^  fail = Control.Monad.Fail.fail$/;"	fi	instance:Monad Test	line:377	language:Haskell
fail	./yaks/easytest/src/EasyTest.hs	/^  fail = crash$/;"	fi	instance:MonadFail Test	line:390	language:Haskell
failCmd	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^failCmd :: Monad m => Command m s (Maybe a)$/;"	ft	signature:(Monad m => Command m s (Maybe a))	line:135	language:Haskell
failCommitted	./parser-typechecker/src/Unison/Parser.hs	/^failCommitted :: Ord v => Error v -> P v x$/;"	ft	signature:(Ord v => Error v -> P v x)	line:221	language:Haskell
failConstructorId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
failConstructorReferent	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorReferent, failConstructorReferent :: Referent.Referent$/;"	ft	signature:(Referent.Referent)	line:442	language:Haskell
failConstructorReferent	./unison-core/src/Unison/DataDeclaration.hs	/^failConstructorReferent = Referent.Con testResultRef failConstructorId CT.Data$/;"	fi	line:444	language:Haskell
failResult	./unison-core/src/Unison/DataDeclaration.hs	/^failResult :: (Ord v, Monoid a) => a -> Text -> Term v a$/;"	ft	signature:((Ord v, Monoid a) => a -> Text -> Term v a)	line:446	language:Haskell
failWith	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^failWith :: MonadIO m => Err -> m a$/;"	ft	signature:(MonadIO m => Err -> m a)	line:749	language:Haskell
failWith	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^failWith :: Cause v loc -> M v loc a$/;"	ft	signature:(Cause v loc -> M v loc a)	line:637	language:Haskell
failureIf	./parser-typechecker/src/Unison/Parser.hs	/^failureIf :: Ord v => P v (P v b) -> P v a -> P v b$/;"	ft	signature:(Ord v => P v (P v b) -> P v a -> P v b)	line:429	language:Haskell
fallbackCompletion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^fallbackCompletion :: Monad m => CompletionFunc m -> CompletionFunc m -> CompletionFunc m$/;"	ft	signature:(Monad m => CompletionFunc m -> CompletionFunc m -> CompletionFunc m)	line:195	language:Haskell
fatalCallout	./parser-typechecker/src/Unison/Util/Pretty.hs	/^fatalCallout = callout "âï¸"$/;"	fi	line:772	language:Haskell
fdReadNonBlocking	./yaks/haskeline/tests/Pty.hs	/^fdReadNonBlocking :: Fd -> Ptr CChar -> CSize -> IO CSsize$/;"	ft	signature:(Fd -> Ptr CChar -> CSize -> IO CSsize)	line:70	language:Haskell
fence	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^fence :: P ()$/;"	ft	signature:(P ())	line:333	language:Haskell
fenced	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^fenced :: P Stanza$/;"	ft	signature:(P Stanza)	line:306	language:Haskell
fieldNames	./parser-typechecker/src/Unison/DeclPrinter.hs	/^fieldNames env r name dd = case DD.constructors dd of$/;"	fi	line:127	language:Haskell
file	./parser-typechecker/src/Unison/FileParser.hs	/^file :: forall v . Var v => P v (UnisonFile v Ann)$/;"	ft	signature:(forall v . Var v => P v (UnisonFile v Ann))	line:39	language:Haskell
file	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^file :: UnisonFile Symbol Ann$/;"	ft	signature:(UnisonFile Symbol Ann)	line:38	language:Haskell
fileHandleRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^fileHandleRunTerm :: Handle -> IO RunTerm$/;"	ft	signature:(Handle -> IO RunTerm)	line:51	language:Haskell
filePathId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
filePathId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^filePathId = constructorNamed filePathReference "io.FilePath.FilePath"$/;"	fi	line:104	language:Haskell
filePathReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^filePathReference = typeNamed "io.FilePath"$/;"	fi	line:84	language:Haskell
fileRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^fileRunTerm :: Handle -> IO RunTerm$/;"	ft	signature:(Handle -> IO RunTerm)	line:309	language:Haskell
fileRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^fileRunTerm :: Handle -> IO RunTerm$/;"	ft	signature:(Handle -> IO RunTerm)	line:400	language:Haskell
fileStyleTests	./yaks/haskeline/tests/Unit.hs	/^fileStyleTests i = "file style" ~:$/;"	fi	line:181	language:Haskell
filenameWordBreakChars	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^filenameWordBreakChars :: String$/;"	ft	signature:(String)	line:93	language:Haskell
filestatusTip	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^filestatusTip :: Pretty$/;"	ft	signature:(Pretty)	line:1746	language:Haskell
fillConsoleAttribute	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^fillConsoleAttribute :: HANDLE -> WORD -> Int -> Coord -> IO ()$/;"	ft	signature:(HANDLE -> WORD -> Int -> Coord -> IO ())	line:529	language:Haskell
fillConsoleChar	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^fillConsoleChar :: HANDLE -> Char -> Int -> Coord -> IO ()$/;"	ft	signature:(HANDLE -> Char -> Int -> Coord -> IO ())	line:520	language:Haskell
filter	./unison-core/src/Unison/Names2.hs	/^filter :: Ord n => (n -> Bool) -> Names' n -> Names' n$/;"	ft	signature:(Ord n => (n -> Bool) -> Names' n -> Names' n)	line:288	language:Haskell
filter	./unison-core/src/Unison/Util/Relation.hs	/^filter :: (Ord a, Ord b) => ((a, b) -> Bool) -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => ((a, b) -> Bool) -> Relation a b -> Relation a b)	line:232	language:Haskell
filter	./unison-core/src/Unison/Util/Relation3.hs	/^filter :: (Ord a, Ord b, Ord c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => ((a, b, c) -> Bool) -> Relation3 a b c -> Relation3 a b c)	line:33	language:Haskell
filter	./unison-core/src/Unison/Util/Relation4.hs	/^filter :: (Ord a, Ord b, Ord c, Ord d) => ((a,b,c,d) -> Bool) -> Relation4 a b c d -> Relation4 a b c d$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => ((a, b, c, d) -> Bool) -> Relation4 a b c d -> Relation4 a b c d)	line:47	language:Haskell
filterByHQs	./unison-core/src/Unison/Names2.hs	/^filterByHQs :: Set HashQualified -> Names0 -> Names0$/;"	ft	signature:(Set HashQualified -> Names0 -> Names0)	line:292	language:Haskell
filterBySHs	./unison-core/src/Unison/Names2.hs	/^filterBySHs :: Set ShortHash -> Names0 -> Names0$/;"	ft	signature:(Set ShortHash -> Names0 -> Names0)	line:299	language:Haskell
filterBySlurpResult	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^filterBySlurpResult :: Ord v$/;"	ft	signature:(Ord v => SlurpResult v -> UF.TypecheckedUnisonFile v Ann -> UF.TypecheckedUnisonFile v Ann)	line:2226	language:Haskell
filterDom	./unison-core/src/Unison/Util/Relation.hs	/^filterDom :: (Ord a, Ord b) => (a -> Bool) -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => (a -> Bool) -> Relation a b -> Relation a b)	line:226	language:Haskell
filterManyDom	./unison-core/src/Unison/Util/Relation.hs	/^filterManyDom :: (Ord a, Ord b) => Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Relation a b)	line:236	language:Haskell
filterRan	./unison-core/src/Unison/Util/Relation.hs	/^filterRan :: (Ord a, Ord b) => (b -> Bool) -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => (b -> Bool) -> Relation a b -> Relation a b)	line:229	language:Haskell
filterTypes	./unison-core/src/Unison/Names2.hs	/^filterTypes :: Ord n => (n -> Bool) -> Names' n -> Names' n$/;"	ft	signature:(Ord n => (n -> Bool) -> Names' n -> Names' n)	line:306	language:Haskell
filterTypes	./unison-core/src/Unison/Names3.hs	/^filterTypes :: (Name -> Bool) -> Names0 -> Names0$/;"	ft	signature:((Name -> Bool) -> Names0 -> Names0)	line:56	language:Haskell
finally	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^finally :: MonadException m => m a -> m b -> m a$/;"	ft	signature:(MonadException m => m a -> m b -> m a)	line:124	language:Haskell
find	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^find :: InputPattern$/;"	ft	signature:(InputPattern)	line:298	language:Haskell
find	./unison-core/src/Unison/ABT.hs	/^find :: (Ord v, Foldable f, Functor f)$/;"	ft	signature:((Ord v, Foldable f, Functor f) => (Term f v a -> FindAction x) -> Term f v a -> [x])	line:510	language:Haskell
find'	./unison-core/src/Unison/ABT.hs	/^find' :: (Ord v, Foldable f, Functor f)$/;"	ft	signature:((Ord v, Foldable f, Functor f) => (Term f v a -> Bool) -> Term f v a -> [Term f v a])	line:524	language:Haskell
findFirst	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^findFirst :: forall s m . (Save s, MonadState HistLog m)$/;"	ft	signature:(forall s m . (Save s, MonadState HistLog m) => ([Grapheme] -> Maybe s) -> Direction -> s -> m (Maybe s))	line:191	language:Haskell
findHistoricalHQs	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^findHistoricalHQs :: Monad m$/;"	ft	signature:(Monad m => Set HashQualified -> Branch m -> m (Set HashQualified, Names0))	line:227	language:Haskell
findHistoricalHQs	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^findHistoricalHQs :: Monad m => Set HQ.HashQualified -> Action' m v Names0$/;"	ft	signature:(Monad m => Set HQ.HashQualified -> Action' m v Names0)	line:2421	language:Haskell
findHistoricalRefs	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^findHistoricalRefs :: Monad m => Set LabeledDependency -> Branch m$/;"	ft	signature:(Monad m => Set LabeledDependency -> Branch m -> m (Set LabeledDependency, Names0))	line:235	language:Haskell
findHistoricalSHs	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^findHistoricalSHs = findInHistory$/;"	fi	line:221	language:Haskell
findInHistory	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^findInHistory :: forall m q. (Monad m, Ord q)$/;"	ft	signature:(forall m q. (Monad m, Ord q) => (q -> Referent -> Name -> Bool) -> (q -> Reference -> Name -> Bool) -> Set q -> Branch m -> m (Set q, Names0))	line:241	language:Haskell
findInLine	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^findInLine :: [Grapheme] -> [Grapheme] -> Maybe InsertMode$/;"	ft	signature:([Grapheme] -> [Grapheme] -> Maybe InsertMode)	line:118	language:Haskell
findMatchingBrace	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^findMatchingBrace :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:316	language:Haskell
findNearest	./parser-typechecker/src/Unison/Lexer.hs	/^findNearest :: Layout -> Set BlockName -> Maybe BlockName$/;"	ft	signature:(Layout -> Set BlockName -> Maybe BlockName)	line:160	language:Haskell
findPatch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^findPatch :: InputPattern$/;"	ft	signature:(InputPattern)	line:346	language:Haskell
findShallow	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^findShallow :: InputPattern$/;"	ft	signature:(InputPattern)	line:317	language:Haskell
findTerm	./parser-typechecker/src/Unison/PrintError.hs	/^findTerm :: Seq (C.PathElement v loc) -> Maybe loc$/;"	ft	signature:(Seq (C.PathElement v loc) -> Maybe loc)	line:1167	language:Haskell
findVerbose	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^findVerbose :: InputPattern$/;"	ft	signature:(InputPattern)	line:336	language:Haskell
finish	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^finish :: (Monad m, Result s) => Command m s (Maybe String)$/;"	ft	signature:((Monad m, Result s) => Command m s (Maybe String))	line:132	language:Haskell
firstHistory	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^prevHistory, firstHistory :: Save s => s -> HistLog -> (s, HistLog)$/;"	ft	signature:(Save s => s -> HistLog -> (s, HistLog))	line:46	language:Haskell
firstHistory	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^firstHistory s h = let prevs = (listSave s,h):prevHistories (listSave s) h$/;"	fi	line:51	language:Haskell
firstLexerError	./parser-typechecker/src/Unison/PrintError.hs	/^firstLexerError :: Foldable t => t (L.Token L.Lexeme) -> Maybe ([L.Token L.Lexeme], L.Err)$/;"	ft	signature:(Foldable t => t (L.Token L.Lexeme) -> Maybe ([L.Token L.Lexeme], L.Err))	line:894	language:Haskell
fixOutput	./yaks/haskeline/tests/RunTTY.hs	/^fixOutput = BC.pack . loop . BC.unpack$/;"	fi	line:93	language:Haskell
fixPath	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^fixPath :: String -> IO String$/;"	ft	signature:(String -> IO String)	line:185	language:Haskell
fixupCompletion	./parser-typechecker/src/Unison/CommandLine.hs	/^fixupCompletion :: String -> [Line.Completion] -> [Line.Completion]$/;"	ft	signature:(String -> [Line.Completion] -> [Line.Completion])	line:153	language:Haskell
fixupNamesRelative	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^fixupNamesRelative :: Path.Absolute -> Names0 -> Names0$/;"	ft	signature:(Path.Absolute -> Names0 -> Names0)	line:2473	language:Haskell
flatMap	./parser-typechecker/src/Unison/Util/Pretty.hs	/^flatMap :: (s -> Pretty s2) -> Pretty s -> Pretty s2$/;"	ft	signature:((s -> Pretty s2) -> Pretty s -> Pretty s2)	line:803	language:Haskell
flatten	./parser-typechecker/src/Unison/Util/Bytes.hs	/^flatten :: Bytes -> Bytes$/;"	ft	signature:(Bytes -> Bytes)	line:47	language:Haskell
flattenEffects	./unison-core/src/Unison/Type.hs	/^flattenEffects :: Type v a -> [Type v a]$/;"	ft	signature:(Type v a -> [Type v a])	line:349	language:Haskell
flipApply	./unison-core/src/Unison/Type.hs	/^flipApply :: Var v => Type v () -> Type v ()$/;"	ft	signature:(Var v => Type v () -> Type v ())	line:365	language:Haskell
flipCase	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^flipCase :: CommandMode -> CommandMode$/;"	ft	signature:(CommandMode -> CommandMode)	line:203	language:Haskell
float	./unison-core/src/Unison/Term.hs	/^float :: Ord v => a -> Double -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Double -> Term2 vt at ap v a)	line:482	language:Haskell
float	./unison-core/src/Unison/Type.hs	/^float :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:234	language:Haskell
floatRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
floatRef	./unison-core/src/Unison/Type.hs	/^floatRef = Reference.Builtin "Float"$/;"	fi	line:215	language:Haskell
flush	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  flush = PutT $ pure flush$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:19	language:Haskell
flush	./parser-typechecker/src/Unison/Util/TQueue.hs	/^flush :: TQueue a -> STM [a]$/;"	ft	signature:(TQueue a -> STM [a])	line:56	language:Haskell
flushEventQueue	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^flushEventQueue :: (String -> IO ()) -> TChan Event -> IO ()$/;"	ft	signature:((String -> IO ()) -> TChan Event -> IO ())	line:54	language:Haskell
fmap	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^  fmap f cl = CodeLookup tm ty where$/;"	fi	instance:(Ord v, Functor m) => Functor (CodeLookup v m)	line:40	language:Haskell
fmap	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  fmap f (PutT m) = PutT $ fmap (fmap f) m$/;"	fi	instance:Functor m => Functor (PutT m)	line:43	language:Haskell
fmap	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  fmap f (MT m) = MT (\\menv -> fmap (first f) (m menv))$/;"	fi	instance:Functor f => Functor (MT v loc f)	line:1809	language:Haskell
fmap	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  fmap = liftM$/;"	fi	instance:Functor (SubseqExtractor' n)	line:309	language:Haskell
fmap	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^  fmap f tl =$/;"	fi	instance:Functor (TypeLookup v)	line:64	language:Haskell
fmap	./parser-typechecker/src/Unison/Util/Free.hs	/^  fmap = liftM$/;"	fi	instance:Functor (Free f)	line:56	language:Haskell
fmap	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  fmap f (Pretty d o) = Pretty d (mapLit f $ fmap (fmap f) o)$/;"	fi	instance:Functor Pretty	line:128	language:Haskell
fmap	./unison-core/src/Unison/ABT.hs	/^  fmap f (Term fvs a sub) = Term fvs (f a) (fmap (fmap f) sub)$/;"	fi	instance:Functor f => Functor (Term f v)	line:157	language:Haskell
fmap	./yaks/easytest/src/EasyTest.hs	/^  fmap = liftM$/;"	fi	instance:Functor Test	line:393	language:Haskell
fmap	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    fmap f km = KeyMap $ fmap (fmap f) . lookupKM km$/;"	fi	instance:Functor KeyMap	line:51	language:Haskell
fmap	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    fmap f (NotConsumed x) = NotConsumed (f x)$/;"	fi	instance:Functor KeyConsumed	line:54	language:Haskell
fmap	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    fmap = liftM$/;"	fi	instance:Monad m => Functor (CmdM m)	line:66	language:Haskell
fmap	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    fmap f am = am {argState = f (argState am)}$/;"	fi	instance:Functor ArgMode	line:344	language:Haskell
fmap	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    fmap  = liftM$/;"	fi	instance:Monad m => Functor (StateT s m)	line:75	language:Haskell
fmt	./parser-typechecker/src/Unison/DeclPrinter.hs	/^fmt :: S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText$/;"	ft	signature:(S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText)	line:189	language:Haskell
fmt	./parser-typechecker/src/Unison/NamePrinter.hs	/^fmt :: S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText$/;"	ft	signature:(S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText)	line:75	language:Haskell
fmt	./parser-typechecker/src/Unison/TermPrinter.hs	/^fmt :: S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText$/;"	ft	signature:(S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText)	line:625	language:Haskell
fmt	./parser-typechecker/src/Unison/TypePrinter.hs	/^fmt :: S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText$/;"	ft	signature:(S.Element -> Pretty S.SyntaxText -> Pretty S.SyntaxText)	line:131	language:Haskell
focus	./unison-core/src/Unison/ABT.hs	/^newtype Path s t a b m = Path { focus :: s -> Maybe (a, b -> Maybe t, m) }$/;"	c_a	cons:Path.Path	line:56	language:Haskell
focus	./unison-core/src/Unison/Paths.hs	/^focus :: Var v => Path -> Target v -> Maybe (Target v, Target (V v) -> Maybe (Target v), [v])$/;"	ft	signature:(Var v => Path -> Target v -> Maybe (Target v, Target (V v) -> Maybe (Target v), [v]))	line:122	language:Haskell
focus1	./unison-core/src/Unison/Paths.hs	/^focus1 e = ABT.Path go'$/;"	fi	line:48	language:Haskell
focusAt	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^focusAt :: (a -> Bool) -> [a] -> Maybe ([a], a, [a])$/;"	ft	signature:((a -> Bool) -> [a] -> Maybe ([a], a, [a]))	line:343	language:Haskell
fold	./parser-typechecker/src/Unison/Util/Free.hs	/^fold :: Monad m => (forall x. f x -> m x) -> Free f a -> m a$/;"	ft	signature:(Monad m => (forall x. f x -> m x) -> Free f a -> m a)	line:20	language:Haskell
fold	./unison-core/src/Unison/LabeledDependency.hs	/^fold :: (Reference -> a) -> (Referent -> a) -> LabeledDependency -> a$/;"	ft	signature:((Reference -> a) -> (Referent -> a) -> LabeledDependency -> a)	line:32	language:Haskell
foldHistoryUntil	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^foldHistoryUntil :: forall m h e a. (Monad m) => --(Show a, Show e) =>$/;"	ft	signature:(forall m h e a. (Monad m) => (a -> e -> (a, Bool)) -> a -> Causal m h e -> m (FoldHistoryResult a))	line:342	language:Haskell
foldMap'	./unison-core/src/Unison/Pattern.hs	/^foldMap' :: Monoid m => (PatternP loc -> m) -> PatternP loc -> m$/;"	ft	signature:(Monoid m => (PatternP loc -> m) -> PatternP loc -> m)	line:147	language:Haskell
foldMapM	./unison-core/src/Unison/Util/Monoid.hs	/^foldMapM :: (Monad m, Foldable f, Monoid b) => (a -> m b) -> f a -> m b$/;"	ft	signature:((Monad m, Foldable f, Monoid b) => (a -> m b) -> f a -> m b)	line:26	language:Haskell
foldResult'	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^foldResult' :: (TermResult' v a -> b) -> (TypeResult' v a -> b) -> SearchResult' v a -> b$/;"	ft	signature:((TermResult' v a -> b) -> (TypeResult' v a -> b) -> SearchResult' v a -> b)	line:39	language:Haskell
foldWithIndex	./parser-typechecker/src/Unison/Util/Free.hs	/^foldWithIndex :: forall f m a . Monad m => (forall x. Int -> f x -> m x) -> Free f a -> m a$/;"	ft	signature:(forall f m a . Monad m => (forall x. Int -> f x -> m x) -> Free f a -> m a)	line:47	language:Haskell
foldl	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  foldl = LL.foldl$/;"	fi	instance:LL-FoldableLL (AnnotatedText a) Char	line:40	language:Haskell
foldl'	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  foldl' f z (AnnotatedText at) = Foldable.foldl' f' z at where$/;"	fi	instance:LL-FoldableLL (AnnotatedText a) Char	line:38	language:Haskell
foldlStrict	./unison-core/src/Unison/Util/Relation.hs	/^foldlStrict :: (a -> b -> a) -> a -> [b] -> a$/;"	ft	signature:((a -> b -> a) -> a -> [b] -> a)	line:156	language:Haskell
foldr	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  foldr f z (AnnotatedText at) = Foldable.foldr f' z at where$/;"	fi	instance:LL-FoldableLL (AnnotatedText a) Char	line:41	language:Haskell
forall	./parser-typechecker/src/Unison/TypeParser.hs	/^forall :: Var v => TypeP v -> TypeP v$/;"	ft	signature:(Var v => TypeP v -> TypeP v)	line:108	language:Haskell
forall	./parser-typechecker/src/Unison/Util/Free.hs	/^data Free f a = Pure a | forall x . Bind (f x) (x -> Free f a)$/;"	cons	data:Free	line:13	language:Haskell
forall	./unison-core/src/Unison/Type.hs	/^forall :: Ord v => a -> v -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> v -> Type v a -> Type v a)	line:278	language:Haskell
forall	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^data Request = forall a . Request (InputT IO a) (MVar a)$/;"	cons	data:Request	line:51	language:Haskell
forall	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^data Handler m a = forall e . Exception e => Handler (e -> m a)$/;"	cons	data:Handler	line:114	language:Haskell
forall	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    = forall n . (Term n, CommandMonad n)$/;"	cons	data:EvalTerm	line:88	language:Haskell
forall'	./unison-core/src/Unison/Type.hs	/^forall' :: Var v => a -> [Text] -> Type v a -> Type v a$/;"	ft	signature:(Var v => a -> [Text] -> Type v a -> Type v a)	line:320	language:Haskell
foralls	./unison-core/src/Unison/Type.hs	/^foralls :: Ord v => a -> [v] -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> [v] -> Type v a -> Type v a)	line:323	language:Haskell
force	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^force :: Value -> IO Value$/;"	ft	signature:(Value -> IO Value)	line:203	language:Haskell
forceTerm	./unison-core/src/Unison/DataDeclaration.hs	/^forceTerm :: Var v => a -> a -> Term v a -> Term v a$/;"	ft	signature:(Var v => a -> a -> Term v a -> Term v a)	line:575	language:Haskell
forceThunk	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^forceThunk :: RT.CompilationEnv -> S -> RT.IR -> IO RT.Result$/;"	ft	signature:(RT.CompilationEnv -> S -> RT.IR -> IO RT.Result)	line:454	language:Haskell
foreachDigit	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^foreachDigit :: (Monad m, LineState t) => (Int -> s -> t) -> [Char] $/;"	ft	signature:((Monad m, LineState t) => (Int -> s -> t) -> [Char] -> KeyCommand m s t)	line:301	language:Haskell
foreachSubterm	./unison-core/src/Unison/ABT.hs	/^foreachSubterm f e = case out e of$/;"	fi	line:401	language:Haskell
fork	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^fork src dest root = case getAt src root of$/;"	fi	line:526	language:Haskell
fork	./yaks/easytest/src/EasyTest.hs	/^fork :: Test a -> Test ()$/;"	ft	signature:(Test a -> Test ())	line:423	language:Haskell
fork'	./yaks/easytest/src/EasyTest.hs	/^fork' :: Test a -> Test (Test a)$/;"	ft	signature:(Test a -> Test (Test a))	line:428	language:Haskell
forkCommandInPty	./yaks/haskeline/tests/Pty.hs	/^forkCommandInPty :: String -> [String] -> Maybe [(String,String)]$/;"	ft	signature:(String -> [String] -> Maybe [(String, String)] -> IO (Fd, ProcessID))	line:85	language:Haskell
forkLocal	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^forkLocal :: InputPattern$/;"	ft	signature:(InputPattern)	line:586	language:Haskell
forkedThread	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^data InputState = HD {forkedThread :: ThreadId,$/;"	c_a	cons:InputState.HD	line:53	language:Haskell
formatAnn	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^formatAnn :: S.Format Ann$/;"	ft	signature:(S.Format Ann)	line:127	language:Haskell
formatMissingStuff	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^formatMissingStuff :: (Show tm, Show typ) =>$/;"	ft	signature:((Show tm, Show typ) => [(HQ.HashQualified, tm)] -> [(HQ.HashQualified, typ)] -> Pretty)	line:963	language:Haskell
formatSymbol	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^formatSymbol :: S.Format Symbol$/;"	ft	signature:(S.Format Symbol)	line:758	language:Haskell
foundHistory	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^                              foundHistory :: InsertMode,$/;"	c_a	cons:SearchMode.SearchMode	line:79	language:Haskell
foundLeaf	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^             , foundLeaf    :: C.Type v loc -- leaf1$/;"	c_a	cons:TypeError.Mismatch	line:28	language:Haskell
foundType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  = Mismatch { foundType    :: C.Type v loc -- overallType1$/;"	c_a	cons:TypeError.Mismatch	line:26	language:Haskell
foundType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                    , foundType          :: C.Type v loc$/;"	c_a	cons:TypeError.BooleanMismatch	line:35	language:Haskell
foundType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , foundType              :: C.Type v loc$/;"	c_a	cons:TypeError.ExistentialMismatch	line:41	language:Haskell
foundType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , foundType    :: C.Type v loc$/;"	c_a	cons:TypeError.FunctionApplication	line:49	language:Haskell
fqn	./parser-typechecker/src/Unison/Typechecker.hs	/^  NamedReference { fqn :: Name, fqnType :: Type v loc$/;"	c_a	cons:NamedReference.NamedReference	line:63	language:Haskell
fqnType	./parser-typechecker/src/Unison/Typechecker.hs	/^  NamedReference { fqn :: Name, fqnType :: Type v loc$/;"	c_a	cons:NamedReference.NamedReference	line:63	language:Haskell
free	./parser-typechecker/src/Unison/Util/Free.hs	/^free :: Traversable f => f (Free f a) -> Free f a$/;"	ft	signature:(Traversable f => f (Free f a) -> Free f a)	line:41	language:Haskell
freeEffectVars	./unison-core/src/Unison/Type.hs	/^freeEffectVars :: Ord v => Type v a -> Set v$/;"	ft	signature:(Ord v => Type v a -> Set v)	line:410	language:Haskell
freeSlots	./parser-typechecker/src/Unison/Runtime/IR.hs	/^freeSlots :: IR e cont -> Set Int$/;"	ft	signature:(IR e cont -> Set Int)	line:827	language:Haskell
freeTypeVarAnnotations	./unison-core/src/Unison/Term.hs	/^freeTypeVarAnnotations :: Ord vt => Term' vt v a -> Map vt [a]$/;"	ft	signature:(Ord vt => Term' vt v a -> Map vt [a])	line:300	language:Haskell
freeTypeVars	./unison-core/src/Unison/Term.hs	/^freeTypeVars :: Ord vt => Term' vt v a -> Set vt$/;"	ft	signature:(Ord vt => Term' vt v a -> Set vt)	line:297	language:Haskell
freeVarOccurrences	./unison-core/src/Unison/ABT.hs	/^freeVarOccurrences :: (Traversable f, Ord v) => Set v -> Term f v a -> [(v, a)]$/;"	ft	signature:((Traversable f, Ord v) => Set v -> Term f v a -> [(v, a)])	line:384	language:Haskell
freeVars	./parser-typechecker/src/Unison/Runtime/IR.hs	/^freeVars :: [(SymbolC,a)] -> Term SymbolC -> Set SymbolC$/;"	ft	signature:([(SymbolC, a)] -> Term SymbolC -> Set SymbolC)	line:429	language:Haskell
freeVars	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^freeVars :: Var v => Term v loc -> M v loc (Set v)$/;"	ft	signature:(Var v => Term v loc -> M v loc (Set v))	line:522	language:Haskell
freeVars	./unison-core/src/Unison/ABT.hs	/^data Term f v a = Term { freeVars :: Set v, annotation :: a, out :: ABT f v (Term f v a) }$/;"	c_a	cons:Term.Term	line:38	language:Haskell
freeVars	./unison-core/src/Unison/Term.hs	/^freeVars :: Term' vt v a -> Set v$/;"	ft	signature:(Term' vt v a -> Set v)	line:294	language:Haskell
freeVars	./unison-core/src/Unison/Type.hs	/^freeVars :: Type v a -> Set v$/;"	ft	signature:(Type v a -> Set v)	line:64	language:Haskell
freeVarsToOuters	./unison-core/src/Unison/Type.hs	/^freeVarsToOuters :: Ord v => Set v -> Type v a -> Type v a$/;"	ft	signature:(Ord v => Set v -> Type v a -> Type v a)	line:516	language:Haskell
fresh	./unison-core/src/Unison/ABT.hs	/^fresh :: Var v => Term f v a -> v -> v$/;"	ft	signature:(Var v => Term f v a -> v -> v)	line:269	language:Haskell
fresh	./unison-core/src/Unison/Term.hs	/^fresh :: Var v => Term0 v -> v -> v$/;"	ft	signature:(Var v => Term0 v -> v -> v)	line:459	language:Haskell
freshEverywhere	./unison-core/src/Unison/ABT.hs	/^freshEverywhere :: (Foldable f, Var v) => Term f v a -> v -> v$/;"	ft	signature:((Foldable f, Var v) => Term f v a -> v -> v)	line:272	language:Haskell
freshId	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  freshId (SymbolC _ s) = Var.freshId s$/;"	fi	instance:Var SymbolC	line:959	language:Haskell
freshId	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^data Env v loc = Env { freshId :: Word64, ctx :: Context v loc }$/;"	c_a	cons:Env.Env	line:123	language:Haskell
freshId	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  freshId v = Var.freshId (underlying v)$/;"	fi	instance:Var v => Var (TypeVar b v)	line:41	language:Haskell
freshId	./unison-core/src/Unison/Symbol.hs	/^  freshId (Symbol id _) = id$/;"	fi	instance:Var Symbol	line:23	language:Haskell
freshId	./unison-core/src/Unison/Var.hs	/^  freshId :: v -> Word64$/;"	ft	signature:(v -> Word64)	class:Var	line:27	language:Haskell
freshIn	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  freshIn vs (SymbolC i s) =$/;"	fi	instance:ABT-Var SymbolC	line:953	language:Haskell
freshIn	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  freshIn s v = ABT.freshIn (Set.map underlying s) <$> v$/;"	fi	instance:ABT-Var v => ABT-Var (TypeVar b v)	line:36	language:Haskell
freshIn	./unison-core/src/Unison/ABT.hs	/^  freshIn :: Set v -> v -> v$/;"	ft	signature:(Set v -> v -> v)	class:Var	line:45	language:Haskell
freshIn	./unison-core/src/Unison/ABT.hs	/^  freshIn s v = freshIn (Set.map unvar s) <$> v$/;"	fi	instance:Var v => Var (V v)	line:54	language:Haskell
freshIn	./unison-core/src/Unison/Symbol.hs	/^  freshIn vs s | Set.null vs || Set.notMember s vs = s -- already fresh!$/;"	fi	instance:ABT-Var Symbol	line:16	language:Haskell
freshIn	./unison-core/src/Unison/Var.hs	/^freshIn :: ABT.Var v => Set v -> v -> v$/;"	ft	signature:(ABT.Var v => Set v -> v -> v)	line:30	language:Haskell
freshInBoth	./unison-core/src/Unison/ABT.hs	/^freshInBoth :: Var v => Term f v a -> Term f v a -> v -> v$/;"	ft	signature:(Var v => Term f v a -> Term f v a -> v -> v)	line:266	language:Haskell
freshNamed	./unison-core/src/Unison/Var.hs	/^freshNamed :: Var v => Set v -> Text -> v$/;"	ft	signature:(Var v => Set v -> Text -> v)	line:141	language:Haskell
freshen	./unison-core/src/Unison/ABT.hs	/^  Subst { freshen :: forall m v' . Monad m => (v -> m v') -> m v'$/;"	c_a	cons:Subst.Subst	line:457	language:Haskell
freshenId	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  freshenId n (SymbolC i s) = SymbolC i (Var.freshenId n s)$/;"	fi	instance:Var SymbolC	line:960	language:Haskell
freshenId	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  freshenId id v = Var.freshenId id <$> v$/;"	fi	instance:Var v => Var (TypeVar b v)	line:42	language:Haskell
freshenId	./unison-core/src/Unison/Symbol.hs	/^  freshenId id (Symbol _ n) = Symbol id n$/;"	fi	instance:Var Symbol	line:24	language:Haskell
freshenId	./unison-core/src/Unison/Var.hs	/^  freshenId :: Word64 -> v -> v$/;"	ft	signature:(Word64 -> v -> v)	class:Var	line:28	language:Haskell
freshenS	./unison-core/src/Unison/ABT.hs	/^freshenS :: (Var v, MonadState (Set v) m) => v -> m v$/;"	ft	signature:((Var v, MonadState (Set v) m) => v -> m v)	line:290	language:Haskell
freshenS'	./unison-core/src/Unison/ABT.hs	/^freshenS' :: (Var v, MonadState s m) => Lens' s (Set v) -> v -> m v$/;"	ft	signature:((Var v, MonadState s m) => Lens' s (Set v) -> v -> m v)	line:295	language:Haskell
freshenTypeVar	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^freshenTypeVar :: Var v => TypeVar v loc -> M v loc v$/;"	ft	signature:(Var v => TypeVar v loc -> M v loc v)	line:512	language:Haskell
freshenVar	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^freshenVar :: Var v => v -> M v0 loc v$/;"	ft	signature:(Var v => v -> M v0 loc v)	line:506	language:Haskell
freshes	./unison-core/src/Unison/ABT.hs	/^freshes :: Var v => Term f v a -> [v] -> [v]$/;"	ft	signature:(Var v => Term f v a -> [v] -> [v])	line:282	language:Haskell
freshes'	./unison-core/src/Unison/ABT.hs	/^freshes' :: Var v => Set v -> [v] -> [v]$/;"	ft	signature:(Var v => Set v -> [v] -> [v])	line:285	language:Haskell
from	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^    { from :: Hash$/;"	c_a	cons:Entry.Entry	line:13	language:Haskell
fromAbsoluteSplit	./parser-typechecker/src/Unison/Codebase/Path.hs	/^fromAbsoluteSplit :: (Absolute, a) -> (Path, a)$/;"	ft	signature:((Absolute, a) -> (Path, a))	line:220	language:Haskell
fromBase32Hex	./unison-core/src/Unison/Hash.hs	/^fromBase32Hex :: Text -> Maybe Hash$/;"	ft	signature:(Text -> Maybe Hash)	line:67	language:Haskell
fromByteString	./parser-typechecker/src/Unison/Util/Bytes.hs	/^fromByteString :: B.ByteString -> Bytes$/;"	ft	signature:(B.ByteString -> Bytes)	line:27	language:Haskell
fromBytes	./unison-core/src/Unison/Hash.hs	/^  fromBytes = fromBytesImpl$/;"	fi	instance:H-Accumulate Hash	line:51	language:Haskell
fromBytes	./unison-core/src/Unison/Hash.hs	/^fromBytes :: ByteString -> Hash$/;"	ft	signature:(ByteString -> Hash)	line:105	language:Haskell
fromBytes	./unison-core/src/Unison/Hashable.hs	/^  fromBytes :: ByteString -> h$/;"	ft	signature:(ByteString -> h)	class:Accumulate	line:21	language:Haskell
fromBytesImpl	./unison-core/src/Unison/Hash.hs	/^fromBytesImpl :: ByteString -> Hash$/;"	ft	signature:(ByteString -> Hash)	line:30	language:Haskell
fromHQ	./unison-core/src/Unison/HashQualified'.hs	/^fromHQ :: HQ.HashQualified' n -> Maybe (HashQualified' n)$/;"	ft	signature:(HQ.HashQualified' n -> Maybe (HashQualified' n))	line:30	language:Haskell
fromHash	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^fromHash :: Int -> Branch.Hash -> ShortBranchHash$/;"	ft	signature:(Int -> Branch.Hash -> ShortBranchHash)	line:20	language:Haskell
fromList	./parser-typechecker/src/Unison/Codebase/Path.hs	/^fromList :: [NameSegment] -> Path$/;"	ft	signature:([NameSegment] -> Path)	line:240	language:Haskell
fromList	./parser-typechecker/src/Unison/Util/Star3.hs	/^fromList :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => [(fact, d1, d2, d3)] -> Star3 fact d1 d2 d3)	line:80	language:Haskell
fromList	./unison-core/src/Unison/Util/Relation.hs	/^fromList :: (Ord a, Ord b) => [(a, b)] -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => [(a, b)] -> Relation a b)	line:60	language:Haskell
fromList	./unison-core/src/Unison/Util/Relation3.hs	/^fromList :: (Ord a, Ord b, Ord c) => [(a,b,c)] -> Relation3 a b c$/;"	ft	signature:((Ord a, Ord b, Ord c) => [(a, b, c)] -> Relation3 a b c)	line:68	language:Haskell
fromList	./unison-core/src/Unison/Util/Relation4.hs	/^fromList :: (Ord a, Ord b, Ord c, Ord d) => [(a,b,c,d)] -> Relation4 a b c d$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => [(a, b, c, d)] -> Relation4 a b c d)	line:44	language:Haskell
fromMEnv	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^fromMEnv :: (MEnv v loc -> a) -> M v loc a$/;"	ft	signature:((MEnv v loc -> a) -> M v loc a)	line:446	language:Haskell
fromMap	./unison-core/src/Unison/Util/Relation.hs	/^fromMap :: (Ord a, Ord b) => Map a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Map a b -> Relation a b)	line:444	language:Haskell
fromMaybe	./unison-core/src/Unison/Util/Monoid.hs	/^fromMaybe :: Monoid a => Maybe a -> a$/;"	ft	signature:(Monoid a => Maybe a -> a)	line:13	language:Haskell
fromMultimap	./unison-core/src/Unison/Util/Relation.hs	/^fromMultimap :: (Ord a, Ord b) => Map a (Set b) -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Map a (Set b) -> Relation a b)	line:447	language:Haskell
fromName	./parser-typechecker/src/Unison/Codebase/Path.hs	/^fromName :: Name -> Path$/;"	ft	signature:(Name -> Path)	line:285	language:Haskell
fromName	./unison-core/src/Unison/HashQualified'.hs	/^fromName :: n -> HashQualified' n$/;"	ft	signature:(n -> HashQualified' n)	line:90	language:Haskell
fromName	./unison-core/src/Unison/HashQualified.hs	/^fromName :: n -> HashQualified' n$/;"	ft	signature:(n -> HashQualified' n)	line:130	language:Haskell
fromName'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^fromName' :: Name -> Path'$/;"	ft	signature:(Name -> Path')	line:288	language:Haskell
fromNameHash	./unison-core/src/Unison/HashQualified.hs	/^fromNameHash :: Maybe Name -> Maybe ShortHash -> HashQualified$/;"	ft	signature:(Maybe Name -> Maybe ShortHash -> HashQualified)	line:70	language:Haskell
fromNamedReference	./unison-core/src/Unison/HashQualified'.hs	/^fromNamedReference :: n -> Reference -> HashQualified' n$/;"	ft	signature:(n -> Reference -> HashQualified' n)	line:87	language:Haskell
fromNamedReference	./unison-core/src/Unison/HashQualified.hs	/^fromNamedReference :: n -> Reference -> HashQualified' n$/;"	ft	signature:(n -> Reference -> HashQualified' n)	line:118	language:Haskell
fromNamedReferent	./unison-core/src/Unison/HashQualified'.hs	/^fromNamedReferent :: n -> Referent -> HashQualified' n$/;"	ft	signature:(n -> Referent -> HashQualified' n)	line:83	language:Haskell
fromNamedReferent	./unison-core/src/Unison/HashQualified.hs	/^fromNamedReferent :: n -> Referent -> HashQualified' n$/;"	ft	signature:(n -> Referent -> HashQualified' n)	line:114	language:Haskell
fromNames	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^fromNames :: Names0 -> [SearchResult]$/;"	ft	signature:(Names0 -> [SearchResult])	line:71	language:Haskell
fromNames	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^fromNames :: Int -> Names -> PrettyPrintEnv$/;"	ft	signature:(Int -> Names -> PrettyPrintEnv)	line:36	language:Haskell
fromNamesDecl	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^fromNamesDecl :: Int -> Names -> PrettyPrintEnvDecl$/;"	ft	signature:(Int -> Names -> PrettyPrintEnvDecl)	line:45	language:Haskell
fromNestedDom	./unison-core/src/Unison/Util/Relation3.hs	/^fromNestedDom :: (Ord a, Ord b, Ord c) => Relation (a,b) c -> Relation3 a b c$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation (a, b) c -> Relation3 a b c)	line:63	language:Haskell
fromNestedRan	./unison-core/src/Unison/Util/Relation3.hs	/^fromNestedRan :: (Ord a, Ord b, Ord c) => Relation a (b,c) -> Relation3 a b c$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a (b, c) -> Relation3 a b c)	line:65	language:Haskell
fromOverHere	./parser-typechecker/src/Unison/PrintError.hs	/^fromOverHere src spots0 removing =$/;"	fi	line:85	language:Haskell
fromOverHere'	./parser-typechecker/src/Unison/PrintError.hs	/^fromOverHere' s spots0 removing =$/;"	fi	line:80	language:Haskell
fromParsing	./parser-typechecker/src/Unison/Result.hs	/^fromParsing (Left e) = do$/;"	fi	line:78	language:Haskell
fromPattern	./unison-core/src/Unison/HashQualified.hs	/^fromPattern :: Reference -> Int -> HashQualified$/;"	ft	signature:(Reference -> Int -> HashQualified)	line:127	language:Haskell
fromReference	./unison-core/src/Unison/HashQualified.hs	/^fromReference :: Reference -> HashQualified$/;"	ft	signature:(Reference -> HashQualified)	line:124	language:Haskell
fromReferent	./unison-core/src/Unison/HashQualified.hs	/^fromReferent :: Referent -> HashQualified$/;"	ft	signature:(Referent -> HashQualified)	line:121	language:Haskell
fromReferent	./unison-core/src/Unison/Term.hs	/^fromReferent :: Ord v$/;"	ft	signature:(Ord v => a -> Referent -> Term2 vt at ap v a)	line:950	language:Haskell
fromSet	./unison-core/src/Unison/Util/Relation.hs	/^fromSet :: (Ord a, Ord b) => Set (a,b) -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Set (a, b) -> Relation a b)	line:462	language:Haskell
fromShortHash	./unison-core/src/Unison/Reference.hs	/^fromShortHash :: ShortHash -> Maybe Reference$/;"	ft	signature:(ShortHash -> Maybe Reference)	line:78	language:Haskell
fromSplit'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^fromSplit' :: (Path', a) -> (Path, a)$/;"	ft	signature:((Path', a) -> (Path, a))	line:216	language:Haskell
fromString	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  fromString s = AnnotatedText . pure $ (s, Nothing)$/;"	fi	instance:IsString (AnnotatedText a)	line:197	language:Haskell
fromString	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  fromString s = AnnotatedExcerpt 1 s mempty$/;"	fi	instance:IsString (AnnotatedExcerpt a)	line:200	language:Haskell
fromString	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  fromString s = lit' (foldMap chDelta s) (fromString s)$/;"	fi	instance:IsString s => IsString (Pretty s)	line:633	language:Haskell
fromString	./unison-core/src/Unison/Codebase/NameSegment.hs	/^  fromString = NameSegment . Text.pack$/;"	fi	instance:IsString NameSegment	line:43	language:Haskell
fromString	./unison-core/src/Unison/HashQualified'.hs	/^fromString :: String -> Maybe HashQualified$/;"	ft	signature:(String -> Maybe HashQualified)	line:74	language:Haskell
fromString	./unison-core/src/Unison/HashQualified'.hs	/^  fromString = unsafeFromText . Text.pack$/;"	fi	instance:IsString HashQualified	line:115	language:Haskell
fromString	./unison-core/src/Unison/HashQualified.hs	/^fromString :: String -> Maybe HashQualified$/;"	ft	signature:(String -> Maybe HashQualified)	line:88	language:Haskell
fromString	./unison-core/src/Unison/Name.hs	/^  fromString = unsafeFromText . Text.pack$/;"	fi	instance:IsString Name	line:135	language:Haskell
fromString	./unison-core/src/Unison/ShortHash.hs	/^fromString :: String -> Maybe ShortHash$/;"	ft	signature:(String -> Maybe ShortHash)	line:70	language:Haskell
fromSuffixNames	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^fromSuffixNames :: Int -> Names -> PrettyPrintEnv$/;"	ft	signature:(Int -> Names -> PrettyPrintEnv)	line:42	language:Haskell
fromTerm	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^fromTerm :: forall a v . (Monoid a, Var v) => (v -> v) -> Term v a -> ANF v a$/;"	ft	signature:(forall a v . (Monoid a, Var v) => (v -> v) -> Term v a -> ANF v a)	line:104	language:Haskell
fromTerm'	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^fromTerm' :: (Monoid a, Var v) => (v -> v) -> Term v a -> Term v a$/;"	ft	signature:((Monoid a, Var v) => (v -> v) -> Term v a -> Term v a)	line:101	language:Haskell
fromTermNames	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^fromTermNames :: [(Referent,HashQualified)] -> PrettyPrintEnv$/;"	ft	signature:([(Referent, HashQualified)] -> PrettyPrintEnv)	line:93	language:Haskell
fromTerms	./unison-core/src/Unison/Names2.hs	/^fromTerms :: Ord n => [(n, Referent)] -> Names' n$/;"	ft	signature:(Ord n => [(n, Referent)] -> Names' n)	line:277	language:Haskell
fromText	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^fromText :: Text -> Maybe Entry$/;"	ft	signature:(Text -> Maybe Entry)	line:18	language:Haskell
fromText	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^fromText :: Text -> Maybe ShortBranchHash$/;"	ft	signature:(Text -> Maybe ShortBranchHash)	line:26	language:Haskell
fromText	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^fromText _ = Nothing$/;"	fi	line:29	language:Haskell
fromText	./unison-core/src/Unison/HashQualified'.hs	/^fromText :: Text -> Maybe HashQualified$/;"	ft	signature:(Text -> Maybe HashQualified)	line:64	language:Haskell
fromText	./unison-core/src/Unison/HashQualified.hs	/^fromText :: Text -> Maybe HashQualified$/;"	ft	signature:(Text -> Maybe HashQualified)	line:96	language:Haskell
fromText	./unison-core/src/Unison/Reference.hs	/^fromText :: Text -> Either String Reference$/;"	ft	signature:(Text -> Either String Reference)	line:142	language:Haskell
fromText	./unison-core/src/Unison/Referent.hs	/^fromText :: Text -> Maybe Referent$/;"	ft	signature:(Text -> Maybe Referent)	line:92	language:Haskell
fromText	./unison-core/src/Unison/ShortHash.hs	/^fromText :: Text -> Maybe ShortHash$/;"	ft	signature:(Text -> Maybe ShortHash)	line:38	language:Haskell
fromTypeNames	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^fromTypeNames :: [(Reference,HashQualified)] -> PrettyPrintEnv$/;"	ft	signature:([(Reference, HashQualified)] -> PrettyPrintEnv)	line:88	language:Haskell
fromTypes	./unison-core/src/Unison/Names2.hs	/^fromTypes :: Ord n => [(n, Reference)] -> Names' n$/;"	ft	signature:(Ord n => [(n, Reference)] -> Names' n)	line:280	language:Haskell
fromUnisonFile	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^fromUnisonFile :: (Var v, Monad m) => UnisonFile v a -> CodeLookup v m a$/;"	ft	signature:((Var v, Monad m) => UnisonFile v a -> CodeLookup v m a)	line:15	language:Haskell
fromVar	./unison-core/src/Unison/HashQualified.hs	/^fromVar :: Var v => v -> Maybe HashQualified$/;"	ft	signature:(Var v => v -> Maybe HashQualified)	line:136	language:Haskell
fromVar	./unison-core/src/Unison/Name.hs	/^fromVar :: Var v => v -> Name$/;"	ft	signature:(Var v => v -> Name)	line:66	language:Haskell
fromWord8s	./parser-typechecker/src/Unison/Util/Bytes.hs	/^fromWord8s :: [Word8] -> Bytes$/;"	ft	signature:([Word8] -> Bytes)	line:74	language:Haskell
ft	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , ft           :: C.Type v loc$/;"	c_a	cons:TypeError.FunctionApplication	line:46	language:Haskell
ft	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                           , ft   :: C.Type v loc$/;"	c_a	cons:TypeError.NotFunctionApplication	line:56	language:Haskell
functionResult	./unison-core/src/Unison/Type.hs	/^functionResult :: Type v a -> Maybe (Type v a)$/;"	ft	signature:(Type v a -> Maybe (Type v a))	line:495	language:Haskell
futureHistory	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data HistLog = HistLog {pastHistory, futureHistory :: [[Grapheme]]}$/;"	c_a	cons:HistLog.HistLog	line:13	language:Haskell
futureRedo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^data Undo = Undo {pastUndo, futureRedo :: [InsertMode]}$/;"	c_a	cons:Undo.Undo	line:9	language:Haskell
fuzzyComplete	./parser-typechecker/src/Unison/CommandLine.hs	/^fuzzyComplete :: String -> [String] -> [Line.Completion]$/;"	ft	signature:(String -> [String] -> [Line.Completion])	line:135	language:Haskell
fuzzyCompleteHashQualified	./parser-typechecker/src/Unison/CommandLine.hs	/^fuzzyCompleteHashQualified :: Names0 -> String -> [Line.Completion]$/;"	ft	signature:(Names0 -> String -> [Line.Completion])	line:125	language:Haskell
fuzzyDefinitionQueryArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^fuzzyDefinitionQueryArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1213	language:Haskell
fuzzyFindInBranch	./parser-typechecker/src/Unison/Util/Find.hs	/^fuzzyFindInBranch :: Names0$/;"	ft	signature:(Names0 -> HashQualified -> [(SearchResult, P.Pretty P.ColorText)])	line:129	language:Haskell
fuzzyFindMatchArray	./parser-typechecker/src/Unison/Util/Find.hs	/^fuzzyFindMatchArray :: forall a.$/;"	ft	signature:(forall a. String -> [a] -> (a -> String) -> [(RE.MatchArray, (a, P.Pretty P.ColorText))])	line:81	language:Haskell
fuzzyFinder	./parser-typechecker/src/Unison/Util/Find.hs	/^fuzzyFinder :: forall a.$/;"	ft	signature:(forall a. String -> [a] -> (a -> String) -> [(a, P.Pretty P.ColorText)])	line:34	language:Haskell
fuzzyNameDistance	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^fuzzyNameDistance :: Name -> Name -> Maybe _ -- MatchArray$/;"	ft	signature:(Name -> Name -> Maybe _)	line:1766	language:Haskell
gBaseChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data Grapheme = Grapheme {gBaseChar :: Char,$/;"	c_a	cons:Grapheme.Grapheme	line:76	language:Haskell
gWidth	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^gWidth :: Grapheme -> Int$/;"	ft	signature:(Grapheme -> Int)	line:24	language:Haskell
generalMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^generalMismatch :: (Var v, Ord loc) => Ex.ErrorExtractor v loc (TypeError v loc)$/;"	ft	signature:((Var v, Ord loc) => Ex.ErrorExtractor v loc (TypeError v loc))	line:154	language:Haskell
generalize	./unison-core/src/Unison/Type.hs	/^generalize :: Ord v => [v] -> Type v a -> Type v a$/;"	ft	signature:(Ord v => [v] -> Type v a -> Type v a)	line:374	language:Haskell
generalize'	./unison-core/src/Unison/Type.hs	/^generalize' :: Var v => Var.Type -> Type v a -> Type v a$/;"	ft	signature:(Var v => Var.Type -> Type v a -> Type v a)	line:369	language:Haskell
generalizeAndUnTypeVar	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^generalizeAndUnTypeVar :: Var v => Type v a -> Type.Type v a$/;"	ft	signature:(Var v => Type v a -> Type.Type v a)	line:789	language:Haskell
generalizeExistentials	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^generalizeExistentials :: (Var v, Ord loc) => [Element v loc] -> Type v loc -> Type v loc$/;"	ft	signature:((Var v, Ord loc) => [Element v loc] -> Type v loc -> Type v loc)	line:1275	language:Haskell
generalizeExistentials'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^generalizeExistentials' t =$/;"	fi	line:795	language:Haskell
generalizeLowercase	./unison-core/src/Unison/Type.hs	/^generalizeLowercase :: Var v => Set v -> Type v a -> Type v a$/;"	ft	signature:(Var v => Set v -> Type v a -> Type v a)	line:509	language:Haskell
generalizeTypeSignatures	./unison-core/src/Unison/Term.hs	/^generalizeTypeSignatures :: (Var vt, Var v) => Term' vt v a -> Term' vt v a$/;"	ft	signature:((Var vt, Var v) => Term' vt v a -> Term' vt v a)	line:392	language:Haskell
generalizedDependencies	./unison-core/src/Unison/Pattern.hs	/^generalizedDependencies literalType dataConstructor dataType effectConstructor effectType$/;"	fi	line:178	language:Haskell
generalizedDependencies	./unison-core/src/Unison/PatternP.hs	/^generalizedDependencies = P.generalizedDependencies$/;"	fi	line:53	language:Haskell
generalizedDependencies	./unison-core/src/Unison/Term.hs	/^generalizedDependencies termRef typeRef literalType dataConstructor dataType effectConstructor effectType$/;"	fi	line:848	language:Haskell
generateConstructorMapping	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^generateConstructorMapping oldComponent newComponent = Map.fromList$/;"	fi	line:90	language:Haskell
generateConstructorRefs	./unison-core/src/Unison/DataDeclaration.hs	/^generateConstructorRefs hashCtor rid n =$/;"	fi	line:86	language:Haskell
generateRecordAccessors	./unison-core/src/Unison/DataDeclaration.hs	/^generateRecordAccessors fields typename typ =$/;"	fi	line:95	language:Haskell
get	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^  get :: Get a,$/;"	c_a	cons:Format.Format	line:18	language:Haskell
get	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  | Ranged { get :: a, start :: Int, end :: Int }$/;"	c_a	cons:Ranged.Ranged	line:66	language:Haskell
get	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    get :: m s$/;"	ft	signature:(m s)	class:MonadState	line:52	language:Haskell
get	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    get = StateT $ \\s -> return $ \\f -> f s s$/;"	fi	instance:Monad m => MonadState s (StateT s m)	line:109	language:Haskell
get	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    get = lift get$/;"	fi	instance:(MonadState s m, MonadTrans t, Monad (t m)) => MonadState s (t m)	line:114	language:Haskell
get	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    get = ask >>= liftIO . readIORef$/;"	fi	instance:MonadIO m => MonadState s (ReaderT (IORef s) m)	line:120	language:Haskell
getABT	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getABT getVar getA getF = getList getVar >>= go [] where$/;"	fi	line:338	language:Haskell
getAbilities	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getAbilities :: M v loc [Type v loc]$/;"	ft	signature:(M v loc [Type v loc])	line:624	language:Haskell
getActions	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^getActions :: Capability Actions$/;"	ft	signature:(Capability Actions)	line:42	language:Haskell
getAt	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^getAt :: Path$/;"	ft	signature:(Path -> Branch m -> Maybe (Branch m))	line:566	language:Haskell
getAt	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^getAt :: Functor m => Path.Absolute -> Action m i v (Branch m)$/;"	ft	signature:(Functor m => Path.Absolute -> Action m i v (Branch m))	line:1957	language:Haskell
getAt'	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^getAt' :: Path -> Branch m -> Branch m$/;"	ft	signature:(Path -> Branch m -> Branch m)	line:575	language:Haskell
getAt0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^getAt0 :: Path -> Branch0 m -> Branch0 m$/;"	ft	signature:(Path -> Branch0 m -> Branch0 m)	line:578	language:Haskell
getAttribute	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getAttribute :: HANDLE -> IO WORD$/;"	ft	signature:(HANDLE -> IO WORD)	line:516	language:Haskell
getAvailableWidth	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^getAvailableWidth :: IO Int$/;"	ft	signature:(IO Int)	line:45	language:Haskell
getBlockOfChars	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^getBlockOfChars :: Handle -> IO String$/;"	ft	signature:(Handle -> IO String)	line:237	language:Haskell
getBoolean	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getBoolean :: MonadGet m => m Bool$/;"	ft	signature:(MonadGet m => m Bool)	line:208	language:Haskell
getBooleanMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | BooleanMismatch { getBooleanMismatch :: BooleanMismatch$/;"	c_a	cons:TypeError.BooleanMismatch	line:33	language:Haskell
getBranch	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getBranch :: Path.Split -> Branch0 m -> Maybe (Branch m)$/;"	ft	signature:(Path.Split -> Branch0 m -> Maybe (Branch m))	line:91	language:Haskell
getBranchForHash	./parser-typechecker/src/Unison/Codebase.hs	/^           , getBranchForHash   :: Branch.Hash -> m (Branch m)$/;"	c_a	cons:Codebase.Codebase	line:58	language:Haskell
getBranchStar	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getBranchStar :: (Ord a, Ord n, MonadGet m) => m a -> m n -> m (Branch.Star a n)$/;"	ft	signature:((Ord a, Ord n, MonadGet m) => m a -> m n -> m (Branch.Star a n))	line:664	language:Haskell
getBufferSize	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getBufferSize :: HANDLE -> IO Layout$/;"	ft	signature:(HANDLE -> IO Layout)	line:202	language:Haskell
getCausal0	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getCausal0 :: MonadGet m => m a -> m (Causal.Raw h a)$/;"	ft	signature:(MonadGet m => m a -> m (Causal.Raw h a))	line:98	language:Haskell
getChar	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getChar :: MonadGet m => m Char$/;"	ft	signature:(MonadGet m => m Char)	line:676	language:Haskell
getChildBranch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^getChildBranch :: NameSegment -> Branch0 m -> Branch m$/;"	ft	signature:(NameSegment -> Branch0 m -> Branch m)	line:656	language:Haskell
getCodePage	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getCodePage :: IO CodePage$/;"	ft	signature:(IO CodePage)	line:489	language:Haskell
getCodebaseDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^getCodebaseDir :: Maybe FilePath -> IO FilePath$/;"	ft	signature:(Maybe FilePath -> IO FilePath)	line:180	language:Haskell
getCodebaseOrExit	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^getCodebaseOrExit :: Maybe FilePath -> IO (Codebase IO Symbol Ann)$/;"	ft	signature:(Maybe FilePath -> IO (Codebase IO Symbol Ann))	line:158	language:Haskell
getConfigFilePath	./parser-typechecker/unison/Main.hs	/^getConfigFilePath :: Maybe FilePath -> IO FilePath$/;"	ft	signature:(Maybe FilePath -> IO FilePath)	line:246	language:Haskell
getConstructorType	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getConstructorType :: MonadGet m => m CT.ConstructorType$/;"	ft	signature:(MonadGet m => m CT.ConstructorType)	line:270	language:Haskell
getConstructorType'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getConstructorType' :: Var v$/;"	ft	signature:(Var v => Unknown -> (Reference -> M v loc (DataDeclaration' v loc)) -> Reference -> Int -> M v loc (Type v loc))	line:666	language:Haskell
getContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getContext :: M v loc (Context v loc)$/;"	ft	signature:(M v loc (Context v loc))	line:449	language:Haskell
getDataConstructorType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getDataConstructorType :: (Var v, Ord loc) => Reference -> Int -> M v loc (Type v loc)$/;"	ft	signature:((Var v, Ord loc) => Reference -> Int -> M v loc (Type v loc))	line:657	language:Haskell
getDataDeclaration	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getDataDeclaration :: (MonadGet m, Ord v) => m v -> m a -> m (DataDeclaration' v a)$/;"	ft	signature:((MonadGet m, Ord v) => m v -> m a -> m (DataDeclaration' v a))	line:722	language:Haskell
getDataDeclaration	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getDataDeclaration :: Reference -> M v loc (DataDeclaration' v loc)$/;"	ft	signature:(Reference -> M v loc (DataDeclaration' v loc))	line:643	language:Haskell
getDataDeclarations	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getDataDeclarations :: M v loc (DataDeclarations v loc)$/;"	ft	signature:(M v loc (DataDeclarations v loc))	line:618	language:Haskell
getDecl	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^getDecl :: (MonadIO m, Ord v)$/;"	ft	signature:((MonadIO m, Ord v) => S.Get v -> S.Get a -> CodebasePath -> Reference.Id -> m (Maybe (DD.Decl v a)))	line:520	language:Haskell
getDecl'	./parser-typechecker/src/Unison/UnisonFile.hs	/^getDecl' :: Ord v => TypecheckedUnisonFile v a -> v -> Maybe (DD.Decl v a)$/;"	ft	signature:(Ord v => TypecheckedUnisonFile v a -> v -> Maybe (DD.Decl v a))	line:124	language:Haskell
getDirectoryContents	./yaks/haskeline/System/Console/Haskeline/Directory.hsc	/^getDirectoryContents :: FilePath -> IO [FilePath]$/;"	ft	signature:(FilePath -> IO [FilePath])	line:32	language:Haskell
getEdits	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getEdits :: MonadGet m => m Patch$/;"	ft	signature:(MonadGet m => m Patch)	line:766	language:Haskell
getEffectConstructorType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getEffectConstructorType :: (Var v, Ord loc) => Reference -> Int -> M v loc (Type v loc)$/;"	ft	signature:((Var v, Ord loc) => Reference -> Int -> M v loc (Type v loc))	line:660	language:Haskell
getEffectDeclaration	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getEffectDeclaration :: (MonadGet m, Ord v) => m v -> m a -> m (EffectDeclaration' v a)$/;"	ft	signature:((MonadGet m, Ord v) => m v -> m a -> m (EffectDeclaration' v a))	line:744	language:Haskell
getEffectDeclaration	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getEffectDeclaration :: Reference -> M v loc (EffectDeclaration' v loc)$/;"	ft	signature:(Reference -> M v loc (EffectDeclaration' v loc))	line:650	language:Haskell
getEffectDeclarations	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^getEffectDeclarations :: M v loc (EffectDeclarations v loc)$/;"	ft	signature:(M v loc (EffectDeclarations v loc))	line:621	language:Haskell
getEither	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getEither :: MonadGet m => m a -> m b -> m (Either a b)$/;"	ft	signature:(MonadGet m => m a -> m b -> m (Either a b))	line:752	language:Haskell
getEndangeredDependents	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^getEndangeredDependents :: forall m. Monad m$/;"	ft	signature:(forall m. Monad m => (Reference -> m (Set Reference)) -> Names0 -> Names0 -> m (Names0, Names0))	line:2037	language:Haskell
getEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^getEvent :: Handle -> TreeMap Char Key -> TChan Event -> IO Event$/;"	ft	signature:(Handle -> TreeMap Char Key -> TChan Event -> IO Event)	line:228	language:Haskell
getEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getEvent :: HANDLE -> TChan Event -> IO Event$/;"	ft	signature:(HANDLE -> TChan Event -> IO Event)	line:49	language:Haskell
getExistentialMismatch	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | ExistentialMismatch { getExistentialMismatch :: ExistentialMismatch$/;"	c_a	cons:TypeError.ExistentialMismatch	line:38	language:Haskell
getExternalPrint	./yaks/haskeline/System/Console/Haskeline.hs	/^getExternalPrint :: MonadException m => InputT m (String -> IO ())$/;"	ft	signature:(MonadException m => InputT m (String -> IO ()))	line:328	language:Haskell
getFloat	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getFloat :: MonadGet m => m Double$/;"	ft	signature:(MonadGet m => m Double)	line:189	language:Haskell
getFolded	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getFolded :: MonadGet m => (b -> a -> b) -> b -> m a -> m b$/;"	ft	signature:(MonadGet m => (b -> a -> b) -> b -> m a -> m b)	line:302	language:Haskell
getFromBytes	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^getFromBytes :: Get a -> ByteString -> Maybe a$/;"	ft	signature:(Get a -> ByteString -> Maybe a)	line:22	language:Haskell
getFromFile	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^getFromFile :: Get a -> FilePath -> IO (Maybe a)$/;"	ft	signature:(Get a -> FilePath -> IO (Maybe a))	line:26	language:Haskell
getFromFile'	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^getFromFile' :: Get a -> FilePath -> IO (Either String a)$/;"	ft	signature:(Get a -> FilePath -> IO (Either String a))	line:31	language:Haskell
getHash	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getHash :: MonadGet m => m Hash$/;"	ft	signature:(MonadGet m => m Hash)	line:220	language:Haskell
getHaskellHandle	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^getHaskellHandle :: Text -> UIO (Maybe Handle)$/;"	ft	signature:(Text -> UIO (Maybe Handle))	line:154	language:Haskell
getHaskellHandleOrThrow	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^getHaskellHandleOrThrow :: Text -> UIO Handle$/;"	ft	signature:(Text -> UIO Handle)	line:160	language:Haskell
getHaskellSocket	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^getHaskellSocket :: Text -> UIO (Maybe Net.Socket)$/;"	ft	signature:(Text -> UIO (Maybe Net.Socket))	line:163	language:Haskell
getHaskellSocketOrThrow	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^getHaskellSocketOrThrow :: Text -> UIO Net.Socket$/;"	ft	signature:(Text -> UIO Net.Socket)	line:169	language:Haskell
getHistory	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^getHistory :: MonadIO m => InputT m History$/;"	ft	signature:(MonadIO m => InputT m History)	line:62	language:Haskell
getHomeDirectory	./yaks/haskeline/System/Console/Haskeline/Directory.hsc	/^getHomeDirectory :: IO FilePath$/;"	ft	signature:(IO FilePath)	line:57	language:Haskell
getInputChar	./yaks/haskeline/System/Console/Haskeline.hs	/^getInputChar :: MonadException m => String -- ^ The input prompt$/;"	ft	signature:(MonadException m => String -> InputT m (Maybe Char))	line:205	language:Haskell
getInputCmdChar	./yaks/haskeline/System/Console/Haskeline.hs	/^getInputCmdChar :: MonadException m => TermOps -> String -> InputT m (Maybe Char)$/;"	ft	signature:(MonadException m => TermOps -> String -> InputT m (Maybe Char))	line:219	language:Haskell
getInputCmdLine	./yaks/haskeline/System/Console/Haskeline.hs	/^getInputCmdLine :: MonadException m => InsertMode -> TermOps -> String -> InputT m (Maybe String)$/;"	ft	signature:(MonadException m => InsertMode -> TermOps -> String -> InputT m (Maybe String))	line:172	language:Haskell
getInputLine	./yaks/haskeline/System/Console/Haskeline.hs	/^getInputLine :: MonadException m => String -- ^ The input prompt$/;"	ft	signature:(MonadException m => String -> InputT m (Maybe String))	line:144	language:Haskell
getInputLineWithInitial	./yaks/haskeline/System/Console/Haskeline.hs	/^getInputLineWithInitial :: MonadException m$/;"	ft	signature:(MonadException m => String -> (String, String) -> InputT m (Maybe String))	line:163	language:Haskell
getInt	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getInt :: MonadGet m => m Int64$/;"	ft	signature:(MonadGet m => m Int64)	line:201	language:Haskell
getKeyEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getKeyEvent :: Ptr () -> IO InputEvent$/;"	ft	signature:(Ptr () -> IO InputEvent)	line:151	language:Haskell
getKeySequences	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^getKeySequences :: (MonadIO m, MonadReader Prefs m)$/;"	ft	signature:((MonadIO m, MonadReader Prefs m) => Handle -> [(String, Key)] -> m (TreeMap Char Key))	line:105	language:Haskell
getKind	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getKind :: MonadGet m => m Kind$/;"	ft	signature:(MonadGet m => m Kind)	line:362	language:Haskell
getLayout	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    { getLayout :: IO Layout$/;"	c_a	cons:TermOps.TermOps	line:43	language:Haskell
getLength	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getLength ::$/;"	ft	signature:((MonadGet m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => m n)	line:168	language:Haskell
getLevel	./parser-typechecker/src/Unison/Util/Logger.hs	/^         , getLevel :: !Level$/;"	c_a	cons:Logger.Logger	line:30	language:Haskell
getLinesLeft	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^getLinesLeft :: ActionM Int$/;"	ft	signature:(ActionM Int)	line:311	language:Haskell
getLinks	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^getLinks :: (Var v, Monad m)$/;"	ft	signature:((Var v, Monad m) => Input -> Path.HQSplit' -> Either (Set Reference) (Maybe String) -> Action' m v (Either (Output v) (PPE.PrettyPrintEnv, [(HQ.HashQualified, Reference, Maybe (Type v Ann))])))	line:1597	language:Haskell
getLinks	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^getLinks input src mdTypeStr = do$/;"	fi	line:1605	language:Haskell
getLinks'	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^getLinks' :: (Var v, Monad m)$/;"	ft	signature:((Var v, Monad m) => Path.HQSplit' -> Maybe (Set Reference) -> Action' m v ((PPE.PrettyPrintEnv, [(HQ.HashQualified, Reference, Maybe (Type v Ann))])))	line:1614	language:Haskell
getList	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getList :: MonadGet m => m a -> m [a]$/;"	ft	signature:(MonadGet m => m a -> m [a])	line:306	language:Haskell
getLocaleChar	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            getLocaleChar :: MaybeT IO Char,$/;"	c_a	cons:FileOps.FileOps	line:75	language:Haskell
getLocaleLine	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            getLocaleLine :: MaybeT IO String,$/;"	c_a	cons:FileOps.FileOps	line:74	language:Haskell
getMainTerm	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^getMainTerm loadTypeOfTerm parseNames0 mainName =$/;"	fi	line:40	language:Haskell
getMap	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)$/;"	ft	signature:((MonadGet m, Ord a) => m a -> m b -> m (Map a b))	line:600	language:Haskell
getMaybe	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getMaybe :: MonadGet m => m a -> m (Maybe a)$/;"	ft	signature:(MonadGet m => m a -> m (Maybe a))	line:280	language:Haskell
getMaybePatch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^getMaybePatch :: Applicative m => NameSegment -> Branch0 m -> m (Maybe Patch)$/;"	ft	signature:(Applicative m => NameSegment -> Branch0 m -> m (Maybe Patch))	line:667	language:Haskell
getMetadataType	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getMetadataType :: MonadGet m => m Metadata.Type$/;"	ft	signature:(MonadGet m => m Metadata.Type)	line:692	language:Haskell
getMetadataValue	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getMetadataValue :: MonadGet m => m Metadata.Value$/;"	ft	signature:(MonadGet m => m Metadata.Value)	line:698	language:Haskell
getModifier	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getModifier :: MonadGet m => m DataDeclaration.Modifier$/;"	ft	signature:(MonadGet m => m DataDeclaration.Modifier)	line:733	language:Haskell
getMultiByteChar	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getMultiByteChar :: CodePage -> Handle -> MaybeT IO Char$/;"	ft	signature:(CodePage -> Handle -> MaybeT IO Char)	line:499	language:Haskell
getName	./parser-typechecker/src/Unison/Util/Find.hs	/^getName :: SearchResult -> (SearchResult, P.Pretty P.ColorText)$/;"	ft	signature:(SearchResult -> (SearchResult, P.Pretty P.ColorText))	line:138	language:Haskell
getNameSegment	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getNameSegment :: MonadGet m => m NameSegment$/;"	ft	signature:(MonadGet m => m NameSegment)	line:682	language:Haskell
getNames	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^getNames :: PPE.PrettyPrintEnv$/;"	ft	signature:(PPE.PrettyPrintEnv)	line:22	language:Haskell
getNat	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getNat :: MonadGet m => m Word64$/;"	ft	signature:(MonadGet m => m Word64)	line:195	language:Haskell
getNumberOfEvents	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getNumberOfEvents :: HANDLE -> IO Int$/;"	ft	signature:(HANDLE -> IO Int)	line:43	language:Haskell
getOutput	./yaks/haskeline/tests/Pty.hs	/^getOutput :: Fd -> IO B.ByteString$/;"	ft	signature:(Fd -> IO B.ByteString)	line:58	language:Haskell
getOutput	./yaks/haskeline/tests/RunTTY.hs	/^getOutput :: Handle -> IO B.ByteString$/;"	ft	signature:(Handle -> IO B.ByteString)	line:78	language:Haskell
getPair	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getPair :: MonadGet m => m a -> m b -> m (a,b)$/;"	ft	signature:(MonadGet m => m a -> m b -> m (a, b))	line:576	language:Haskell
getPassword	./yaks/haskeline/System/Console/Haskeline.hs	/^getPassword :: MonadException m => Maybe Char -- ^ A masking character; e.g., @Just \\'*\\'@$/;"	ft	signature:(MonadException m => Maybe Char -> String -> InputT m (Maybe String))	line:244	language:Haskell
getPatch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^getPatch :: Applicative m => NameSegment -> Branch0 m -> m Patch$/;"	ft	signature:(Applicative m => NameSegment -> Branch0 m -> m Patch)	line:662	language:Haskell
getPattern	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getPattern :: MonadGet m => m a -> m (Pattern a)$/;"	ft	signature:(MonadGet m => m a -> m (Pattern a))	line:449	language:Haskell
getPolytype	./unison-core/src/Unison/Type.hs	/^newtype Monotype v a = Monotype { getPolytype :: Type v a } deriving Eq$/;"	c_a	cons:Monotype.Monotype	line:84	language:Haskell
getPos	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getPos :: MonadIO m => Draw m Coord$/;"	ft	signature:(MonadIO m => Draw m Coord)	line:270	language:Haskell
getPosition	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^getPosition :: HANDLE -> IO Coord$/;"	ft	signature:(HANDLE -> IO Coord)	line:191	language:Haskell
getPrintableChar	./yaks/haskeline/System/Console/Haskeline.hs	/^getPrintableChar :: FileOps -> IO (Maybe Char)$/;"	ft	signature:(FileOps -> IO (Maybe Char))	line:212	language:Haskell
getRawBranch	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getRawBranch :: MonadGet m => m Branch.Raw$/;"	ft	signature:(MonadGet m => m Branch.Raw)	line:704	language:Haskell
getReference	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getReference :: MonadGet m => m Reference$/;"	ft	signature:(MonadGet m => m Reference)	line:238	language:Haskell
getReferent	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getReferent :: MonadGet m => m Referent$/;"	ft	signature:(MonadGet m => m Referent)	line:262	language:Haskell
getReflog	./parser-typechecker/src/Unison/Codebase.hs	/^           , getReflog          :: m [Reflog.Entry]$/;"	c_a	cons:Codebase.Codebase	line:76	language:Haskell
getRelation	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getRelation :: (MonadGet m, Ord a, Ord b) => m a -> m b -> m (Relation a b)$/;"	ft	signature:((MonadGet m, Ord a, Ord b) => m a -> m b -> m (Relation a b))	line:594	language:Haskell
getResult	./parser-typechecker/src/Unison/Result.hs	/^getResult :: Functor f => ResultT notes f a -> f (Result notes a)$/;"	ft	signature:(Functor f => ResultT notes f a -> f (Result notes a))	line:66	language:Haskell
getRootBranch	./parser-typechecker/src/Unison/Codebase.hs	/^           , getRootBranch      :: m (Branch m)$/;"	c_a	cons:Codebase.Codebase	line:55	language:Haskell
getRootBranch	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^getRootBranch ::$/;"	ft	signature:(MonadIO m => BranchLoadMode -> CodebasePath -> m (Branch m))	line:331	language:Haskell
getScope	./parser-typechecker/src/Unison/Util/Logger.hs	/^  Logger { getScope :: !Scope$/;"	c_a	cons:Logger.Logger	line:28	language:Haskell
getSeqOp	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getSeqOp :: MonadGet m => m SeqOp$/;"	ft	signature:(MonadGet m => m SeqOp)	line:442	language:Haskell
getStar3	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getStar3 getF getD1 getD2 getD3 =$/;"	fi	line:653	language:Haskell
getStateTFunc	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^newtype StateT s m a = StateT { getStateTFunc $/;"	c_a	cons:StateT.StateT	line:71	language:Haskell
getSymbol	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getSymbol :: MonadGet m => m Symbol$/;"	ft	signature:(MonadGet m => m Symbol)	line:400	language:Haskell
getTerm	./parser-typechecker/src/Unison/Codebase.hs	/^  Codebase { getTerm            :: Reference.Id -> m (Maybe (Term v a))$/;"	c_a	cons:Codebase.Codebase	line:48	language:Haskell
getTerm	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getTerm :: Path.HQSplit -> Branch0 m -> Set Referent$/;"	ft	signature:(Path.HQSplit -> Branch0 m -> Set Referent)	line:44	language:Haskell
getTerm	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^      getTerm :: Reference.Id -> m (Maybe (Term v a)),$/;"	c_a	cons:CodeLookup.CodeLookup	line:32	language:Haskell
getTerm	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getTerm :: (MonadGet m, Ord v)$/;"	ft	signature:((MonadGet m, Ord v) => m v -> m a -> m (Term v a))	line:536	language:Haskell
getTermEdit	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getTermEdit :: MonadGet m => m TermEdit$/;"	ft	signature:(MonadGet m => m TermEdit)	line:611	language:Haskell
getTermMetadataAt	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getTermMetadataAt :: (Path.Path, a) -> Referent -> Branch0 m -> Metadata$/;"	ft	signature:((Path.Path, a) -> Referent -> Branch0 m -> Metadata)	line:64	language:Haskell
getTermMetadataHQNamed	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getTermMetadataHQNamed :: (Path.Path, HQSegment) -> Branch0 m -> Metadata.R4 Referent NameSegment$/;"	ft	signature:((Path.Path, HQSegment) -> Branch0 m -> Metadata.R4 Referent NameSegment)	line:52	language:Haskell
getTermsIncludingHistorical	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^getTermsIncludingHistorical (p, hq) b = case Set.toList refs of$/;"	fi	line:2409	language:Haskell
getText	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getText :: MonadGet m => m Text$/;"	ft	signature:(MonadGet m => m Text)	line:180	language:Haskell
getTuple3	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getTuple3 :: MonadGet m => m a -> m b -> m c -> m (a,b,c)$/;"	ft	signature:(MonadGet m => m a -> m b -> m c -> m (a, b, c))	line:588	language:Haskell
getType	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getType :: Path.HQSplit -> Branch0 m -> Set Reference$/;"	ft	signature:(Path.HQSplit -> Branch0 m -> Set Reference)	line:71	language:Haskell
getType	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getType :: (MonadGet m, Ord v)$/;"	ft	signature:((MonadGet m, Ord v) => m v -> m a -> m (Type v a))	line:383	language:Haskell
getTypeByShortHash	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getTypeByShortHash :: SH.ShortHash -> Branch0 m -> Set Reference$/;"	ft	signature:(SH.ShortHash -> Branch0 m -> Set Reference)	line:79	language:Haskell
getTypeDeclaration	./parser-typechecker/src/Unison/Codebase.hs	/^           , getTypeDeclaration :: Reference.Id -> m (Maybe (Decl v a))$/;"	c_a	cons:Codebase.Codebase	line:50	language:Haskell
getTypeDeclaration	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^      getTypeDeclaration :: Reference.Id -> m (Maybe (Decl v a))$/;"	c_a	cons:CodeLookup.CodeLookup	line:33	language:Haskell
getTypeEdit	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^getTypeEdit :: MonadGet m => m TypeEdit$/;"	ft	signature:(MonadGet m => m TypeEdit)	line:626	language:Haskell
getTypeMetadataAt	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getTypeMetadataAt :: (Path.Path, a) -> Reference -> Branch0 m -> Metadata$/;"	ft	signature:((Path.Path, a) -> Reference -> Branch0 m -> Metadata)	line:84	language:Haskell
getTypeMetadataHQNamed	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^getTypeMetadataHQNamed :: (Path.Path, HQSegment) -> Branch0 m -> Metadata.R4 Reference NameSegment$/;"	ft	signature:((Path.Path, HQSegment) -> Branch0 m -> Metadata.R4 Reference NameSegment)	line:57	language:Haskell
getTypeOfConstructor	./parser-typechecker/src/Unison/Codebase.hs	/^getTypeOfConstructor ::$/;"	ft	signature:((Monad m, Ord v) => Codebase m v a -> Reference -> Int -> m (Maybe (Type v a)))	line:132	language:Haskell
getTypeOfTerm	./parser-typechecker/src/Unison/Codebase.hs	/^getTypeOfTerm :: (Applicative m, Var v, BuiltinAnnotation a) =>$/;"	ft	signature:((Applicative m, Var v, BuiltinAnnotation a) => Codebase m v a -> Reference -> m (Maybe (Type v a)))	line:244	language:Haskell
getTypeOfTermImpl	./parser-typechecker/src/Unison/Codebase.hs	/^           , getTypeOfTermImpl  :: Reference.Id -> m (Maybe (Type v a))$/;"	c_a	cons:Codebase.Codebase	line:49	language:Haskell
getUserInput	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^getUserInput patterns codebase branch currentPath numberedArgs =$/;"	fi	line:78	language:Haskell
getVars	./parser-typechecker/src/Unison/FileParser.hs	/^getVars :: Var v => Stanza v term -> [v]$/;"	ft	signature:(Var v => Stanza v term -> [v])	line:103	language:Haskell
getWatch	./parser-typechecker/src/Unison/Codebase.hs	/^           , getWatch           :: UF.WatchKind -> Reference.Id -> m (Maybe (Term v a))$/;"	c_a	cons:Codebase.Codebase	line:73	language:Haskell
getWrapLine	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^getWrapLine :: TermOutput -> Capability TermOutput$/;"	ft	signature:(TermOutput -> Capability TermOutput)	line:67	language:Haskell
get_input_line	./yaks/haskeline/examples/export/HaskelineExport.hs	/^get_input_line sptr c_prefix = do$/;"	fi	line:37	language:Haskell
gets	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^gets :: MonadState s m => (s -> a) -> m a$/;"	ft	signature:(MonadState s m => (s -> a) -> m a)	line:55	language:Haskell
gitDescribe	./parser-typechecker/unison/Version.hs	/^gitDescribe :: String$/;"	ft	signature:(String)	line:11	language:Haskell
gitIn	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^gitIn :: FilePath -> [Text] -> IO ()$/;"	ft	signature:(FilePath -> [Text] -> IO ())	line:111	language:Haskell
gitTextIn	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^gitTextIn :: FilePath -> [Text] -> IO Text$/;"	ft	signature:(FilePath -> [Text] -> IO Text)	line:114	language:Haskell
gitUrlArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^gitUrlArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1314	language:Haskell
go	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^go :: Runtime Symbol -> IO [FilePath] -> (EitherResult -> Test TFile) -> Test ()$/;"	ft	signature:(Runtime Symbol -> IO [FilePath] -> (EitherResult -> Test TFile) -> Test ())	line:98	language:Haskell
goLeft	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goLeft, goRight, moveToStart, moveToEnd :: s -> s$/;"	ft	signature:(s -> s)	class:Move	line:184	language:Haskell
goLeft	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goLeft im@(IMode [] _) = im $/;"	fi	instance:Move InsertMode	line:203	language:Haskell
goLeft	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goLeft (CMode (x:xs) c ys) = CMode xs x (c:ys)$/;"	fi	instance:Move CommandMode	line:283	language:Haskell
goLeftUntil	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^goRightUntil, goLeftUntil :: (InsertMode -> Bool) -> InsertMode -> InsertMode$/;"	ft	signature:((InsertMode -> Bool) -> InsertMode -> InsertMode)	line:425	language:Haskell
goLeftUntil	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^goLeftUntil f = loop . goLeft$/;"	fi	line:430	language:Haskell
goRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goLeft, goRight, moveToStart, moveToEnd :: s -> s$/;"	ft	signature:(s -> s)	class:Move	line:184	language:Haskell
goRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goRight im@(IMode _ []) = im$/;"	fi	instance:Move InsertMode	line:206	language:Haskell
goRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goRight (CMode xs c (y:ys)) = CMode (c:xs) y ys$/;"	fi	instance:Move CommandMode	line:286	language:Haskell
goRightUntil	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^goRightUntil, goLeftUntil :: (InsertMode -> Bool) -> InsertMode -> InsertMode$/;"	ft	signature:((InsertMode -> Bool) -> InsertMode -> InsertMode)	line:425	language:Haskell
goToBigWordDelEnd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^goToWordDelEnd, goToBigWordDelEnd :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:253	language:Haskell
goToBigWordDelEnd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^goToBigWordDelEnd = goRightUntil $ atStart (not . isBigWordChar)$/;"	fi	line:256	language:Haskell
goToWordDelEnd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^goToWordDelEnd, goToBigWordDelEnd :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:253	language:Haskell
good	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^good :: EitherResult -> Test TFile$/;"	ft	signature:(EitherResult -> Test TFile)	line:65	language:Haskell
graphemesToString	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^graphemesToString :: [Grapheme] -> String$/;"	ft	signature:([Grapheme] -> String)	line:144	language:Haskell
green	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
green	./parser-typechecker/src/Unison/Util/ColorText.hs	/^green = style Green$/;"	fi	line:27	language:Haskell
green	./parser-typechecker/src/Unison/Util/Pretty.hs	/^green = map CT.green$/;"	fi	line:670	language:Haskell
group	./parser-typechecker/src/Unison/Util/Pretty.hs	/^group :: Pretty s -> Pretty s$/;"	ft	signature:(Pretty s -> Pretty s)	line:227	language:Haskell
groupBy	./unison-core/src/Unison/Util/List.hs	/^groupBy :: (Foldable f, Ord k) => (v -> k) -> f v -> Map k [v]$/;"	ft	signature:((Foldable f, Ord k) => (v -> k) -> f v -> Map k [v])	line:16	language:Haskell
groupByComponent	./unison-core/src/Unison/Reference.hs	/^groupByComponent :: [(k, Reference)] -> [[(k, Reference)]]$/;"	ft	signature:([(k, Reference)] -> [[ (k, Reference) ]])	line:160	language:Haskell
groupMenu1	./parser-typechecker/src/Unison/Util/Menu.hs	/^groupMenu1 :: forall a mc$/;"	ft	signature:(forall a mc . Console -> Caption -> (a -> Stylized) -> (mc -> Stylized) -> [([Keyword], [a])] -> [([Keyword], mc)] -> Maybe Keyword -> IO (Maybe (Either mc [a])))	line:117	language:Haskell
groupMenu1	./parser-typechecker/src/Unison/Util/Menu.hs	/^groupMenu1 console caption render renderMeta groups metas initial = do$/;"	fi	line:126	language:Haskell
groupMenuN	./parser-typechecker/src/Unison/Util/Menu.hs	/^groupMenuN :: forall a mc. Ord a$/;"	ft	signature:(forall a mc. Ord a => Console -> Caption -> (a -> Stylized) -> (mc -> Stylized) -> [([Keyword], [a])] -> [([Keyword], mc)] -> [[Keyword]] -> IO (Either mc [[a]]))	line:213	language:Haskell
groupMenuN	./parser-typechecker/src/Unison/Util/Menu.hs	/^groupMenuN console caption render renderMeta groups metas initials =$/;"	fi	line:222	language:Haskell
groupMenuN'	./parser-typechecker/src/Unison/Util/Menu.hs	/^groupMenuN' :: forall a mc. Ord a$/;"	ft	signature:(forall a mc. Ord a => Console -> Caption -> (a -> Stylized) -> (mc -> Stylized) -> [([Keyword], [a])] -> [([Keyword], mc)] -> Set [Keyword] -> IO (Either mc [[a]]))	line:225	language:Haskell
groupMenuN'	./parser-typechecker/src/Unison/Util/Menu.hs	/^groupMenuN' console caption render renderMeta groups metas initials = do$/;"	fi	line:234	language:Haskell
gsWidth	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^gsWidth :: [Grapheme] -> Int$/;"	ft	signature:([Grapheme] -> Int)	line:27	language:Haskell
guardedEOF	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^guardedEOF :: (Handle -> IO a) -> Handle -> MaybeT IO a$/;"	ft	signature:((Handle -> IO a) -> Handle -> MaybeT IO a)	line:172	language:Haskell
h	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^pattern Hash h = Causal.RawHash h$/;"	fi	line:414	language:Haskell
h	./parser-typechecker/src/Unison/Codebase/Path.hs	/^pattern Parent h t = Path (NameSegment h :<| t)$/;"	fi	line:314	language:Haskell
h	./unison-core/src/Unison/Reference.hs	/^pattern Derived h i n = DerivedId (Id h i n)$/;"	fi	line:49	language:Haskell
hBracketInputEcho	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hBracketInputEcho :: MonadException m => Handle -> m a -> m a$/;"	ft	signature:(MonadException m => Handle -> m a -> m a)	line:70	language:Haskell
hEchoOff	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hEchoOff :: Handle -> IO EchoState$/;"	ft	signature:(Handle -> IO EchoState)	line:120	language:Haskell
hGetByte	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^hGetByte :: Handle -> MaybeT IO Word8$/;"	ft	signature:(Handle -> MaybeT IO Word8)	line:169	language:Haskell
hGetInputEchoSTTY	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hGetInputEchoSTTY :: Handle -> IO STTYSettings$/;"	ft	signature:(Handle -> IO STTYSettings)	line:43	language:Haskell
hGetInputEchoState	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hGetInputEchoState :: Handle -> IO EchoState$/;"	ft	signature:(Handle -> IO EchoState)	line:31	language:Haskell
hGetLocaleLine	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^hGetLocaleLine :: Handle -> MaybeT IO ByteString$/;"	ft	signature:(Handle -> MaybeT IO ByteString)	line:202	language:Haskell
hMaybeReadNewline	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^hMaybeReadNewline :: Handle -> IO ()$/;"	ft	signature:(Handle -> IO ())	line:189	language:Haskell
hOut	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^data Handles = Handles {hIn, hOut :: ExternalHandle$/;"	c_a	cons:Handles.Handles	line:52	language:Haskell
hOut	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data Handles = Handles { hIn, hOut :: HANDLE }$/;"	c_a	cons:Handles.Handles	line:257	language:Haskell
hSetBinOrEncoding	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^hSetBinOrEncoding :: Handle -> Maybe TextEncoding -> IO ()$/;"	ft	signature:(Handle -> Maybe TextEncoding -> IO ())	line:53	language:Haskell
hSetInputEchoSTTY	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hSetInputEchoSTTY :: Handle -> STTYSettings -> IO ()$/;"	ft	signature:(Handle -> STTYSettings -> IO ())	line:57	language:Haskell
hSetInputEchoState	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hSetInputEchoState :: Handle -> EchoState -> IO ()$/;"	ft	signature:(Handle -> EchoState -> IO ())	line:47	language:Haskell
hSttyRaw	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hSttyRaw :: Handle -> String -> IO STTYSettings$/;"	ft	signature:(Handle -> String -> IO STTYSettings)	line:86	language:Haskell
hWithBinaryMode	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^hWithBinaryMode :: MonadException m => Handle -> m a -> m a$/;"	ft	signature:(MonadException m => Handle -> m a -> m a)	line:156	language:Haskell
hWithoutInputEcho	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^hWithoutInputEcho :: MonadException m => Handle -> m a -> m a$/;"	ft	signature:(MonadException m => Handle -> m a -> m a)	line:79	language:Haskell
handle	./parser-typechecker/src/Unison/TermParser.hs	/^letBlock, handle, lamCase, ifthen :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:244	language:Haskell
handle	./parser-typechecker/src/Unison/TermParser.hs	/^handle = label "handle" $ do$/;"	fi	line:247	language:Haskell
handle	./unison-core/src/Unison/Term.hs	/^handle :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:533	language:Haskell
handle	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^handle :: (MonadException m, Exception e) => (e -> m a) -> m a -> m a$/;"	ft	signature:((MonadException m, Exception e) => (e -> m a) -> m a -> m a)	line:102	language:Haskell
handleIO	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^handleIO :: RT.CompilationEnv -> IR.ConstructorId -> [RT.Value] -> UIO RT.Value$/;"	ft	signature:(RT.CompilationEnv -> IR.ConstructorId -> [RT.Value] -> UIO RT.Value)	line:286	language:Haskell
handleIO'	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^handleIO' cenv s rid cid vs = case rid of$/;"	fi	line:265	language:Haskell
handleId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
handleId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^handleId = constructorNamed handleReference "io.Handle.Handle"$/;"	fi	line:98	language:Haskell
handleInterrupt	./yaks/haskeline/System/Console/Haskeline.hs	/^handleInterrupt :: MonadException m => m a -> m a -> m a$/;"	ft	signature:(MonadException m => m a -> m a -> m a)	line:322	language:Haskell
handleReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^handleReference = typeNamed "io.Handle"$/;"	fi	line:80	language:Haskell
hang	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hang :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s)	line:601	language:Haskell
hang'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hang' from by p = group $ if preferredHeight p > 0$/;"	fi	line:583	language:Haskell
hangUngrouped	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hangUngrouped from = hangUngrouped' from "  "$/;"	fi	line:599	language:Haskell
hangUngrouped'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hangUngrouped' from by p = if preferredHeight p > 0$/;"	fi	line:593	language:Haskell
hasHash	./unison-core/src/Unison/HashQualified.hs	/^hasName, hasHash :: HashQualified -> Bool$/;"	ft	signature:(HashQualified -> Bool)	line:59	language:Haskell
hasHash	./unison-core/src/Unison/HashQualified.hs	/^hasHash = isJust . toHash$/;"	fi	line:61	language:Haskell
hasMetadata	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^hasMetadata :: Ord a => a -> Type -> Value -> Star a n -> Bool$/;"	ft	signature:(Ord a => a -> Type -> Value -> Star a n -> Bool)	line:31	language:Haskell
hasName	./unison-core/src/Unison/HashQualified.hs	/^hasName, hasHash :: HashQualified -> Bool$/;"	ft	signature:(HashQualified -> Bool)	line:59	language:Haskell
hasSep	./parser-typechecker/src/Unison/Lexer.hs	/^hasSep :: String -> Bool$/;"	ft	signature:(String -> Bool)	line:631	language:Haskell
hasShift	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^data Modifier = Modifier {hasControl, hasMeta, hasShift :: Bool}$/;"	c_a	cons:Modifier.Modifier	line:22	language:Haskell
hasTermNamed	./unison-core/src/Unison/Names3.hs	/^hasTermNamed :: Name -> Names -> Bool$/;"	ft	signature:(Name -> Names -> Bool)	line:142	language:Haskell
hasTypeNamed	./unison-core/src/Unison/Names3.hs	/^hasTypeNamed :: Name -> Names -> Bool$/;"	ft	signature:(Name -> Names -> Bool)	line:145	language:Haskell
hash	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^hash :: Hashable e => e -> Hash$/;"	ft	signature:(Hashable e => e -> Hash)	line:287	language:Haskell
hash	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  ReflogEntry { hash :: ShortBranchHash, reason :: Text }$/;"	c_a	cons:ReflogEntry.ReflogEntry	line:198	language:Haskell
hash	./unison-core/src/Unison/ABT.hs	/^hash :: forall f v a h . (Functor f, Hashable1 f, Eq v, Show v, Var v, Ord h, Accumulate h)$/;"	ft	signature:(forall f v a h . (Functor f, Hashable1 f, Eq v, Show v, Var v, Ord h, Accumulate h) => Term f v a -> h)	line:653	language:Haskell
hash	./unison-core/src/Unison/DataDeclaration.hs	/^hash :: (Eq v, Var v, Ord h, Accumulate h)$/;"	ft	signature:((Eq v, Var v, Ord h, Accumulate h) => [(v, ABT.Term F v ())] -> [(v, h)])	line:312	language:Haskell
hash1	./unison-core/src/Unison/ABT.hs	/^  hash1 hashCycle hash c = case c of$/;"	fi	instance:(Hashable1 f, Functor f) => Hashable1 (Component f)	line:644	language:Haskell
hash1	./unison-core/src/Unison/DataDeclaration.hs	/^  hash1 hashCycle hash e =$/;"	fi	instance:Hashable1 F	line:281	language:Haskell
hash1	./unison-core/src/Unison/Hashable.hs	/^  hash1 :: (Ord h, Accumulate h) => ([a] -> ([h], a -> h)) -> (a -> h) -> f a -> h$/;"	ft	signature:((Ord h, Accumulate h) => ([a] -> ([h], a -> h)) -> (a -> h) -> f a -> h)	class:Hashable1	line:72	language:Haskell
hash1	./unison-core/src/Unison/Term.hs	/^  hash1 hashCycle hash e$/;"	fi	instance:Var v => Hashable1 (F v a p)	line:961	language:Haskell
hash1	./unison-core/src/Unison/Type.hs	/^  hash1 hashCycle hash e =$/;"	fi	instance:Hashable1 F	line:587	language:Haskell
hashComponent	./unison-core/src/Unison/ABT.hs	/^hashComponent ::$/;"	ft	signature:((Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v, Ord h, Accumulate h) => Map.Map v (Term f v a) -> (h, [(v, Term f v a)]))	line:599	language:Haskell
hashComponents	./unison-core/src/Unison/ABT.hs	/^hashComponents termFromHash termsByName = let$/;"	fi	line:621	language:Haskell
hashComponents	./unison-core/src/Unison/Reference/Util.hs	/^hashComponents ::$/;"	ft	signature:((Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v) => (Reference -> ABT.Term f v ()) -> Map v (ABT.Term f v a) -> Map v (Reference, ABT.Term f v a))	line:11	language:Haskell
hashComponents	./unison-core/src/Unison/Term.hs	/^hashComponents = ReferenceUtil.hashComponents $ ref ()$/;"	fi	line:930	language:Haskell
hashComponents	./unison-core/src/Unison/Type.hs	/^hashComponents = ReferenceUtil.hashComponents $ ref ()$/;"	fi	line:584	language:Haskell
hashConstructor	./unison-core/src/Unison/Term.hs	/^hashConstructor :: Reference -> Int -> Reference$/;"	ft	signature:(Reference -> Int -> Reference)	line:944	language:Haskell
hashConstructor'	./unison-core/src/Unison/Term.hs	/^hashConstructor' f r cid =$/;"	fi	line:935	language:Haskell
hashConstructors	./parser-typechecker/src/Unison/UnisonFile.hs	/^hashConstructors file =$/;"	fi	line:217	language:Haskell
hashDecls	./unison-core/src/Unison/DataDeclaration.hs	/^hashDecls decls = do$/;"	fi	line:395	language:Haskell
hashDecls0	./unison-core/src/Unison/DataDeclaration.hs	/^hashDecls0 :: (Eq v, Var v) => Map v (DataDeclaration' v ()) -> [(v, Reference)]$/;"	ft	signature:((Eq v, Var v) => Map v (DataDeclaration' v ()) -> [(v, Reference)])	line:373	language:Haskell
hashExists	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^hashExists :: MonadIO m => CodebasePath -> Branch.Hash -> m Bool$/;"	ft	signature:(MonadIO m => CodebasePath -> Branch.Hash -> m Bool)	line:359	language:Haskell
hashFromFilePath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^hashFromFilePath :: FilePath -> Maybe Hash.Hash$/;"	ft	signature:(FilePath -> Maybe Hash.Hash)	line:397	language:Haskell
hashFromString	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^hashFromString :: String -> Maybe Hash.Hash$/;"	ft	signature:(String -> Maybe Hash.Hash)	line:390	language:Haskell
hashLength	./parser-typechecker/src/Unison/Codebase.hs	/^           , hashLength         :: m Int$/;"	c_a	cons:Codebase.Codebase	line:84	language:Haskell
hashQualifiedInfixTerm	./parser-typechecker/src/Unison/TermParser.hs	/^hashQualifiedInfixTerm :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:286	language:Haskell
hashQualifiedPrefixTerm	./parser-typechecker/src/Unison/TermParser.hs	/^hashQualifiedPrefixTerm :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:283	language:Haskell
hashRequest	./unison-core/src/Unison/Term.hs	/^hashRequest :: Reference -> Int -> Reference$/;"	ft	signature:(Reference -> Int -> Reference)	line:947	language:Haskell
hashTerms	./parser-typechecker/src/Unison/UnisonFile.hs	/^    hashTerms           :: Map v (Reference, Term v a, Type v a)$/;"	c_a	cons:TypecheckedUnisonFile.TypecheckedUnisonFile	line:86	language:Haskell
hashToRaw	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^hashToRaw ::$/;"	ft	signature:(forall m h e. Monad m => Causal m h e -> m (Map (RawHash h) [RawHash h]))	line:357	language:Haskell
hashToString	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^hashToString :: Hash.Hash -> String$/;"	ft	signature:(Hash.Hash -> String)	line:394	language:Haskell
haskelineEncoding	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^haskelineEncoding :: TextEncoding$/;"	ft	signature:(TextEncoding)	line:57	language:Haskell
haskellBufferMode	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^haskellBufferMode :: RT.Value -> BufferMode$/;"	ft	signature:(RT.Value -> BufferMode)	line:218	language:Haskell
haskellMode	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^haskellMode :: Text -> IOMode$/;"	ft	signature:(Text -> IOMode)	line:127	language:Haskell
haskellSeekMode	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^haskellSeekMode :: Text -> SeekMode$/;"	ft	signature:(Text -> SeekMode)	line:211	language:Haskell
haveTerminalUI	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^haveTerminalUI :: Monad m => InputT m Bool$/;"	ft	signature:(Monad m => InputT m Bool)	line:108	language:Haskell
head	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^head :: Branch m -> Branch0 m$/;"	ft	signature:(Branch m -> Branch0 m)	line:327	language:Haskell
head	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^        , head :: e$/;"	c_a	cons:Causal.One	line:62	language:Haskell
head	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^         , head :: e$/;"	c_a	cons:Causal.Cons	line:65	language:Haskell
head	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^          , head :: e$/;"	c_a	cons:Causal.Merge	line:70	language:Haskell
headHash	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^headHash :: Branch m -> Hash$/;"	ft	signature:(Branch m -> Hash)	line:330	language:Haskell
headToken	./parser-typechecker/src/Unison/Lexer.hs	/^headToken :: T a -> a$/;"	ft	signature:(T a -> a)	line:174	language:Haskell
height	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^data Layout = Layout {width, height :: Int}$/;"	c_a	cons:Layout.Layout	line:149	language:Haskell
help	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  , help        :: P.Pretty CT.ColorText$/;"	c_a	cons:InputPattern.InputPattern	line:32	language:Haskell
help	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^help :: InputPattern$/;"	ft	signature:(InputPattern)	line:995	language:Haskell
helpFor	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^helpFor :: InputPattern -> Either (P.Pretty CT.ColorText) Input$/;"	ft	signature:(InputPattern -> Either (P.Pretty CT.ColorText) Input)	line:71	language:Haskell
helpTopics	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^helpTopics :: InputPattern$/;"	ft	signature:(InputPattern)	line:885	language:Haskell
helpTopicsMap	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^helpTopicsMap :: Map String (P.Pretty P.ColorText)$/;"	ft	signature:(Map String (P.Pretty P.ColorText))	line:907	language:Haskell
here	./unison-core/src/Unison/ABT.hs	/^here :: Monoid m => Path s t s t m$/;"	ft	signature:(Monoid m => Path s t s t m)	line:58	language:Haskell
hiBlack	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiBlack	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiBlack = style HiBlack$/;"	fi	line:33	language:Haskell
hiBlack	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiBlack = map CT.hiBlack$/;"	fi	line:676	language:Haskell
hiBlue	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiBlue	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiBlue = style HiBlue$/;"	fi	line:37	language:Haskell
hiBlue	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiBlue = map CT.hiBlue$/;"	fi	line:680	language:Haskell
hiCyan	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiCyan	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiCyan = style HiCyan$/;"	fi	line:39	language:Haskell
hiCyan	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiCyan = map CT.hiCyan$/;"	fi	line:682	language:Haskell
hiGreen	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiGreen	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiGreen = style HiGreen$/;"	fi	line:35	language:Haskell
hiGreen	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiGreen = map CT.hiGreen$/;"	fi	line:678	language:Haskell
hiPurple	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiPurple	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiPurple = style HiPurple$/;"	fi	line:38	language:Haskell
hiPurple	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiPurple = map CT.hiPurple$/;"	fi	line:681	language:Haskell
hiRed	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiRed	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiRed = style HiRed$/;"	fi	line:34	language:Haskell
hiRed	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiRed = map CT.hiRed$/;"	fi	line:677	language:Haskell
hiWhite	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiWhite	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiWhite = style HiWhite$/;"	fi	line:40	language:Haskell
hiWhite	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiWhite = map CT.hiWhite$/;"	fi	line:683	language:Haskell
hiYellow	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
hiYellow	./parser-typechecker/src/Unison/Util/ColorText.hs	/^hiYellow = style HiYellow$/;"	fi	line:36	language:Haskell
hiYellow	./parser-typechecker/src/Unison/Util/Pretty.hs	/^hiYellow = map CT.hiYellow$/;"	fi	line:679	language:Haskell
hidden	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^hidden :: P Hidden$/;"	ft	signature:(P Hidden)	line:377	language:Haskell
highlight	./parser-typechecker/src/Unison/Util/Find.hs	/^highlight :: (P.Pretty P.ColorText -> P.Pretty P.ColorText)$/;"	ft	signature:((P.Pretty P.ColorText -> P.Pretty P.ColorText) -> Text -> [(Pos, Len)] -> P.Pretty P.ColorText)	line:163	language:Haskell
highlight'	./parser-typechecker/src/Unison/Util/Find.hs	/^highlight' :: (P.Pretty P.ColorText -> P.Pretty P.ColorText)$/;"	ft	signature:((P.Pretty P.ColorText -> P.Pretty P.ColorText) -> (P.Pretty P.ColorText -> P.Pretty P.ColorText) -> Text -> [(Pos, Len)] -> P.Pretty P.ColorText)	line:169	language:Haskell
highlightSimple	./parser-typechecker/src/Unison/Util/Find.hs	/^highlightSimple :: String -> String -> P.Pretty P.ColorText$/;"	ft	signature:(String -> String -> P.Pretty P.ColorText)	line:55	language:Haskell
hintFreshCodebase	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^hintFreshCodebase :: P.Pretty P.ColorText$/;"	ft	signature:(P.Pretty P.ColorText)	line:147	language:Haskell
histLines	./yaks/haskeline/System/Console/Haskeline/History.hs	/^data History = History {histLines :: Seq String,$/;"	c_a	cons:History.History	line:38	language:Haskell
histLog	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^histLog :: History -> HistLog$/;"	ft	signature:(History -> HistLog)	line:26	language:Haskell
histUpdate	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^histUpdate :: MonadState HistLog m => (s -> HistLog -> (t,HistLog))$/;"	ft	signature:(MonadState HistLog m => (s -> HistLog -> (t, HistLog)) -> s -> m (Either Effect t))	line:64	language:Haskell
history	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^history :: InputPattern$/;"	ft	signature:(InputPattern)	line:568	language:Haskell
historyBack	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^historyBack, historyForward :: (Save s, MonadState HistLog m) => Command m s s$/;"	ft	signature:((Save s, MonadState HistLog m) => Command m s s)	line:56	language:Haskell
historyDuplicates	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     historyDuplicates :: HistoryDuplicates,$/;"	c_a	cons:Prefs.Prefs	line:35	language:Haskell
historyEnd	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^historyStart, historyEnd :: (Save s, MonadState HistLog m) => Command m s s$/;"	ft	signature:((Save s, MonadState HistLog m) => Command m s s)	line:60	language:Haskell
historyEnd	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^historyEnd = simpleCommand $ reverseHist . histUpdate firstHistory$/;"	fi	line:62	language:Haskell
historyFile	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^                            historyFile :: Maybe FilePath, -- ^ Where to read\/write the history at the$/;"	c_a	cons:Settings.Settings	line:22	language:Haskell
historyForward	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^historyBack, historyForward :: (Save s, MonadState HistLog m) => Command m s s$/;"	ft	signature:((Save s, MonadState HistLog m) => Command m s s)	line:56	language:Haskell
historyForward	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^historyForward = simpleCommand $ reverseHist . histUpdate prevHistory$/;"	fi	line:58	language:Haskell
historyLines	./yaks/haskeline/System/Console/Haskeline/History.hs	/^historyLines :: History -> [String]$/;"	ft	signature:(History -> [String])	line:53	language:Haskell
historyStart	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^historyStart, historyEnd :: (Save s, MonadState HistLog m) => Command m s s$/;"	ft	signature:((Save s, MonadState HistLog m) => Command m s s)	line:60	language:Haskell
historyTests	./yaks/haskeline/tests/Unit.hs	/^historyTests i =  "history encoding" ~:$/;"	fi	line:129	language:Haskell
hoist	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^  hoist f (CodeLookup tm tp) = CodeLookup (f . tm) (f . tp)$/;"	fi	instance:MFunctor (CodeLookup v)	line:37	language:Haskell
hoist	./parser-typechecker/src/Unison/Result.hs	/^hoist morph = Morph.hoist (Morph.hoist morph)$/;"	fi	line:93	language:Haskell
hostPreference	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^hostPreference :: [RT.Value] -> Net.HostPreference$/;"	ft	signature:([RT.Value] -> Net.HostPreference)	line:244	language:Haskell
hq	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^pattern Tm' hq r as = Tm (TermResult hq r as)$/;"	fi	line:33	language:Haskell
hq	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^pattern Tp' hq r as = Tp (TypeResult hq r as)$/;"	fi	line:34	language:Haskell
hqBacktickedId_	./parser-typechecker/src/Unison/Parser.hs	/^hqBacktickedId_ :: Ord v => P v (L.Token HQ.HashQualified)$/;"	ft	signature:(Ord v => P v (L.Token HQ.HashQualified))	line:360	language:Haskell
hqInfixId	./parser-typechecker/src/Unison/Parser.hs	/^hqPrefixId, hqInfixId :: Ord v => P v (L.Token HQ.HashQualified)$/;"	ft	signature:(Ord v => P v (L.Token HQ.HashQualified))	line:338	language:Haskell
hqInfixId	./parser-typechecker/src/Unison/Parser.hs	/^hqInfixId = hqSymbolyId_ <|> hqBacktickedId_$/;"	fi	line:340	language:Haskell
hqLength	./parser-typechecker/tests/Unison/Test/Common.hs	/^hqLength :: Int$/;"	ft	signature:(Int)	line:36	language:Haskell
hqName	./unison-core/src/Unison/Names2.hs	/^hqName :: Ord n => Names' n -> n -> Either Reference Referent -> HQ.HashQualified' n$/;"	ft	signature:(Ord n => Names' n -> n -> Either Reference Referent -> HQ.HashQualified' n)	line:223	language:Haskell
hqPrefixId	./parser-typechecker/src/Unison/Parser.hs	/^hqPrefixId, hqInfixId :: Ord v => P v (L.Token HQ.HashQualified)$/;"	ft	signature:(Ord v => P v (L.Token HQ.HashQualified))	line:338	language:Haskell
hqSymbolyId_	./parser-typechecker/src/Unison/Parser.hs	/^hqSymbolyId_ :: Ord v => P v (L.Token HQ.HashQualified)$/;"	ft	signature:(Ord v => P v (L.Token HQ.HashQualified))	line:353	language:Haskell
hqTermName	./unison-core/src/Unison/Names2.hs	/^hqTermName :: Ord n => Int -> Names' n -> n -> Referent -> HQ.HashQualified' n$/;"	ft	signature:(Ord n => Int -> Names' n -> n -> Referent -> HQ.HashQualified' n)	line:232	language:Haskell
hqTermName'	./unison-core/src/Unison/Names2.hs	/^hqTermName' :: Int -> n -> Referent -> HQ.HashQualified' n$/;"	ft	signature:(Int -> n -> Referent -> HQ.HashQualified' n)	line:261	language:Haskell
hqTypeName	./unison-core/src/Unison/Names2.hs	/^hqTypeName :: Ord n => Int -> Names' n -> n -> Reference -> HQ.HashQualified' n$/;"	ft	signature:(Ord n => Int -> Names' n -> n -> Reference -> HQ.HashQualified' n)	line:237	language:Haskell
hqTypeName'	./unison-core/src/Unison/Names2.hs	/^hqTypeName' :: Int -> n -> Reference -> HQ.HashQualified' n$/;"	ft	signature:(Int -> n -> Reference -> HQ.HashQualified' n)	line:265	language:Haskell
hqWordyId_	./parser-typechecker/src/Unison/Parser.hs	/^hqWordyId_ :: Ord v => P v (L.Token HQ.HashQualified)$/;"	ft	signature:(Ord v => P v (L.Token HQ.HashQualified))	line:343	language:Haskell
idContinuation	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^idContinuation :: IO Continuation$/;"	ft	signature:(IO Continuation)	line:60	language:Haskell
idFromText	./unison-core/src/Unison/Reference.hs	/^idFromText :: Text -> Maybe Id$/;"	ft	signature:(Text -> Maybe Id)	line:131	language:Haskell
ifBody	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^ifBody = existentialMismatch0 IfBody (Ex.inSynthesizeApp >> Ex.inIfBody)$/;"	fi	line:234	language:Haskell
iff	./unison-core/src/Unison/Term.hs	/^iff :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:562	language:Haskell
iff	./unison-core/src/Unison/Type.hs	/^iff :: Var v => Type v ()$/;"	ft	signature:(Var v => Type v ())	line:284	language:Haskell
iff'	./unison-core/src/Unison/Type.hs	/^iff' :: Var v => a -> Type v a$/;"	ft	signature:(Var v => a -> Type v a)	line:290	language:Haskell
iff2	./unison-core/src/Unison/Type.hs	/^iff2 :: Var v => a -> Type v a$/;"	ft	signature:(Var v => a -> Type v a)	line:296	language:Haskell
ifthen	./parser-typechecker/src/Unison/TermParser.hs	/^letBlock, handle, lamCase, ifthen :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:244	language:Haskell
ifthen	./parser-typechecker/src/Unison/TermParser.hs	/^ifthen = label "if" $ do$/;"	fi	line:263	language:Haskell
illFormedType	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^illFormedType :: ErrorExtractor v loc (C.Context v loc)$/;"	ft	signature:(ErrorExtractor v loc (C.Context v loc))	line:237	language:Haskell
illegalOperation	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^illegalOperation :: String -> IOError$/;"	ft	signature:(String -> IOError)	line:282	language:Haskell
illegalOperationId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^illegalOperationId = mkErrorType "io.ErrorType.IllegalOperation"$/;"	fi	line:116	language:Haskell
immediateChildBlockTerms	./parser-typechecker/src/Unison/TermPrinter.hs	/^immediateChildBlockTerms :: (Var vt, Var v) => Term2 vt at ap v a -> [Term2 vt at ap v a]$/;"	ft	signature:((Var vt, Var v) => Term2 vt at ap v a -> [Term2 vt at ap v a])	line:986	language:Haskell
import	./parser-typechecker/src/Unison/Codebase.hs	/^import           Control.Lens                   ( _1, _2, (%=) )$/;"	fi	line:8	language:Haskell
import	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^import           System.FilePath.Find   (always, extension, find, (==?))$/;"	fi	line:17	language:Haskell
import	./unison-core/src/Unison/ABT.hs	/^import Control.Lens (Lens', use, (.=))$/;"	fi	line:15	language:Haskell
importDotId	./parser-typechecker/src/Unison/Parser.hs	/^importDotId :: Ord v => P v (L.Token Name)$/;"	ft	signature:(Ord v => P v (L.Token Name))	line:269	language:Haskell
importSymbolyId	./parser-typechecker/src/Unison/Parser.hs	/^importSymbolyId :: Ord v => P v (L.Token Name)$/;"	ft	signature:(Ord v => P v (L.Token Name))	line:312	language:Haskell
importWordyId	./parser-typechecker/src/Unison/Parser.hs	/^importWordyId :: Ord v => P v (L.Token Name)$/;"	ft	signature:(Ord v => P v (L.Token Name))	line:308	language:Haskell
importing	./unison-core/src/Unison/Names3.hs	/^importing :: [(Name, Name)] -> Names -> Names$/;"	ft	signature:([(Name, Name)] -> Names -> Names)	line:211	language:Haskell
importing0	./unison-core/src/Unison/Names3.hs	/^importing0 :: [(Name, Name)] -> Names0 -> Names0$/;"	ft	signature:([(Name, Name)] -> Names0 -> Names0)	line:215	language:Haskell
importp	./parser-typechecker/src/Unison/TermParser.hs	/^importp :: Ord v => P v [(Name, Name)]$/;"	ft	signature:(Ord v => P v [(Name, Name)])	line:725	language:Haskell
imports	./parser-typechecker/src/Unison/TermParser.hs	/^imports :: Var v => P v (Names, [(v,v)])$/;"	ft	signature:(Var v => P v (Names, [(v, v)]))	line:792	language:Haskell
imports	./parser-typechecker/src/Unison/TermPrinter.hs	/^  , imports :: Imports$/;"	c_a	cons:AmbientContext.AmbientContext	line:67	language:Haskell
inAndApp	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inAndApp = asPathExtractor $ \\case$/;"	fi	line:196	language:Haskell
inCheck	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inCheck :: SubseqExtractor v loc (C.Term v loc, C.Type v loc)$/;"	ft	signature:(SubseqExtractor v loc (C.Term v loc, C.Type v loc))	line:173	language:Haskell
inFunctionCall	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inFunctionCall = asPathExtractor $ \\case$/;"	fi	line:188	language:Haskell
inIfBody	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inMatch, inVector, inIfBody :: SubseqExtractor v loc loc$/;"	ft	signature:(SubseqExtractor v loc loc)	line:212	language:Haskell
inIfBody	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inIfBody = asPathExtractor $ \\case$/;"	fi	line:219	language:Haskell
inIfCond	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inIfCond = asPathExtractor $ \\case$/;"	fi	line:202	language:Haskell
inMatch	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inMatch, inVector, inIfBody :: SubseqExtractor v loc loc$/;"	ft	signature:(SubseqExtractor v loc loc)	line:212	language:Haskell
inMatchBody	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inMatchBody = asPathExtractor $ \\case$/;"	fi	line:208	language:Haskell
inMatchGuard	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inMatchGuard = asPathExtractor $ \\case$/;"	fi	line:205	language:Haskell
inOrApp	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inOrApp = asPathExtractor $ \\case$/;"	fi	line:199	language:Haskell
inRange	./parser-typechecker/src/Unison/Util/Range.hs	/^inRange :: Pos -> Range -> Bool$/;"	ft	signature:(Pos -> Range -> Bool)	line:12	language:Haskell
inScopeAt	./unison-core/src/Unison/Paths.hs	/^inScopeAt :: Var v => Path -> Target v -> [v]$/;"	ft	signature:(Var v => Path -> Target v -> [v])	line:153	language:Haskell
inScopeAtTerm	./unison-core/src/Unison/Paths.hs	/^inScopeAtTerm :: Var v => Path -> Term v -> [v]$/;"	ft	signature:(Var v => Path -> Term v -> [v])	line:156	language:Haskell
inScopeAtType	./unison-core/src/Unison/Paths.hs	/^inScopeAtType :: Var v => Path -> Type v -> [v]$/;"	ft	signature:(Var v => Path -> Type v -> [v])	line:159	language:Haskell
inSubtype	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inSubtype :: SubseqExtractor v loc (C.Type v loc, C.Type v loc)$/;"	ft	signature:(SubseqExtractor v loc (C.Type v loc, C.Type v loc))	line:168	language:Haskell
inSubtypes	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^inSubtypes :: Ex.SubseqExtractor v loc (C.Type v loc,$/;"	ft	signature:(Ex.SubseqExtractor v loc (C.Type v loc, C.Type v loc, Maybe (C.Type v loc, C.Type v loc)))	line:290	language:Haskell
inSynthesize	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inSynthesize :: SubseqExtractor v loc (C.Term v loc)$/;"	ft	signature:(SubseqExtractor v loc (C.Term v loc))	line:163	language:Haskell
inSynthesizeApp	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inSynthesizeApp :: SubseqExtractor v loc (C.Type v loc, C.Term v loc, Int)$/;"	ft	signature:(SubseqExtractor v loc (C.Type v loc, C.Term v loc, Int))	line:181	language:Haskell
inVector	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inMatch, inVector, inIfBody :: SubseqExtractor v loc loc$/;"	ft	signature:(SubseqExtractor v loc loc)	line:212	language:Haskell
inVector	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^inVector = asPathExtractor $ \\case$/;"	fi	line:216	language:Haskell
inc	./parser-typechecker/src/Unison/Lexer.hs	/^inc :: Pos -> Pos$/;"	ft	signature:(Pos -> Pos)	line:754	language:Haskell
incBy	./parser-typechecker/src/Unison/Lexer.hs	/^incBy :: String -> Pos -> Pos$/;"	ft	signature:(String -> Pos -> Pos)	line:757	language:Haskell
incorrectInput	./yaks/haskeline/tests/Unit.hs	/^incorrectInput i = "incorrect input" ~:$/;"	fi	line:116	language:Haskell
increment	./parser-typechecker/src/Unison/Util/Logger.hs	/^increment :: Logger -> Logger$/;"	ft	signature:(Logger -> Logger)	line:105	language:Haskell
indent	./parser-typechecker/src/Unison/Util/Pretty.hs	/^indent :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s)	line:607	language:Haskell
indentAfterNewline	./parser-typechecker/src/Unison/Util/Pretty.hs	/^indentAfterNewline by = flatMap f$/;"	fi	line:623	language:Haskell
indentN	./parser-typechecker/src/Unison/Util/Pretty.hs	/^indentN :: (LL.ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s)	line:610	language:Haskell
indentNAfterNewline	./parser-typechecker/src/Unison/Util/Pretty.hs	/^indentNAfterNewline by = indentAfterNewline (fromString $ replicate by ' ')$/;"	fi	line:619	language:Haskell
indentNonEmptyN	./parser-typechecker/src/Unison/Util/Pretty.hs	/^indentNonEmptyN :: (LL.ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s)	line:613	language:Haskell
indices	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^  = SparseVector { indices :: !bits$/;"	c_a	cons:SparseVector.SparseVector	line:18	language:Haskell
inferAbility	./unison-core/src/Unison/Var.hs	/^inferAbility = typed (Inference Ability)$/;"	fi	line:73	language:Haskell
inferInput	./unison-core/src/Unison/Var.hs	/^inferInput = typed (Inference Input)$/;"	fi	line:71	language:Haskell
inferOther	./unison-core/src/Unison/Var.hs	/^inferOther = typed (Inference Other)$/;"	fi	line:80	language:Haskell
inferOutput	./unison-core/src/Unison/Var.hs	/^inferOutput = typed (Inference Output)$/;"	fi	line:72	language:Haskell
inferPatternBindE	./unison-core/src/Unison/Var.hs	/^inferPatternBindE = typed (Inference PatternBindE)$/;"	fi	line:76	language:Haskell
inferPatternBindV	./unison-core/src/Unison/Var.hs	/^inferPatternBindV = typed (Inference PatternBindV)$/;"	fi	line:77	language:Haskell
inferPatternPureE	./unison-core/src/Unison/Var.hs	/^inferPatternPureE = typed (Inference PatternPureE)$/;"	fi	line:74	language:Haskell
inferPatternPureV	./unison-core/src/Unison/Var.hs	/^inferPatternPureV = typed (Inference PatternPureV)$/;"	fi	line:75	language:Haskell
inferTypeConstructor	./unison-core/src/Unison/Var.hs	/^inferTypeConstructor = typed (Inference TypeConstructor)$/;"	fi	line:78	language:Haskell
inferTypeConstructorArg	./unison-core/src/Unison/Var.hs	/^inferTypeConstructorArg = typed (Inference TypeConstructorArg)$/;"	fi	line:79	language:Haskell
inferredType	./parser-typechecker/src/Unison/Typechecker.hs	/^             , inferredType :: Context.Type v loc$/;"	c_a	cons:Resolution.Resolution	line:169	language:Haskell
infixAppOrBooleanOp	./parser-typechecker/src/Unison/TermParser.hs	/^infixAppOrBooleanOp :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:638	language:Haskell
infixContext	./parser-typechecker/src/Unison/TermPrinter.hs	/^  , infixContext :: InfixContext$/;"	c_a	cons:AmbientContext.AmbientContext	line:66	language:Haskell
infixDefinitionName	./parser-typechecker/src/Unison/Parser.hs	/^infixDefinitionName :: Var v => P v (L.Token v)$/;"	ft	signature:(Var v => P v (L.Token v))	line:322	language:Haskell
info	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^info :: Ord v => Context v loc -> Info v loc$/;"	ft	signature:(Ord v => Context v loc -> Info v loc)	line:553	language:Haskell
info	./parser-typechecker/src/Unison/Util/Logger.hs	/^error, warn, info, debug, trace :: Logger -> String -> IO ()$/;"	ft	signature:(Logger -> String -> IO ())	line:81	language:Haskell
info	./parser-typechecker/src/Unison/Util/Logger.hs	/^info l = logAt l infoLevel$/;"	fi	line:84	language:Haskell
info'	./parser-typechecker/src/Unison/Util/Logger.hs	/^error', warn', info', debug', trace' :: Logger -> IO String -> IO ()$/;"	ft	signature:(Logger -> IO String -> IO ())	line:88	language:Haskell
info'	./parser-typechecker/src/Unison/Util/Logger.hs	/^info' l = logAt' l infoLevel$/;"	fi	line:91	language:Haskell
infoLevel	./parser-typechecker/src/Unison/Util/Logger.hs	/^errorLevel, warnLevel, infoLevel, debugLevel, traceLevel :: Level$/;"	ft	signature:(Level)	line:95	language:Haskell
infoNote	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^infoNote :: InfoExtractor v loc (C.InfoNote v loc)$/;"	ft	signature:(InfoExtractor v loc (C.InfoNote v loc))	line:286	language:Haskell
infoNotes	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^infoNotes :: Result v loc a -> Seq (InfoNote v loc)$/;"	ft	signature:(Result v loc a -> Seq (InfoNote v loc))	line:163	language:Haskell
infos	./parser-typechecker/src/Unison/Typechecker.hs	/^  infos  :: Seq (Context.InfoNote v loc)$/;"	c_a	cons:Notes.Notes	line:47	language:Haskell
initCodebase	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^initCodebase :: FilePath -> IO (Codebase IO Symbol Ann)$/;"	ft	signature:(FilePath -> IO (Codebase IO Symbol Ann))	line:136	language:Haskell
initCodebaseAndExit	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^initCodebaseAndExit :: Maybe FilePath -> IO ()$/;"	ft	signature:(Maybe FilePath -> IO ())	line:130	language:Haskell
initTermPos	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^initTermPos :: TermPos$/;"	ft	signature:(TermPos)	line:81	language:Haskell
initTermRows	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^initTermRows :: TermRows$/;"	ft	signature:(TermRows)	line:94	language:Haskell
initWindow	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^initWindow :: Window$/;"	ft	signature:(Window)	line:20	language:Haskell
initialPath	./parser-typechecker/unison/Main.hs	/^initialPath :: Path.Absolute$/;"	ft	signature:(Path.Absolute)	line:225	language:Haskell
initialUndo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^initialUndo :: Undo$/;"	ft	signature:(Undo)	line:16	language:Haskell
initialize	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^initialize :: CodebasePath -> IO ()$/;"	ft	signature:(CodebasePath -> IO ())	line:302	language:Haskell
initializeBuiltinCode	./parser-typechecker/src/Unison/Codebase.hs	/^initializeBuiltinCode :: forall m. Monad m => Codebase m Symbol Parser.Ann -> m ()$/;"	ft	signature:(forall m. Monad m => Codebase m Symbol Parser.Ann -> m ())	line:99	language:Haskell
initializeCodebase	./parser-typechecker/src/Unison/Codebase.hs	/^initializeCodebase :: forall m. Monad m => Codebase m Symbol Parser.Ann -> m ()$/;"	ft	signature:(forall m. Monad m => Codebase m Symbol Parser.Ann -> m ())	line:110	language:Haskell
initializeInput	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^initializeInput :: Settings IO -> IO InputState$/;"	ft	signature:(Settings IO -> IO InputState)	line:59	language:Haskell
initialize_input	./yaks/haskeline/examples/export/HaskelineExport.hs	/^initialize_input = do$/;"	fi	line:21	language:Haskell
innerJoinDomMultimaps	./unison-core/src/Unison/Util/Relation.hs	/^innerJoinDomMultimaps :: (Ord a, Ord b, Ord c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Map a (Set b, Set c))	line:113	language:Haskell
innerJoinRanMultimaps	./unison-core/src/Unison/Util/Relation.hs	/^innerJoinRanMultimaps :: (Ord a, Ord b, Ord c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Map c (Set a, Set b))	line:122	language:Haskell
innermostErrorTerm	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^innermostErrorTerm :: ErrorNote v loc -> Maybe (Term v loc)$/;"	ft	signature:(ErrorNote v loc -> Maybe (Term v loc))	line:301	language:Haskell
innermostTerm	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^innermostTerm :: ErrorExtractor v loc (C.Term v loc)$/;"	ft	signature:(ErrorExtractor v loc (C.Term v loc))	line:289	language:Haskell
inputChar	./yaks/haskeline/tests/Unit.hs	/^inputChar i = "getInputChar" ~:$/;"	fi	line:151	language:Haskell
inputOutput	./yaks/haskeline/tests/Pty.hs	/^inputOutput :: Fd -> B.ByteString -> IO B.ByteString$/;"	ft	signature:(Fd -> B.ByteString -> IO B.ByteString)	line:45	language:Haskell
inputOutput	./yaks/haskeline/tests/RunTTY.hs	/^inputOutput :: Handle -> Handle -> B.ByteString -> IO B.ByteString$/;"	ft	signature:(Handle -> Handle -> B.ByteString -> IO B.ByteString)	line:72	language:Haskell
inputStream	./parser-typechecker/src/Unison/Parser.hs	/^newtype Input = Input { inputStream :: [L.Token L.Lexeme] }$/;"	c_a	cons:Input.Input	line:134	language:Haskell
insert	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^insert :: (Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n$/;"	ft	signature:((Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n)	line:42	language:Haskell
insert	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^insert :: (Hashable k, Eq k) => k -> v -> CycleTable k v -> IO ()$/;"	ft	signature:((Hashable k, Eq k) => k -> v -> CycleTable k v -> IO ())	line:27	language:Haskell
insert	./parser-typechecker/src/Unison/Util/Star3.hs	/^insert :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d1, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3)	line:144	language:Haskell
insert	./unison-core/src/Unison/Util/Relation.hs	/^insert :: (Ord a, Ord b) => a -> b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => a -> b -> Relation a b -> Relation a b)	line:167	language:Haskell
insert	./unison-core/src/Unison/Util/Relation3.hs	/^insert a b c Relation3{..} =$/;"	fi	line:77	language:Haskell
insert	./unison-core/src/Unison/Util/Relation4.hs	/^insert a b c d Relation4{..} =$/;"	fi	line:80	language:Haskell
insertAll	./unison-core/src/Unison/Util/Relation3.hs	/^insertAll, deleteAll :: Foldable f => Ord a => Ord b => Ord c$/;"	ft	signature:(Foldable f => Ord a => Ord b => Ord c => f (a, b, c) -> Relation3 a b c -> Relation3 a b c)	line:85	language:Haskell
insertAll	./unison-core/src/Unison/Util/Relation4.hs	/^insertAll :: Foldable f => Ord a => Ord b => Ord c => Ord d$/;"	ft	signature:(Foldable f => Ord a => Ord b => Ord c => Ord d => f (a, b, c, d) -> Relation4 a b c d -> Relation4 a b c d)	line:105	language:Haskell
insertChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^insertChar :: Char -> InsertMode -> InsertMode$/;"	ft	signature:(Char -> InsertMode -> InsertMode)	line:217	language:Haskell
insertChars	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^insertChars :: InputKeyCmd InsertMode InsertMode$/;"	ft	signature:(InputKeyCmd InsertMode InsertMode)	line:66	language:Haskell
insertD1	./parser-typechecker/src/Unison/Util/Star3.hs	/^insertD1 (f,x) s = s { fact = Set.insert f (fact s)$/;"	fi	line:132	language:Haskell
insertD23	./parser-typechecker/src/Unison/Util/Star3.hs	/^insertD23 :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3)	line:154	language:Haskell
insertEnd	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^insertEnd :: (Hashable k, Eq k) => k -> CycleTable k Int -> IO ()$/;"	ft	signature:((Hashable k, Eq k) => k -> CycleTable k Int -> IO ())	line:35	language:Haskell
insertFromCommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^insertFromCommandMode, appendFromCommandMode :: CommandMode -> InsertMode$/;"	ft	signature:(CommandMode -> InsertMode)	line:326	language:Haskell
insertGraphemes	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^insertGraphemes :: [Grapheme] -> InsertMode -> InsertMode$/;"	ft	signature:([Grapheme] -> InsertMode -> InsertMode)	line:247	language:Haskell
insertIntoTree	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^insertIntoTree :: Ord a => ([a], b) -> TreeMap a b -> TreeMap a b$/;"	ft	signature:(Ord a => ([a], b) -> TreeMap a b -> TreeMap a b)	line:160	language:Haskell
insertManyDom	./unison-core/src/Unison/Util/Relation.hs	/^insertManyDom as b r = foldl' (flip $ flip insert b) r as$/;"	fi	line:394	language:Haskell
insertManyRan	./unison-core/src/Unison/Util/Relation.hs	/^insertManyRan a bs r = foldl' (flip $ insert a) r bs$/;"	fi	line:390	language:Haskell
insertString	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^insertString :: String -> InsertMode -> InsertMode$/;"	ft	signature:(String -> InsertMode -> InsertMode)	line:226	language:Haskell
insertTerm	./unison-core/src/Unison/Paths.hs	/^insertTerm :: Var v => Path -> Term v -> Maybe (Term v)$/;"	ft	signature:(Var v => Path -> Term v -> Maybe (Term v))	line:162	language:Haskell
insertWithMetadata	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^insertWithMetadata (a, md) =$/;"	fi	line:39	language:Haskell
inserts	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^inserts :: (Ord a, Ord n) => [(a, Type, Value)] -> Star a n -> Star a n$/;"	ft	signature:((Ord a, Ord n) => [(a, Type, Value)] -> Star a n -> Star a n)	line:34	language:Haskell
installSignalHandlers	./parser-typechecker/unison/Main.hs	/^installSignalHandlers :: IO ()$/;"	ft	signature:(IO ())	line:84	language:Haskell
instantiateL	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instantiateL :: (Var v, Ord loc) => B.Blank loc -> v -> Type v loc -> M v loc ()$/;"	ft	signature:((Var v, Ord loc) => B.Blank loc -> v -> Type v loc -> M v loc ())	line:1430	language:Haskell
instantiateR	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^instantiateR :: (Var v, Ord loc) => Type v loc -> B.Blank loc -> v -> M v loc ()$/;"	ft	signature:((Var v, Ord loc) => Type v loc -> B.Blank loc -> v -> M v loc ())	line:1494	language:Haskell
int	./unison-core/src/Unison/Term.hs	/^int :: Ord v => a -> Int64 -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Int64 -> Term2 vt at ap v a)	line:488	language:Haskell
int	./unison-core/src/Unison/Type.hs	/^int :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:228	language:Haskell
int	./yaks/easytest/src/EasyTest.hs	/^int :: Test Int$/;"	ft	signature:(Test Int)	line:225	language:Haskell
int'	./yaks/easytest/src/EasyTest.hs	/^int' :: Int -> Int -> Test Int$/;"	ft	signature:(Int -> Int -> Test Int)	line:238	language:Haskell
int64	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^int64 :: Test Int64$/;"	ft	signature:(Test Int64)	line:115	language:Haskell
intLiteralSyntaxTip	./parser-typechecker/src/Unison/PrintError.hs	/^intLiteralSyntaxTip term expectedType = case (term, expectedType) of$/;"	fi	line:1194	language:Haskell
intRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
interactionTests	./yaks/haskeline/tests/Unit.hs	/^interactionTests i = "interaction" ~: test$/;"	fi	line:50	language:Haskell
intercalateMap	./unison-core/src/Unison/Util/Monoid.hs	/^intercalateMap :: (Foldable t, Monoid a) => a -> (b -> a) -> t b -> a$/;"	ft	signature:((Foldable t, Monoid a) => a -> (b -> a) -> t b -> a)	line:9	language:Haskell
intercalateMapWith	./unison-core/src/Unison/Util/List.hs	/^intercalateMapWith :: (a -> a -> b) -> (a -> b) -> [a] -> [b]$/;"	ft	signature:((a -> a -> b) -> (a -> b) -> [a] -> [b])	line:46	language:Haskell
intersection	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^intersection :: Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v$/;"	ft	signature:(Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v)	line:31	language:Haskell
intersection	./unison-core/src/Unison/Util/Relation.hs	/^intersection :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b)	line:94	language:Haskell
into	./unison-core/src/Unison/ABT.hs	/^into :: (Foldable f, Ord v) => ABT f v (Term f v ()) -> Term f v ()$/;"	ft	signature:((Foldable f, Ord v) => ABT f v (Term f v ()) -> Term f v ())	line:235	language:Haskell
into'	./unison-core/src/Unison/ABT.hs	/^into' :: (Foldable f, Ord v) => a -> ABT f v (Term f v a) -> Term f v a$/;"	ft	signature:((Foldable f, Ord v) => a -> ABT f v (Term f v a) -> Term f v a)	line:238	language:Haskell
intrinsicTermReferences	./parser-typechecker/src/Unison/Builtin.hs	/^intrinsicTermReferences :: Set R.Reference$/;"	ft	signature:(Set R.Reference)	line:174	language:Haskell
intrinsicTypeReferences	./parser-typechecker/src/Unison/Builtin.hs	/^intrinsicTypeReferences :: Set R.Reference$/;"	ft	signature:(Set R.Reference)	line:167	language:Haskell
introOuter	./unison-core/src/Unison/Type.hs	/^introOuter :: Ord v => a -> v -> Type v a -> Type v a$/;"	ft	signature:(Ord v => a -> v -> Type v a -> Type v a)	line:281	language:Haskell
invalidHist	./yaks/haskeline/tests/Unit.hs	/^invalidHist =  utf8 "abcÎ±" $/;"	fi	line:141	language:Haskell
io	./yaks/easytest/src/EasyTest.hs	/^io :: IO a -> Test a$/;"	ft	signature:(IO a -> Test a)	line:45	language:Haskell
io.Error	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^type io.Error = Error io.ErrorType Text$/;"	t	line:425	language:Haskell
io.Mode	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^type io.Mode = Read | Write | Append | ReadWrite$/;"	t	line:404	language:Haskell
ioErrorId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
ioErrorId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioErrorId = constructorNamed errorReference "io.Error.Error"$/;"	fi	line:97	language:Haskell
ioHash	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioHash, eitherHash, ioModeHash :: R.Id$/;"	ft	signature:(R.Id)	line:63	language:Haskell
ioModeHash	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioHash, eitherHash, ioModeHash :: R.Id$/;"	ft	signature:(R.Id)	line:63	language:Haskell
ioModeHash	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioModeHash = R.unsafeId ioModeReference$/;"	fi	line:66	language:Haskell
ioModeReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioModeReference = typeNamed "io.Mode"$/;"	fi	line:73	language:Haskell
ioReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^ioReference = abilityNamed "io.IO"$/;"	fi	line:70	language:Haskell
ioUnit	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^ioUnit :: Ord v => a -> Type.Type v a$/;"	ft	signature:(Ord v => a -> Type.Type v a)	line:57	language:Haskell
ioctlLayout	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^ioctlLayout :: Handle -> IO (Maybe Layout)$/;"	ft	signature:(Handle -> IO (Maybe Layout))	line:67	language:Haskell
isAllDuplicates	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^isAllDuplicates :: Ord v => SlurpResult v -> Bool$/;"	ft	signature:(Ord v => SlurpResult v -> Bool)	line:350	language:Haskell
isArrow	./unison-core/src/Unison/Type.hs	/^isArrow :: ABT.Var v => Type v a -> Bool$/;"	ft	signature:(ABT.Var v => Type v a -> Bool)	line:187	language:Haskell
isBigWordChar	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^isBigWordChar, isWordChar, isOtherChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:293	language:Haskell
isBlank	./parser-typechecker/src/Unison/TermPrinter.hs	/^isBlank :: String -> Bool$/;"	ft	signature:(String -> Bool)	line:618	language:Haskell
isBuiltinType	./parser-typechecker/src/Unison/Builtin.hs	/^isBuiltinType :: R.Reference -> Bool$/;"	ft	signature:(R.Reference -> Bool)	line:71	language:Haskell
isClosed	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isClosed :: Var v => Term v loc -> M v loc Bool$/;"	ft	signature:(Var v => Term v loc -> M v loc Bool)	line:519	language:Haskell
isClosed	./unison-core/src/Unison/ABT.hs	/^isClosed :: Term f v a -> Bool$/;"	ft	signature:(Term f v a -> Bool)	line:127	language:Haskell
isCombiningChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^isCombiningChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:103	language:Haskell
isConstructor	./unison-core/src/Unison/Referent.hs	/^isConstructor :: Referent -> Bool$/;"	ft	signature:(Referent -> Bool)	line:66	language:Haskell
isConstructor	./unison-core/src/Unison/ShortHash.hs	/^isConstructor :: ShortHash -> Bool$/;"	ft	signature:(ShortHash -> Bool)	line:18	language:Haskell
isCurrentPath	./parser-typechecker/src/Unison/Codebase/Path.hs	/^isCurrentPath :: Path' -> Bool$/;"	ft	signature:(Path' -> Bool)	line:37	language:Haskell
isDelayOrForce	./parser-typechecker/src/Unison/Lexer.hs	/^isDelayOrForce :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:545	language:Haskell
isDelimiter	./parser-typechecker/src/Unison/Lexer.hs	/^isDelimiter :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:748	language:Haskell
isDocLiteral	./parser-typechecker/src/Unison/TermPrinter.hs	/^isDocLiteral :: Term3 v PrintAnnotation -> Bool$/;"	ft	signature:(Term3 v PrintAnnotation -> Bool)	line:550	language:Haskell
isDotU	./parser-typechecker/unison/Main.hs	/^isDotU :: String -> Bool$/;"	ft	signature:(String -> Bool)	line:238	language:Haskell
isEmoji	./parser-typechecker/src/Unison/Lexer.hs	/^isEmoji :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:650	language:Haskell
isEmpty	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^isEmpty :: Branch m -> Bool$/;"	ft	signature:(Branch m -> Bool)	line:598	language:Haskell
isEmpty	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^isEmpty :: BranchDiffOutput v a -> Bool$/;"	ft	signature:(BranchDiffOutput v a -> Bool)	line:66	language:Haskell
isEmpty	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^isEmpty :: SlurpComponent v -> Bool$/;"	ft	signature:(SlurpComponent v -> Bool)	line:20	language:Haskell
isEmpty	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^isEmpty :: Patch -> Bool$/;"	ft	signature:(Patch -> Bool)	line:61	language:Haskell
isEmpty	./unison-core/src/Unison/Codebase/NameSegment.hs	/^isEmpty :: NameSegment -> Bool$/;"	ft	signature:(NameSegment -> Bool)	line:24	language:Haskell
isEmpty	./unison-core/src/Unison/Util/Monoid.hs	/^isEmpty, nonEmpty :: (Eq a, Monoid a) => a -> Bool$/;"	ft	signature:((Eq a, Monoid a) => a -> Bool)	line:22	language:Haskell
isEmpty0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^isEmpty0 :: Branch0 m -> Bool$/;"	ft	signature:(Branch0 m -> Bool)	line:595	language:Haskell
isEmpty0	./unison-core/src/Unison/Names3.hs	/^isEmpty0 :: Names0 -> Bool$/;"	ft	signature:(Names0 -> Bool)	line:80	language:Haskell
isEmptyDiff	./unison-core/src/Unison/Names3.hs	/^isEmptyDiff :: Diff -> Bool$/;"	ft	signature:(Diff -> Bool)	line:77	language:Haskell
isEqual	./parser-typechecker/src/Unison/Typechecker.hs	/^isEqual :: Var v => Type v loc -> Type v loc -> Bool$/;"	ft	signature:(Var v => Type v loc -> Type v loc -> Bool)	line:161	language:Haskell
isEqual	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isEqual t1 t2 =$/;"	fi	line:1771	language:Haskell
isExact	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isExact :: Suggestion v loc -> Bool$/;"	ft	signature:(Suggestion v loc -> Bool)	line:260	language:Haskell
isFailure	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^isFailure :: Ord v => Output v -> Bool$/;"	ft	signature:(Ord v => Output v -> Bool)	line:245	language:Haskell
isFailure	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^isFailure :: Status -> Bool$/;"	ft	signature:(Status -> Bool)	line:133	language:Haskell
isFailure	./parser-typechecker/src/Unison/Result.hs	/^isFailure :: Functor f => ResultT note f a -> f Bool$/;"	ft	signature:(Functor f => ResultT note f a -> f Bool)	line:56	language:Haskell
isFinished	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^                        isFinished :: Bool$/;"	c_a	cons:Completion.Completion	line:39	language:Haskell
isFlag	./parser-typechecker/unison/Main.hs	/^isFlag :: String -> String -> Bool$/;"	ft	signature:(String -> String -> Bool)	line:243	language:Haskell
isFreeIn	./unison-core/src/Unison/ABT.hs	/^isFreeIn :: Ord v => v -> Term f v a -> Bool$/;"	ft	signature:(Ord v => v -> Term f v a -> Bool)	line:131	language:Haskell
isFreeIn	./unison-core/src/Unison/ABT.hs	/^occurrences v t | not (v `isFreeIn` t) = 0$/;"	fi	line:357	language:Haskell
isLam	./unison-core/src/Unison/Term.hs	/^isLam :: Term2 vt at ap v a -> Bool$/;"	ft	signature:(Term2 vt at ap v a -> Bool)	line:585	language:Haskell
isLazy	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  SymbolC { isLazy :: Bool$/;"	c_a	cons:SymbolC.SymbolC	line:63	language:Haskell
isLeaf	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^isLeaf :: ABT.Term (F typeVar typeAnn patternAnn) v a -> Bool$/;"	ft	signature:(ABT.Term (F typeVar typeAnn patternAnn) v a -> Bool)	line:83	language:Haskell
isMarkdown	./parser-typechecker/unison/Main.hs	/^isMarkdown :: String -> Bool$/;"	ft	signature:(String -> Bool)	line:232	language:Haskell
isMultiLine	./parser-typechecker/src/Unison/Util/Range.hs	/^isMultiLine :: Range -> Bool$/;"	ft	signature:(Range -> Bool)	line:15	language:Haskell
isNonempty	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^isNonempty :: Ord v => SlurpResult v -> Bool$/;"	ft	signature:(Ord v => SlurpResult v -> Bool)	line:124	language:Haskell
isNumberedFailure	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^isNumberedFailure :: NumberedOutput v -> Bool$/;"	ft	signature:(NumberedOutput v -> Bool)	line:323	language:Haskell
isOk	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^isOk :: Ord v => SlurpResult v -> Bool$/;"	ft	signature:(Ord v => SlurpResult v -> Bool)	line:342	language:Haskell
isOne	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^isOne :: Branch m -> Bool$/;"	ft	signature:(Branch m -> Bool)	line:610	language:Haskell
isOtherChar	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^isBigWordChar, isWordChar, isOtherChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:293	language:Haskell
isOtherChar	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^isOtherChar = not . (isSpace .||. isWordChar)$/;"	fi	line:296	language:Haskell
isPrefixOf	./unison-core/src/Unison/Codebase/NameSegment.hs	/^isPrefixOf :: NameSegment -> NameSegment -> Bool$/;"	ft	signature:(NameSegment -> NameSegment -> Bool)	line:27	language:Haskell
isPrefixOf	./unison-core/src/Unison/Name.hs	/^isPrefixOf :: Name -> Name -> Bool$/;"	ft	signature:(Name -> Name -> Bool)	line:72	language:Haskell
isPrefixOf	./unison-core/src/Unison/Reference.hs	/^isPrefixOf :: ShortHash -> Reference -> Bool$/;"	ft	signature:(ShortHash -> Reference -> Bool)	line:101	language:Haskell
isPrefixOf	./unison-core/src/Unison/Referent.hs	/^isPrefixOf :: ShortHash -> Referent -> Bool$/;"	ft	signature:(ShortHash -> Referent -> Bool)	line:85	language:Haskell
isPrefixOf	./unison-core/src/Unison/ShortHash.hs	/^isPrefixOf :: ShortHash -> ShortHash -> Bool$/;"	ft	signature:(ShortHash -> ShortHash -> Bool)	line:80	language:Haskell
isPropagatedReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^isPropagatedReference = typeNamed "IsPropagated"$/;"	fi	line:83	language:Haskell
isPropagatedValue	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^isPropagatedValue :: R.Reference$/;"	ft	signature:(R.Reference)	line:89	language:Haskell
isRedundant	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isRedundant userType0 inferredType0 = do$/;"	fi	line:1747	language:Haskell
isReserved	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isReserved :: Var v => v -> M v loc Bool$/;"	ft	signature:(Var v => v -> M v loc Bool)	line:487	language:Haskell
isReservedIn	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isReservedIn :: Var v => v -> Env v loc -> Bool$/;"	ft	signature:(Var v => v -> Env v loc -> Bool)	line:490	language:Haskell
isRoot	./parser-typechecker/src/Unison/Codebase/Path.hs	/^isRoot :: Absolute -> Bool$/;"	ft	signature:(Absolute -> Bool)	line:46	language:Haskell
isRoot'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^isRoot' :: Path' -> Bool$/;"	ft	signature:(Path' -> Bool)	line:43	language:Haskell
isSame	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^isSame :: TermEdit -> Bool$/;"	ft	signature:(TermEdit -> Bool)	line:42	language:Haskell
isSep	./parser-typechecker/src/Unison/Lexer.hs	/^isSep :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:628	language:Haskell
isSpaceNotNewline	./parser-typechecker/src/Unison/Util/Pretty.hs	/^isSpaceNotNewline :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:171	language:Haskell
isSubpath	./parser-typechecker/src/Unison/Path.hs	/^isSubpath :: (Eq p, Path p) => p -> p -> Bool$/;"	ft	signature:((Eq p, Path p) => p -> p -> Bool)	line:32	language:Haskell
isSubtype	./parser-typechecker/src/Unison/Typechecker.hs	/^isSubtype :: Var v => Type v loc -> Type v loc -> Bool$/;"	ft	signature:(Var v => Type v loc -> Type v loc -> Bool)	line:154	language:Haskell
isSubtype	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isSubtype t1 t2 =$/;"	fi	line:1766	language:Haskell
isSubtype'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^isSubtype' :: (Var v, Ord loc) => Type v loc -> Type v loc -> TotalM v loc Bool$/;"	ft	signature:((Var v, Ord loc) => Type v loc -> Type v loc -> TotalM v loc Bool)	line:1727	language:Haskell
isSubtypeTest	./parser-typechecker/tests/Unison/Test/Typechecker.hs	/^isSubtypeTest :: Test ()$/;"	ft	signature:(Test ())	line:16	language:Haskell
isSuccess	./parser-typechecker/src/Unison/Result.hs	/^isSuccess :: Functor f => ResultT note f a -> f Bool$/;"	ft	signature:(Functor f => ResultT note f a -> f Bool)	line:53	language:Haskell
isSymbolic	./parser-typechecker/src/Unison/TermPrinter.hs	/^isSymbolic :: HQ.HashQualified -> Bool$/;"	ft	signature:(HQ.HashQualified -> Bool)	line:608	language:Haskell
isSymbolic'	./parser-typechecker/src/Unison/TermPrinter.hs	/^isSymbolic' :: Name -> Bool$/;"	ft	signature:(Name -> Bool)	line:613	language:Haskell
isTerm	./parser-typechecker/src/Unison/Codebase.hs	/^isTerm :: (Applicative m, Var v, BuiltinAnnotation a)$/;"	ft	signature:((Applicative m, Var v, BuiltinAnnotation a) => Codebase m v a -> Reference -> m Bool)	line:273	language:Haskell
isTerminalStyle	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^isTerminalStyle :: RunTerm -> Bool$/;"	ft	signature:(RunTerm -> Bool)	line:80	language:Haskell
isTest	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^isTest :: (R.Reference, R.Reference)$/;"	ft	signature:((R.Reference, R.Reference))	line:86	language:Haskell
isTestOk	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^isTestOk :: Term v Ann -> Bool$/;"	ft	signature:(Term v Ann -> Bool)	line:1831	language:Haskell
isTestReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^isTestReference = typeNamed "IsTest"$/;"	fi	line:82	language:Haskell
isType	./parser-typechecker/src/Unison/Codebase.hs	/^isType :: Applicative m => Codebase m v a -> Reference -> m Bool$/;"	ft	signature:(Applicative m => Codebase m v a -> Reference -> m Bool)	line:277	language:Haskell
isTypePreserving	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^isTypePreserving :: TermEdit -> Bool$/;"	ft	signature:(TermEdit -> Bool)	line:36	language:Haskell
isUnquoted	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^isUnquoted :: Maybe Char -> String -> String -> Bool$/;"	ft	signature:(Maybe Char -> String -> String -> Bool)	line:154	language:Haskell
isWordChar	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^isBigWordChar, isWordChar, isOtherChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:293	language:Haskell
isWordChar	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^isWordChar = isAlphaNum .||. (=='_')$/;"	fi	line:295	language:Haskell
joinDom	./unison-core/src/Unison/Util/Relation.hs	/^joinDom :: (Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Relation a (b,c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Relation a (b, c))	line:128	language:Haskell
joinDot	./unison-core/src/Unison/Name.hs	/^joinDot :: Name -> Name -> Name$/;"	ft	signature:(Name -> Name -> Name)	line:98	language:Haskell
joinDot	./unison-core/src/Unison/Var.hs	/^joinDot :: Var v => v -> v -> v$/;"	ft	signature:(Var v => v -> v -> v)	line:136	language:Haskell
joinName	./parser-typechecker/src/Unison/TermPrinter.hs	/^joinName :: Prefix -> Suffix -> Name$/;"	ft	signature:(Prefix -> Suffix -> Name)	line:830	language:Haskell
joinRan	./unison-core/src/Unison/Util/Relation.hs	/^joinRan :: (Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Relation (a,b) c$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Relation (a, b) c)	line:133	language:Haskell
keyChoiceCmd	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^keyChoiceCmd :: [KeyCommand m s t] -> Command m s t$/;"	ft	signature:([KeyCommand m s t] -> Command m s t)	line:109	language:Haskell
keyChoiceCmdM	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^keyChoiceCmdM :: [KeyMap (CmdM m a)] -> CmdM m a$/;"	ft	signature:([KeyMap (CmdM m a)] -> CmdM m a)	line:112	language:Haskell
keyCommand	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^keyCommand :: KeyCommand m s t -> Command m s t$/;"	ft	signature:(KeyCommand m s t -> Command m s t)	line:87	language:Haskell
keyDown	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^data InputEvent = KeyEvent {keyDown :: BOOL,$/;"	c_a	cons:InputEvent.KeyEvent	line:119	language:Haskell
keyEventLoop	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^keyEventLoop :: IO [Event] -> TChan Event -> IO Event$/;"	ft	signature:(IO [Event] -> TChan Event -> IO Event)	line:125	language:Haskell
keyFromCode	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^keyFromCode :: WORD -> Maybe BaseKey$/;"	ft	signature:(WORD -> Maybe BaseKey)	line:102	language:Haskell
keywordBlock	./parser-typechecker/src/Unison/TermParser.hs	/^keywordBlock :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:79	language:Haskell
keywords	./parser-typechecker/src/Unison/Lexer.hs	/^keywords :: Set String$/;"	ft	signature:(Set String)	line:702	language:Haskell
killAll	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^killAll :: KillHelper$/;"	ft	signature:(KillHelper)	line:83	language:Haskell
killAndStoreCmd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^killAndStoreCmd :: MonadIO m => KillHelper -> Command (ViT m) (ArgMode CommandMode) CommandMode$/;"	ft	signature:(MonadIO m => KillHelper -> Command (ViT m) (ArgMode CommandMode) CommandMode)	line:385	language:Haskell
killAndStoreI	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^killAndStoreI :: MonadIO m => KillHelper -> Command (ViT m) (ArgMode CommandMode) InsertMode$/;"	ft	signature:(MonadIO m => KillHelper -> Command (ViT m) (ArgMode CommandMode) InsertMode)	line:388	language:Haskell
killAndStoreIE	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^killAndStoreIE :: MonadIO m => KillHelper -> Command (ViT m) (ArgMode CommandMode) EitherMode$/;"	ft	signature:(MonadIO m => KillHelper -> Command (ViT m) (ArgMode CommandMode) EitherMode)	line:391	language:Haskell
killFromArgHelper	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^killFromArgHelper :: (MonadState KillRing m, MonadState Undo m, Save s, Save t)$/;"	ft	signature:((MonadState KillRing m, MonadState Undo m, Save s, Save t) => KillHelper -> Command m (ArgMode s) t)	line:63	language:Haskell
killFromHelper	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^killFromHelper :: (MonadState KillRing m, MonadState Undo m,$/;"	ft	signature:((MonadState KillRing m, MonadState Undo m, Save s, Save t) => KillHelper -> Command m s t)	line:55	language:Haskell
km	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^km >+> g = fmap (>|> g) km$/;"	fi	line:121	language:Haskell
l	./parser-typechecker/src/Unison/TermPrinter.hs	/^l :: IsString s => String -> Pretty s$/;"	ft	signature:(IsString s => String -> Pretty s)	line:605	language:Haskell
lBoxStyle1	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lBoxStyle1, lBoxStyle2, rBoxStyle2 :: IsString s => BoxStyle s$/;"	ft	signature:(IsString s => BoxStyle s)	line:723	language:Haskell
lBoxStyle2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lBoxStyle1, lBoxStyle2, rBoxStyle2 :: IsString s => BoxStyle s$/;"	ft	signature:(IsString s => BoxStyle s)	line:723	language:Haskell
lBoxStyle2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lBoxStyle2 = (("â ","  ")$/;"	fi	line:728	language:Haskell
label	./parser-typechecker/src/Unison/Parser.hs	/^label :: (Ord v, Show a) => String -> P v a -> P v a$/;"	ft	signature:((Ord v, Show a) => String -> P v a -> P v a)	line:194	language:Haskell
labeledDependencies	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^labeledDependencies :: Ord v => SearchResult' v a -> Set LabeledDependency$/;"	ft	signature:(Ord v => SearchResult' v a -> Set LabeledDependency)	line:47	language:Haskell
labeledDependencies	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^labeledDependencies :: Ord v => TodoOutput v a -> Set LabeledDependency$/;"	ft	signature:(Ord v => TodoOutput v a -> Set LabeledDependency)	line:35	language:Haskell
labeledDependencies	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^labeledDependencies :: Patch -> Set LabeledDependency$/;"	ft	signature:(Patch -> Set LabeledDependency)	line:49	language:Haskell
labeledDependencies	./unison-core/src/Unison/Pattern.hs	/^labeledDependencies :: PatternP loc -> Set LabeledDependency$/;"	ft	signature:(PatternP loc -> Set LabeledDependency)	line:198	language:Haskell
labeledDependencies	./unison-core/src/Unison/PatternP.hs	/^labeledDependencies :: P.PatternP loc -> Set LabeledDependency$/;"	ft	signature:(P.PatternP loc -> Set LabeledDependency)	line:41	language:Haskell
labeledDependencies	./unison-core/src/Unison/Term.hs	/^labeledDependencies :: (Ord v, Ord vt)$/;"	ft	signature:((Ord v, Ord vt) => Term2 vt at ap v a -> Set LabeledDependency)	line:875	language:Haskell
lam	./parser-typechecker/src/Unison/TermParser.hs	/^lam :: Var v => TermP v -> TermP v$/;"	ft	signature:(Var v => TermP v -> TermP v)	line:239	language:Haskell
lam	./unison-core/src/Unison/Term.hs	/^lam :: Ord v => a -> v -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> v -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:576	language:Haskell
lam'	./unison-core/src/Unison/Term.hs	/^lam' :: Ord v => a -> [v] -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> [v] -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:579	language:Haskell
lam''	./unison-core/src/Unison/Term.hs	/^lam'' :: Ord v => [(a,v)] -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => [(a, v)] -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:582	language:Haskell
lamCase	./parser-typechecker/src/Unison/TermParser.hs	/^letBlock, handle, lamCase, ifthen :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:244	language:Haskell
lamCase	./parser-typechecker/src/Unison/TermParser.hs	/^lamCase = do$/;"	fi	line:252	language:Haskell
lamToHask	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^lamToHask :: RT.CompilationEnv -> S -> RT.IR -> RT.Value -> IO RT.Result$/;"	ft	signature:(RT.CompilationEnv -> S -> RT.IR -> RT.Value -> IO RT.Result)	line:457	language:Haskell
lambdaLift	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^lambdaLift :: (Var v, Semigroup a) => (v -> v) -> Term v a -> Term v a$/;"	ft	signature:((Var v, Semigroup a) => (v -> v) -> Term v a -> Term v a)	line:41	language:Haskell
language	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^language :: P Text$/;"	ft	signature:(P Text)	line:388	language:Haskell
lastCommand	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^            lastCommand :: SavedCommand m,$/;"	c_a	cons:ViState.ViState	line:21	language:Haskell
lastRow	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                    lastRow :: !Int$/;"	c_a	cons:TermRows.TermRows	line:87	language:Haskell
lastSearch	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^            lastSearch :: [Grapheme]$/;"	c_a	cons:ViState.ViState	line:22	language:Haskell
latin1TestInvalidHist	./yaks/haskeline/tests/Unit.hs	/^latin1TestInvalidHist i input output = test $ do$/;"	fi	line:312	language:Haskell
launch	./parser-typechecker/unison/Main.hs	/^launch :: FilePath -> FilePath -> _ -> [Either Input.Event Input.Input] -> IO ()$/;"	ft	signature:(FilePath -> FilePath -> _ -> [Either Input.Event Input.Input] -> IO ())	line:228	language:Haskell
layoutCloseAndOpenKeywordMap	./parser-typechecker/src/Unison/Lexer.hs	/^layoutCloseAndOpenKeywordMap :: String    -- close-and-open keyword$/;"	ft	signature:(String -> Layout -> BlockName)	line:723	language:Haskell
layoutCloseAndOpenKeywords	./parser-typechecker/src/Unison/Lexer.hs	/^layoutCloseAndOpenKeywords :: Set String$/;"	ft	signature:(Set String)	line:719	language:Haskell
layoutCloseOnlyKeywords	./parser-typechecker/src/Unison/Lexer.hs	/^layoutCloseOnlyKeywords :: Set String$/;"	ft	signature:(Set String)	line:742	language:Haskell
layoutKeywords	./parser-typechecker/src/Unison/Lexer.hs	/^layoutKeywords :: Set String$/;"	ft	signature:(Set String)	line:712	language:Haskell
lca	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^lca :: Monad m => Branch m -> Branch m -> m (Maybe (Branch m))$/;"	ft	signature:(Monad m => Branch m -> Branch m -> m (Maybe (Branch m)))	line:795	language:Haskell
lca	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^lca :: Monad m => Causal m h e -> Causal m h e -> m (Maybe (Causal m h e))$/;"	ft	signature:(Monad m => Causal m h e -> Causal m h e -> m (Maybe (Causal m h e)))	line:166	language:Haskell
lca	./parser-typechecker/src/Unison/Path.hs	/^lca :: Path p => p -> p -> p$/;"	ft	signature:(Path p => p -> p -> p)	line:28	language:Haskell
lca'	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^lca' = go Set.empty Set.empty where$/;"	fi	line:178	language:Haskell
lcaPair	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^lcaPair :: Test (Causal Identity Hash Int64, Causal Identity Hash Int64)$/;"	ft	signature:(Test (Causal Identity Hash Int64, Causal Identity Hash Int64))	line:127	language:Haskell
lcaPairTest	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^lcaPairTest :: Test ()$/;"	ft	signature:(Test ())	line:134	language:Haskell
leafs	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , leafs        :: Maybe (C.Type v loc, C.Type v loc) -- found, expected$/;"	c_a	cons:TypeError.FunctionApplication	line:51	language:Haskell
left	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  left <> right = BranchDiff$/;"	fi	instance:Semigroup BranchDiff	line:188	language:Haskell
left	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^left,right,up :: Int -> TermAction$/;"	ft	signature:(Int -> TermAction)	line:206	language:Haskell
leftPad	./parser-typechecker/src/Unison/Util/Pretty.hs	/^leftPad, rightPad :: IsString s => Int -> Pretty s -> Pretty s$/;"	ft	signature:(IsString s => Int -> Pretty s -> Pretty s)	line:432	language:Haskell
legacyEncoding	./yaks/haskeline/tests/Unit.hs	/^legacyEncoding :: Bool$/;"	ft	signature:(Bool)	line:27	language:Haskell
lengthEncode	./parser-typechecker/src/Unison/Codecs.hs	/^lengthEncode :: MonadPut m => Text -> m ()$/;"	ft	signature:(MonadPut m => Text -> m ())	line:282	language:Haskell
lengthToEnd	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^lengthToEnd :: LineChars -> Int$/;"	ft	signature:(LineChars -> Int)	line:167	language:Haskell
less	./parser-typechecker/src/Unison/Util/Less.hs	/^less :: String -> IO ()$/;"	ft	signature:(String -> IO ())	line:8	language:Haskell
let'	./parser-typechecker/src/Unison/Runtime/IR.hs	/^let' :: Symbol -> IR e cont -> IR e cont -> IR e cont$/;"	ft	signature:(Symbol -> IR e cont -> IR e cont -> IR e cont)	line:860	language:Haskell
let1	./unison-core/src/Unison/Term.hs	/^let1 isTop bindings e = foldr f e bindings$/;"	fi	line:652	language:Haskell
let1'	./unison-core/src/Unison/Term.hs	/^let1' isTop bindings e = foldr f e bindings$/;"	fi	line:661	language:Haskell
let1_	./unison-core/src/Unison/Term.hs	/^let1_ :: Ord v => IsTop -> [(v,Term0' vt v)] -> Term0' vt v -> Term0' vt v$/;"	ft	signature:(Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v)	line:640	language:Haskell
letBlock	./parser-typechecker/src/Unison/TermParser.hs	/^letBlock, handle, lamCase, ifthen :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:244	language:Haskell
letRec	./unison-core/src/Unison/Term.hs	/^letRec _ _ []       e     = e$/;"	fi	line:620	language:Haskell
letRec'	./unison-core/src/Unison/Term.hs	/^letRec' isTop bindings body =$/;"	fi	line:607	language:Haskell
letRec_	./unison-core/src/Unison/Term.hs	/^letRec_ :: Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v$/;"	ft	signature:(Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v)	line:630	language:Haskell
lexKeys	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^lexKeys :: TreeMap Char Key -> [Char] -> [Key]$/;"	ft	signature:(TreeMap Char Key -> [Char] -> [Key])	line:181	language:Haskell
lexedSource	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^lexedSource :: Monad m => SourceName -> Source -> Action' m v (Names, LexedSource)$/;"	ft	signature:(Monad m => SourceName -> Source -> Action' m v (Names, LexedSource))	line:2353	language:Haskell
lexer	./parser-typechecker/src/Unison/Lexer.hs	/^lexer :: String -> String -> [Token Lexeme]$/;"	ft	signature:(String -> String -> [Token Lexeme])	line:226	language:Haskell
lexer0	./parser-typechecker/src/Unison/Lexer.hs	/^lexer0 :: String -> String -> [Token Lexeme]$/;"	ft	signature:(String -> String -> [Token Lexeme])	line:236	language:Haskell
lift	./parser-typechecker/src/Unison/Util/Free.hs	/^instance MonadTrans Free where lift = eval$/;"	fi	instance:MonadTrans Free	line:68	language:Haskell
lift	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    lift = DumbTerm . lift . lift$/;"	fi	instance:MonadTrans DumbTerm	line:30	language:Haskell
lift	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    lift = Draw . lift . lift . lift . lift . lift$/;"	fi	instance:MonadTrans Draw	line:114	language:Haskell
lift	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    lift = Draw . lift$/;"	fi	instance:MonadTrans Draw	line:268	language:Haskell
lift	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    lift m = CmdM $ do$/;"	fi	instance:MonadTrans CmdM	line:83	language:Haskell
lift	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^    lift = InputT . lift . lift . lift . lift . lift$/;"	fi	instance:MonadTrans InputT	line:56	language:Haskell
lift	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    lift m = StateT $ \\s -> do$/;"	fi	instance:MonadTrans (StateT s)	line:88	language:Haskell
liftIO	./yaks/easytest/src/EasyTest.hs	/^  liftIO io = do$/;"	fi	instance:MonadIO Test	line:400	language:Haskell
liftIO	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    liftIO = lift . liftIO$/;"	fi	instance:MonadIO m => MonadIO (StateT s m)	line:93	language:Haskell
liftIOOp	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^liftIOOp :: MonadException m => ((a -> IO (m b)) -> IO (m c)) -> (a -> m b) -> m c$/;"	ft	signature:(MonadException m => ((a -> IO (m b)) -> IO (m c)) -> (a -> m b) -> m c)	line:83	language:Haskell
liftIOOp_	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^liftIOOp_ :: MonadException m => (IO (m a) -> IO (m a)) -> m a -> m a$/;"	ft	signature:(MonadException m => (IO (m a) -> IO (m a)) -> m a -> m a)	line:93	language:Haskell
liftResult	./parser-typechecker/src/Unison/Typechecker.hs	/^liftResult :: Monad f => Result (Notes v loc) a -> TDNR f v loc a$/;"	ft	signature:(Monad f => Result (Notes v loc) a -> TDNR f v loc a)	line:196	language:Haskell
liftResult	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^liftResult :: Result v loc a -> M v loc a$/;"	ft	signature:(Result v loc a -> M v loc a)	line:186	language:Haskell
liftTerm	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^liftTerm :: Ord v => Term v a -> Term' (TypeVar b v) v a$/;"	ft	signature:(Ord v => Term v a -> Term' (TypeVar b v) v a)	line:50	language:Haskell
liftTotalM	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^liftTotalM :: TotalM v loc a -> M v loc a$/;"	ft	signature:(TotalM v loc a -> M v loc a)	line:189	language:Haskell
liftType	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^liftType :: Ord v => Type v a -> Type (TypeVar b v) a$/;"	ft	signature:(Ord v => Type v a -> Type (TypeVar b v) a)	line:44	language:Haskell
line	./parser-typechecker/src/Unison/Lexer.hs	/^line :: Pos -> Line$/;"	ft	signature:(Pos -> Line)	line:133	language:Haskell
line	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  Delta { line :: !Int, col :: !Int, maxCol :: !Int }$/;"	c_a	cons:Delta.Delta	line:646	language:Haskell
lineChange	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^lineChange :: LineState s => s -> Effect$/;"	ft	signature:(LineState s => s -> Effect)	line:43	language:Haskell
lineChars	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^lineChars :: LineState s => Prefix -> s -> LineChars$/;"	ft	signature:(LineState s => Prefix -> s -> LineChars)	line:163	language:Haskell
lineOffset	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  { lineOffset  :: Line$/;"	c_a	cons:AnnotatedExcerpt.AnnotatedExcerpt	line:79	language:Haskell
lineSkip	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lineSkip :: IsString s => Pretty s$/;"	ft	signature:(IsString s => Pretty s)	line:286	language:Haskell
lineToken	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^lineToken :: P a -> P a$/;"	ft	signature:(P a -> P a)	line:371	language:Haskell
lines	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lines :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:382	language:Haskell
linesNonEmpty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^linesNonEmpty :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:386	language:Haskell
linesSpaced	./parser-typechecker/src/Unison/Util/Pretty.hs	/^linesSpaced :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:389	language:Haskell
link	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^link :: InputPattern$/;"	ft	signature:(InputPattern)	line:1039	language:Haskell
link	./parser-typechecker/src/Unison/TermParser.hs	/^link :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:107	language:Haskell
link'	./parser-typechecker/src/Unison/TermParser.hs	/^link' :: Var v => P v (Either (L.Token Reference) (L.Token Referent))$/;"	ft	signature:(Var v => P v (Either (L.Token Reference) (L.Token Referent)))	line:98	language:Haskell
linkRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef :: Reference$/;"	ft	signature:(Reference)	line:409	language:Haskell
linkTermId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
linkTypeId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
links	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^links :: InputPattern$/;"	ft	signature:(InputPattern)	line:1060	language:Haskell
listBranch	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^listBranch :: Branch0 m -> [SearchResult]$/;"	ft	signature:(Branch0 m -> [SearchResult])	line:1754	language:Haskell
listCompletionsImmediately	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     listCompletionsImmediately :: !Bool,$/;"	c_a	cons:Prefs.Prefs	line:44	language:Haskell
listFiles	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^listFiles :: MonadIO m => FilePath -> m [Completion]$/;"	ft	signature:(MonadIO m => FilePath -> m [Completion])	line:161	language:Haskell
listOf	./yaks/easytest/src/EasyTest.hs	/^listOf :: Int -> Test a -> Test [a]$/;"	ft	signature:(Int -> Test a -> Test [a])	line:280	language:Haskell
listOfDefinitions	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^listOfDefinitions ::$/;"	ft	signature:(Var v => PPE.PrettyPrintEnv -> E.ListDetailed -> [SR'.SearchResult' v a] -> IO Pretty)	line:1275	language:Haskell
listOfDefinitions'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^listOfDefinitions' :: Var v$/;"	ft	signature:(Var v => PPE.PrettyPrintEnv -> E.ListDetailed -> [SR'.SearchResult' v a] -> Pretty)	line:1654	language:Haskell
listOfLinks	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^listOfLinks ::$/;"	ft	signature:(Var v => PPE.PrettyPrintEnv -> [(HQ.HashQualified, Maybe (Type v a))] -> IO Pretty)	line:1280	language:Haskell
listRestore	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^listRestore :: Save s => [Grapheme] -> s$/;"	ft	signature:(Save s => [Grapheme] -> s)	line:180	language:Haskell
listSave	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^listSave :: Save s => s -> [Grapheme]$/;"	ft	signature:(Save s => s -> [Grapheme])	line:177	language:Haskell
listToTree	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^listToTree :: Ord a => [([a],b)] -> TreeMap a b$/;"	ft	signature:(Ord a => [([a], b)] -> TreeMap a b)	line:172	language:Haskell
listsOf	./yaks/easytest/src/EasyTest.hs	/^listsOf :: [Int] -> Test a -> Test [[a]]$/;"	ft	signature:([Int] -> Test a -> Test [[a]])	line:285	language:Haskell
lit	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lit :: (IsString s, LL.ListLike s Char) => s -> Pretty s$/;"	ft	signature:((IsString s, LL.ListLike s Char) => s -> Pretty s)	line:142	language:Haskell
lit'	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lit' :: Delta -> s -> Pretty s$/;"	ft	signature:(Delta -> s -> Pretty s)	line:145	language:Haskell
load	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^load :: InputPattern$/;"	ft	signature:(InputPattern)	line:119	language:Haskell
loadDisplayInfo	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadDisplayInfo ::$/;"	ft	signature:(Set Reference -> Action m i v ([(Reference, Maybe (Type v Ann))], [(Reference, DisplayThing (DD.Decl v Ann))]))	line:2323	language:Haskell
loadPropagateDiffDefaultPatch	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadPropagateDiffDefaultPatch :: (Monad m, Var v) =>$/;"	ft	signature:((Monad m, Var v) => InputDescription -> Maybe Path.Path' -> Path.Absolute -> Action' m v ())	line:1932	language:Haskell
loadPullRequest	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^loadPullRequest :: InputPattern$/;"	ft	signature:(InputPattern)	line:721	language:Haskell
loadReferencesByPrefix	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^loadReferencesByPrefix dir sh = liftIO $ do$/;"	fi	line:576	language:Haskell
loadReferentType	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadReferentType :: Referent -> _ (Maybe (Type _ _))$/;"	ft	signature:(Referent -> _ (Maybe (Type _ _)))	line:2333	language:Haskell
loadRemoteBranch	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadRemoteBranch :: RemoteNamespace -> Action' m v (Either GitError (Branch m))$/;"	ft	signature:(RemoteNamespace -> Action' m v (Either GitError (Branch m)))	line:1944	language:Haskell
loadSearchResults	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadSearchResults :: Ord v => [SR.SearchResult] -> Action m i v [SearchResult' v Ann]$/;"	ft	signature:(Ord v => [SR.SearchResult] -> Action m i v [SearchResult' v Ann])	line:2312	language:Haskell
loadTypeDisplayThing	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadTypeDisplayThing :: Reference -> _ (DisplayThing (DD.Decl _ _))$/;"	ft	signature:(Reference -> _ (DisplayThing (DD.Decl _ _)))	line:2347	language:Haskell
loadTypeOfTerm	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loadTypeOfTerm :: Referent -> Action m i v (Maybe (Type v Ann))$/;"	ft	signature:(Referent -> Action m i v (Maybe (Type v Ann)))	line:2596	language:Haskell
loc	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^loc :: ABT.Term f v loc -> loc$/;"	ft	signature:(ABT.Term f v loc -> loc)	line:725	language:Haskell
loc	./unison-core/src/Unison/Blank.hs	/^loc :: Recorded loc -> loc$/;"	ft	signature:(Recorded loc -> loc)	line:5	language:Haskell
loc	./unison-core/src/Unison/Pattern.hs	/^loc :: PatternP loc -> loc$/;"	ft	signature:(PatternP loc -> loc)	line:85	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Unbound loc = P.UnboundP loc$/;"	fi	line:13	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Var loc = P.VarP loc$/;"	fi	line:14	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Boolean loc b = P.BooleanP loc b$/;"	fi	line:15	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Int loc n = P.IntP loc n$/;"	fi	line:16	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Nat loc n = P.NatP loc n$/;"	fi	line:17	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Float loc n = P.FloatP loc n$/;"	fi	line:18	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Text loc t = P.TextP loc t$/;"	fi	line:19	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Char loc c = P.CharP loc c$/;"	fi	line:20	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern Constructor loc r cid ps = P.ConstructorP loc r cid ps$/;"	fi	line:21	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern As loc p = P.AsP loc p$/;"	fi	line:22	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern EffectPure loc p = P.EffectPureP loc p$/;"	fi	line:23	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern EffectBind loc r c args k = P.EffectBindP loc r c args k$/;"	fi	line:24	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern SequenceLiteral loc ps = P.SequenceLiteralP loc ps$/;"	fi	line:25	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^pattern SequenceOp loc l op r = P.SequenceOpP loc l op r$/;"	fi	line:26	language:Haskell
loc	./unison-core/src/Unison/PatternP.hs	/^loc :: P.PatternP loc -> loc$/;"	ft	signature:(P.PatternP loc -> loc)	line:35	language:Haskell
local	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  local f m = MT $ runM m . f$/;"	fi	instance:Monad f => MonadReader (MEnv v loc) (MT v loc f)	line:1813	language:Haskell
local	./yaks/easytest/src/EasyTest.hs	/^  local f (Test t) = Test (local f t)$/;"	fi	instance:MonadReader Env Test	line:373	language:Haskell
logAt	./parser-typechecker/src/Unison/Util/Logger.hs	/^logAt :: Logger -> Level -> String -> IO ()$/;"	ft	signature:(Logger -> Level -> String -> IO ())	line:65	language:Haskell
logAt'	./parser-typechecker/src/Unison/Util/Logger.hs	/^logAt' :: Logger -> Level -> IO String -> IO ()$/;"	ft	signature:(Logger -> Level -> IO String -> IO ())	line:61	language:Haskell
logHandleAt	./parser-typechecker/src/Unison/Util/Logger.hs	/^logHandleAt :: Logger -> Level -> Handle -> IO ()$/;"	ft	signature:(Logger -> Level -> Handle -> IO ())	line:50	language:Haskell
logger	./parser-typechecker/src/Unison/Util/Logger.hs	/^logger :: (String -> IO ()) -> Logger$/;"	ft	signature:((String -> IO ()) -> Logger)	line:78	language:Haskell
loginTTY	./yaks/haskeline/tests/Pty.hs	/^loginTTY :: Fd -> IO ()$/;"	ft	signature:(Fd -> IO ())	line:96	language:Haskell
lookAhead	./parser-typechecker/src/Unison/Parser.hs	/^lookAhead :: Ord v => P v a -> P v a$/;"	ft	signature:(Ord v => P v a -> P v a)	line:215	language:Haskell
lookup	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^lookup :: (Hashable k, Eq k) => k -> CycleTable k v -> IO (Maybe v)$/;"	ft	signature:((Hashable k, Eq k) => k -> CycleTable k v -> IO (Maybe v))	line:24	language:Haskell
lookupAnn	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^lookupAnn :: Ord v => Context v loc -> v -> Maybe (Type v loc)$/;"	ft	signature:(Ord v => Context v loc -> v -> Maybe (Type v loc))	line:1143	language:Haskell
lookupCells	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^lookupCells :: TermRows -> Int -> Int$/;"	ft	signature:(TermRows -> Int -> Int)	line:101	language:Haskell
lookupChars	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^lookupChars :: TreeMap Char Key -> [Char] -> Maybe (Key,[Char])$/;"	ft	signature:(TreeMap Char Key -> [Char] -> Maybe (Key, [Char]))	line:192	language:Haskell
lookupD1	./parser-typechecker/src/Unison/Util/Star3.hs	/^lookupD1 :: (Ord fact, Ord d1) => d1 -> Star3 fact d1 d2 d3 -> Set fact$/;"	ft	signature:((Ord fact, Ord d1) => d1 -> Star3 fact d1 d2 d3 -> Set fact)	line:124	language:Haskell
lookupD1	./unison-core/src/Unison/Util/Relation3.hs	/^lookupD1 :: (Ord a, Ord b, Ord c) => a -> Relation3 a b c -> Relation b c$/;"	ft	signature:((Ord a, Ord b, Ord c) => a -> Relation3 a b c -> Relation b c)	line:40	language:Haskell
lookupD2	./unison-core/src/Unison/Util/Relation3.hs	/^lookupD2 :: (Ord a, Ord b, Ord c) => b -> Relation3 a b c -> Relation a c$/;"	ft	signature:((Ord a, Ord b, Ord c) => b -> Relation3 a b c -> Relation a c)	line:43	language:Haskell
lookupD3	./unison-core/src/Unison/Util/Relation3.hs	/^lookupD3 :: (Ord a, Ord b, Ord c) => c -> Relation3 a b c -> Relation a b$/;"	ft	signature:((Ord a, Ord b, Ord c) => c -> Relation3 a b c -> Relation a b)	line:46	language:Haskell
lookupDecl	./parser-typechecker/src/Unison/UnisonFile.hs	/^lookupDecl :: Ord v => v -> TypecheckedUnisonFile v a$/;"	ft	signature:(Ord v => v -> TypecheckedUnisonFile v a -> Maybe (Reference, Either (EffectDeclaration' v a) (DataDeclaration' v a)))	line:109	language:Haskell
lookupDom	./unison-core/src/Unison/Util/Relation.hs	/^lookupDom :: Ord a => a -> Relation a b -> Set b$/;"	ft	signature:(Ord a => a -> Relation a b -> Set b)	line:399	language:Haskell
lookupDom'	./unison-core/src/Unison/Util/Relation.hs	/^lookupDom' :: Ord a => a -> Relation a b -> Maybe (Set b)$/;"	ft	signature:(Ord a => a -> Relation a b -> Maybe (Set b))	line:211	language:Haskell
lookupHQPattern	./unison-core/src/Unison/Names3.hs	/^lookupHQPattern :: HQ.HashQualified -> Names -> Set (Reference, Int)$/;"	ft	signature:(HQ.HashQualified -> Names -> Set (Reference, Int))	line:187	language:Haskell
lookupHQTerm	./unison-core/src/Unison/Names3.hs	/^lookupHQTerm :: HashQualified -> Names -> Set Referent$/;"	ft	signature:(HashQualified -> Names -> Set Referent)	line:148	language:Haskell
lookupHQType	./unison-core/src/Unison/Names3.hs	/^lookupHQType :: HashQualified -> Names -> Set Reference$/;"	ft	signature:(HashQualified -> Names -> Set Reference)	line:128	language:Haskell
lookupKM	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^data KeyMap a = KeyMap {lookupKM :: Key -> Maybe (KeyConsumed a)}$/;"	c_a	cons:KeyMap.KeyMap	line:46	language:Haskell
lookupKeyBinding	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^lookupKeyBinding :: Key -> Prefs -> [Key]$/;"	ft	signature:(Key -> Prefs -> [Key])	line:123	language:Haskell
lookupRan	./unison-core/src/Unison/Util/Relation.hs	/^lookupRan :: Ord b => b -> Relation a b -> Set a$/;"	ft	signature:(Ord b => b -> Relation a b -> Set a)	line:396	language:Haskell
lookupRan'	./unison-core/src/Unison/Util/Relation.hs	/^lookupRan' :: Ord b => b -> Relation a b -> Maybe (Set a)$/;"	ft	signature:(Ord b => b -> Relation a b -> Maybe (Set a))	line:215	language:Haskell
lookupSolved	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^lookupSolved :: Ord v => Context v loc -> v -> Maybe (Monotype v loc)$/;"	ft	signature:(Ord v => Context v loc -> v -> Maybe (Monotype v loc))	line:1146	language:Haskell
loop	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loop :: forall m v . (Monad m, Var v) => Action m (Either Event Input) v ()$/;"	ft	signature:(forall m v . (Monad m, Var v) => Action m (Either Event Input) v ())	line:183	language:Haskell
loopState0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^loopState0 :: Branch m -> Path.Absolute -> LoopState m v$/;"	ft	signature:(Branch m -> Path.Absolute -> LoopState m v)	line:175	language:Haskell
lowerTerm	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^lowerTerm :: Ord v => Term' (TypeVar b v) v a -> Term v a$/;"	ft	signature:(Ord v => Term' (TypeVar b v) v a -> Term v a)	line:53	language:Haskell
lowerType	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^lowerType :: Ord v => Type (TypeVar b v) a -> Type v a$/;"	ft	signature:(Ord v => Type (TypeVar b v) a -> Type v a)	line:47	language:Haskell
m	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  m >>= f = MT go where$/;"	fi	instance:Monad f => Monad (MT v loc f)	line:1796	language:Haskell
main	./parser-typechecker/prettyprintdemo/Main.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:9	language:Haskell
main	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^main dir initialPath configFile initialInputs startRuntime codebase = do$/;"	fi	line:162	language:Haskell
main	./parser-typechecker/tests/Suite.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:61	language:Haskell
main	./parser-typechecker/tests/Unison/Test/Transcripts.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:45	language:Haskell
main	./parser-typechecker/unison/Main.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:98	language:Haskell
main	./unison-src/parser-tests/GenerateErrors.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:47	language:Haskell
main	./yaks/easytest/tests/Suite.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:20	language:Haskell
main	./yaks/haskeline/Setup.hs	/^main = defaultMain$/;"	fi	line:2	language:Haskell
main	./yaks/haskeline/examples/Test.hs	/^main :: IO ()$/;"	ft	signature:(IO ())	line:21	language:Haskell
main	./yaks/haskeline/tests/Unit.hs	/^main = do$/;"	fi	line:38	language:Haskell
mainTypes	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^mainTypes :: Ord v => a -> [Type v a]$/;"	ft	signature:(Ord v => a -> [Type v a])	line:64	language:Haskell
makeAbsolute	./unison-core/src/Unison/Name.hs	/^makeAbsolute :: Name -> Name$/;"	ft	signature:(Name -> Name)	line:126	language:Haskell
makeAbsolute0	./unison-core/src/Unison/Names3.hs	/^makeAbsolute0:: Names0 -> Names0$/;"	ft	signature:(Names0 -> Names0)	line:124	language:Haskell
makeAddTermName	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeAddTermName :: Path.Split -> Referent -> Metadata -> (Path, Branch0 m -> Branch0 m)$/;"	ft	signature:(Path.Split -> Referent -> Metadata -> (Path, Branch0 m -> Branch0 m))	line:99	language:Haskell
makeAddTypeName	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeAddTypeName :: Path.Split -> Reference -> Metadata -> (Path, Branch0 m -> Branch0 m)$/;"	ft	signature:(Path.Split -> Reference -> Metadata -> (Path, Branch0 m -> Branch0 m))	line:111	language:Haskell
makeDeletePatch	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeDeletePatch :: Path.Split -> (Path, Branch0 m -> Branch0 m)$/;"	ft	signature:(Path.Split -> (Path, Branch0 m -> Branch0 m))	line:108	language:Haskell
makeDeleteTermName	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeDeleteTermName :: Path.Split -> Referent -> (Path, Branch0 m -> Branch0 m)$/;"	ft	signature:(Path.Split -> Referent -> (Path, Branch0 m -> Branch0 m))	line:102	language:Haskell
makeDeleteTypeName	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeDeleteTypeName :: Path.Split -> Reference -> (Path, Branch0 m -> Branch0 m)$/;"	ft	signature:(Path.Split -> Reference -> (Path, Branch0 m -> Branch0 m))	line:114	language:Haskell
makeExample	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^makeExample, makeExampleNoBackticks :: InputPattern -> [P.Pretty CT.ColorText] -> P.Pretty CT.ColorText$/;"	ft	signature:(InputPattern -> [P.Pretty CT.ColorText] -> P.Pretty CT.ColorText)	line:57	language:Haskell
makeExample'	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^makeExample' :: InputPattern -> P.Pretty CT.ColorText$/;"	ft	signature:(InputPattern -> P.Pretty CT.ColorText)	line:63	language:Haskell
makeExampleEOS	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^makeExampleEOS ::$/;"	ft	signature:(InputPattern -> [P.Pretty CT.ColorText] -> P.Pretty CT.ColorText)	line:66	language:Haskell
makeExampleNoBackticks	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^makeExample, makeExampleNoBackticks :: InputPattern -> [P.Pretty CT.ColorText] -> P.Pretty CT.ColorText$/;"	ft	signature:(InputPattern -> [P.Pretty CT.ColorText] -> P.Pretty CT.ColorText)	line:57	language:Haskell
makeExampleNoBackticks	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^makeExampleNoBackticks p args =$/;"	fi	line:60	language:Haskell
makeHistoricalParsingNames	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^makeHistoricalParsingNames ::$/;"	ft	signature:(Monad m => Set HQ.HashQualified -> Action' m v Names)	line:2479	language:Haskell
makeLazy	./parser-typechecker/src/Unison/Runtime/IR.hs	/^makeLazy :: SymbolC -> SymbolC$/;"	ft	signature:(SymbolC -> SymbolC)	line:69	language:Haskell
makeLines	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^makeLines :: [String] -> Layout -> [String]$/;"	ft	signature:([String] -> Layout -> [String])	line:119	language:Haskell
makePartialCompletion	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^makePartialCompletion :: InsertMode -> [Completion] -> InsertMode$/;"	ft	signature:(InsertMode -> [Completion] -> InsertMode)	line:63	language:Haskell
makePassingTest	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^makePassingTest rt how filepath = scope (shortName filepath) $ do$/;"	fi	line:122	language:Haskell
makePrintNamesFromLabeled'	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^makePrintNamesFromLabeled' deps = do$/;"	fi	line:2457	language:Haskell
makeReplacePatch	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeReplacePatch :: Applicative m => Path.Split -> Patch -> (Path, Branch0 m -> Branch0 m)$/;"	ft	signature:(Applicative m => Path.Split -> Patch -> (Path, Branch0 m -> Branch0 m))	line:105	language:Haskell
makeSelfContained'	./parser-typechecker/src/Unison/Codebase.hs	/^makeSelfContained' code uf = do$/;"	fi	line:200	language:Haskell
makeSetBranch	./parser-typechecker/src/Unison/Codebase/BranchUtil.hs	/^makeSetBranch ::$/;"	ft	signature:(Path.Split -> Branch m -> (Path, Branch0 m -> Branch0 m))	line:118	language:Haskell
makeShadowedPrintNamesFromHQ	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^makeShadowedPrintNamesFromHQ :: Monad m => Set HQ.HashQualified -> Names0 -> Action' m v Names$/;"	ft	signature:(Monad m => Set HQ.HashQualified -> Names0 -> Action' m v Names)	line:2443	language:Haskell
makeShadowedPrintNamesFromLabeled	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^makeShadowedPrintNamesFromLabeled ::$/;"	ft	signature:(Monad m => Set LabeledDependency -> Names0 -> Action' m v Names)	line:2392	language:Haskell
makeStateT	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^makeStateT :: Monad m => (s -> m (a,s)) -> StateT s m a$/;"	ft	signature:(Monad m => (s -> m (a, s)) -> StateT s m a)	line:103	language:Haskell
makeTranscript	./parser-typechecker/tests/Unison/Test/Git.hs	/^makeTranscript :: FilePath -> Text$/;"	ft	signature:(FilePath -> Text)	line:44	language:Haskell
malformedEffectBind	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^malformedEffectBind = cause >>= \\case$/;"	fi	line:273	language:Haskell
manyDom	./unison-core/src/Unison/Util/Relation.hs	/^manyDom :: Ord a => a -> Relation a b -> Bool$/;"	ft	signature:(Ord a => a -> Relation a b -> Bool)	line:260	language:Haskell
manyRan	./unison-core/src/Unison/Util/Relation.hs	/^manyRan :: Ord b => b -> Relation a b -> Bool$/;"	ft	signature:(Ord b => b -> Relation a b -> Bool)	line:263	language:Haskell
map	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^map :: (UV.Unbox a, UV.Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b$/;"	ft	signature:((UV.Unbox a, UV.Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b)	line:25	language:Haskell
map	./parser-typechecker/src/Unison/Util/Pretty.hs	/^map :: LL.ListLike s2 Char => (s -> s2) -> Pretty s -> Pretty s2$/;"	ft	signature:(LL.ListLike s2 Char => (s -> s2) -> Pretty s -> Pretty s2)	line:794	language:Haskell
map	./unison-core/src/Unison/Util/Relation.hs	/^map :: (Ord a, Ord b, Ord c, Ord d)$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => ((a, b) -> (c, d)) -> Relation a b -> Relation c d)	line:432	language:Haskell
map0	./unison-core/src/Unison/Names3.hs	/^map0 :: (Name -> Name) -> Names0 -> Names0$/;"	ft	signature:((Name -> Name) -> Names0 -> Names0)	line:103	language:Haskell
mapBaseChars	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^mapBaseChars :: (Char -> Char) -> [Grapheme] -> [Grapheme]$/;"	ft	signature:((Char -> Char) -> [Grapheme] -> [Grapheme])	line:89	language:Haskell
mapD1	./parser-typechecker/src/Unison/Util/Star3.hs	/^mapD1 :: (Ord fact, Ord d1, Ord d1a) => (d1 -> d1a) -> Star3 fact d1 d2 d3 -> Star3 fact d1a d2 d3$/;"	ft	signature:((Ord fact, Ord d1, Ord d1a) => (d1 -> d1a) -> Star3 fact d1 d2 d3 -> Star3 fact d1a d2 d3)	line:71	language:Haskell
mapD2	./parser-typechecker/src/Unison/Util/Star3.hs	/^mapD2 :: (Ord fact, Ord d2, Ord d2a) => (d2 -> d2a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2a d3$/;"	ft	signature:((Ord fact, Ord d2, Ord d2a) => (d2 -> d2a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2a d3)	line:74	language:Haskell
mapD2	./unison-core/src/Unison/Util/Relation4.hs	/^mapD2 :: (Ord a, Ord b, Ord b', Ord c, Ord d)$/;"	ft	signature:((Ord a, Ord b, Ord b', Ord c, Ord d) => (b -> b') -> Relation4 a b c d -> Relation4 a b' c d)	line:101	language:Haskell
mapD3	./parser-typechecker/src/Unison/Util/Star3.hs	/^mapD3 :: (Ord fact, Ord d3, Ord d3a) => (d3 -> d3a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3a$/;"	ft	signature:((Ord fact, Ord d3, Ord d3a) => (d3 -> d3a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3a)	line:77	language:Haskell
mapDom	./unison-core/src/Unison/Util/Relation.hs	/^mapDom :: (Ord a, Ord a', Ord b) => (a -> a') -> Relation a b -> Relation a' b$/;"	ft	signature:((Ord a, Ord a', Ord b) => (a -> a') -> Relation a b -> Relation a' b)	line:437	language:Haskell
mapErrors	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^mapErrors :: (ErrorNote v loc -> ErrorNote v loc) -> Result v loc a -> Result v loc a$/;"	ft	signature:((ErrorNote v loc -> ErrorNote v loc) -> Result v loc a -> Result v loc a)	line:169	language:Haskell
mapEvalTerm	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^mapEvalTerm :: (forall a . n a -> m a) -> (forall a . m a -> n a)$/;"	ft	signature:((forall a . n a -> m a) -> (forall a . m a -> n a) -> EvalTerm n -> EvalTerm m)	line:91	language:Haskell
mapInputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^mapInputT :: (forall b . m b -> m b) -> InputT m a -> InputT m a$/;"	ft	signature:((forall b . m b -> m b) -> InputT m a -> InputT m a)	line:159	language:Haskell
mapLines	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^mapLines :: (Show a, Show b) => TreeMap a b -> [String]$/;"	ft	signature:((Show a, Show b) => TreeMap a b -> [String])	line:176	language:Haskell
mapLit	./parser-typechecker/src/Unison/Util/Pretty.hs	/^mapLit :: (s -> t) -> F s r -> F t r$/;"	ft	signature:((s -> t) -> F s r -> F t r)	line:134	language:Haskell
mapOf	./yaks/easytest/src/EasyTest.hs	/^mapOf :: Ord k => Int -> Test k -> Test v -> Test (Map k v)$/;"	ft	signature:(Ord k => Int -> Test k -> Test v -> Test (Map k v))	line:293	language:Haskell
mapRan	./unison-core/src/Unison/Util/Relation.hs	/^mapRan :: (Ord a, Ord b, Ord b') => (b -> b') -> Relation a b -> Relation a b'$/;"	ft	signature:((Ord a, Ord b, Ord b') => (b -> b') -> Relation a b -> Relation a b')	line:441	language:Haskell
mapStateT	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^mapStateT :: (forall b . m b -> n b) -> StateT s m a -> StateT s n a$/;"	ft	signature:((forall b . m b -> n b) -> StateT s m a -> StateT s n a)	line:95	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  mappend = (<>)$/;"	fi	instance:Monoid BranchDiff	line:198	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  mappend = (<>)$/;"	fi	instance:Monoid BranchAttentions	line:828	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  mappend r1 r2 = RefCollisions (termCollisions r1 <> termCollisions r2)$/;"	fi	instance:Monoid RefCollisions	line:839	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^  c1 `mappend` c2 = CodeLookup tm ty where$/;"	fi	instance:Monad m => Monoid (CodeLookup v m a)	line:51	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  mappend = (<>)$/;"	fi	instance:Monoid (MetadataDiff tm)	line:45	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^  c1 `mappend` c2 = SlurpComponent (types c1 <> types c2)$/;"	fi	instance:Ord v => Monoid (SlurpComponent v)	line:39	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  mappend = (<>)$/;"	fi	instance:Monoid Patch	line:120	language:Haskell
mappend	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  mappend = (<>)$/;"	fi	instance:Monoid PatchDiff	line:136	language:Haskell
mappend	./parser-typechecker/src/Unison/Lexer.hs	/^  Pos line col `mappend` Pos line2 col2 =$/;"	fi	instance:Monoid Pos	line:129	language:Haskell
mappend	./parser-typechecker/src/Unison/Parser.hs	/^  mappend (UniqueName f) (UniqueName g) =$/;"	fi	instance:Monoid UniqueName	line:60	language:Haskell
mappend	./parser-typechecker/src/Unison/Parser.hs	/^  mappend = (<>)$/;"	fi	instance:Monoid Ann	line:121	language:Haskell
mappend	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  mappend = unionLeft$/;"	fi	instance:Monoid PrettyPrintEnv	line:117	language:Haskell
mappend	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  mappend c1 c2 = CompilationEnv ir ctor where$/;"	fi	instance:Monoid (CompilationEnv e cont)	line:989	language:Haskell
mappend	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  mappend = mplus$/;"	fi	instance:Monoid (SubseqExtractor' n a)	line:345	language:Haskell
mappend	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^  mappend (TypeLookup a b c) (TypeLookup a2 b2 c2) =$/;"	fi	instance:Monoid (TypeLookup v a)	line:60	language:Haskell
mappend	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  mappend (Bytes b1) (Bytes b2) = Bytes (b1 `mappend` b2)$/;"	fi	instance:Monoid Bytes	line:79	language:Haskell
mappend	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  mappend p1 p2 = Pretty (delta p1 <> delta p2) .$/;"	fi	instance:Monoid (Pretty s)	line:638	language:Haskell
mappend	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  mappend (Delta l c mc) (Delta 0 c2 mc2) =$/;"	fi	instance:Monoid Delta	line:652	language:Haskell
mappend	./parser-typechecker/src/Unison/Util/Star3.hs	/^  s1 `mappend` s2 = Star3 fact' d1' d2' d3' where$/;"	fi	instance:(Ord fact, Ord d1, Ord d2, Ord d3) => Monoid (Star3 fact d1 d2 d3)	line:192	language:Haskell
mappend	./unison-core/src/Unison/ABT.hs	/^  mappend (Path p1) (Path p2) = Path p3 where$/;"	fi	instance:Monoid (Path s t a b m)	line:66	language:Haskell
mappend	./unison-core/src/Unison/Names2.hs	/^  Names e1 t1 `mappend` Names e2 t2 =$/;"	fi	instance:Ord n => Monoid (Names' n)	line:327	language:Haskell
mappend	./unison-core/src/Unison/Util/Relation.hs	/^  mappend = (<>)$/;"	fi	instance:(Ord a, Ord b) => Monoid (Relation a b)	line:474	language:Haskell
mappend	./unison-core/src/Unison/Util/Relation3.hs	/^  s1 `mappend` s2 = Relation3 d1' d2' d3' where$/;"	fi	instance:(Ord a, Ord b, Ord c) => Monoid (Relation3 a b c)	line:113	language:Haskell
mappend	./unison-core/src/Unison/Util/Relation4.hs	/^  s1 `mappend` s2 = Relation4 d1' d2' d3' d4' where$/;"	fi	instance:(Ord a, Ord b, Ord c, Ord d) => Monoid (Relation4 a b c d)	line:114	language:Haskell
mapsOf	./yaks/easytest/src/EasyTest.hs	/^mapsOf :: Ord k => [Int] -> Test k -> Test v -> Test [Map k v]$/;"	ft	signature:(Ord k => [Int] -> Test k -> Test v -> Test [Map k v])	line:297	language:Haskell
markThenRetract	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^markThenRetract :: (Var v, Ord loc) => v -> M v loc a -> M v loc (a, [Element v loc])$/;"	ft	signature:((Var v, Ord loc) => v -> M v loc a -> M v loc (a, [Element v loc]))	line:362	language:Haskell
markThenRetract0	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^markThenRetract0 :: (Var v, Ord loc) => v -> M v loc a -> M v loc ()$/;"	ft	signature:((Var v, Ord loc) => v -> M v loc a -> M v loc ())	line:389	language:Haskell
markup	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^markup :: AnnotatedExcerpt a -> Map Range a -> AnnotatedExcerpt a$/;"	ft	signature:(AnnotatedExcerpt a -> Map Range a -> AnnotatedExcerpt a)	line:106	language:Haskell
mask	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^mask :: (UV.Unbox a, B.FiniteBits bits)$/;"	ft	signature:((UV.Unbox a, B.FiniteBits bits) => bits -> SparseVector bits a -> SparseVector bits a)	line:30	language:Haskell
match	./parser-typechecker/src/Unison/TermParser.hs	/^match :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:124	language:Haskell
match	./unison-core/src/Unison/Term.hs	/^match :: Ord v => a -> Term2 vt at a v a -> [MatchCase a (Term2 vt at a v a)] -> Term2 vt at a v a$/;"	ft	signature:(Ord v => a -> Term2 vt at a v a -> [MatchCase a (Term2 vt at a v a)] -> Term2 vt at a v a)	line:530	language:Haskell
matchBody	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^matchBody = existentialMismatch0 CaseBody (Ex.inMatchBody >> Ex.inMatch)$/;"	fi	line:236	language:Haskell
matchCase	./parser-typechecker/src/Unison/TermParser.hs	/^matchCase :: Var v => P v (Term.MatchCase Ann (Term v Ann))$/;"	ft	signature:(Var v => P v (Term.MatchCase Ann (Term v Ann)))	line:137	language:Haskell
matchCaseExtraMap	./unison-core/src/Unison/Term.hs	/^matchCaseExtraMap :: (loc -> loc') -> MatchCase loc a -> MatchCase loc' a$/;"	ft	signature:((loc -> loc') -> MatchCase loc a -> MatchCase loc' a)	line:262	language:Haskell
matchGuard	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^matchGuard = booleanMismatch0 GuardMismatch Ex.inMatchGuard$/;"	fi	line:183	language:Haskell
matchInit	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^matchInit :: Eq a => [a] -> [a] -> ([a],[a])$/;"	ft	signature:(Eq a => [a] -> [a] -> ([a], [a]))	line:114	language:Haskell
matchKeyword	./parser-typechecker/src/Unison/Lexer.hs	/^matchKeyword :: String -> Maybe (String,String)$/;"	ft	signature:(String -> Maybe (String, String))	line:548	language:Haskell
matchKeyword'	./parser-typechecker/src/Unison/Lexer.hs	/^matchKeyword' :: Set String -> String -> Maybe (String,String)$/;"	ft	signature:(Set String -> String -> Maybe (String, String))	line:551	language:Haskell
matchToken	./parser-typechecker/src/Unison/Parser.hs	/^matchToken :: Ord v => L.Lexeme -> P v (L.Token L.Lexeme)$/;"	ft	signature:(Ord v => L.Lexeme -> P v (L.Token L.Lexeme))	line:265	language:Haskell
matchesNamedReference	./unison-core/src/Unison/HashQualified'.hs	/^matchesNamedReference :: Eq n => n -> Reference -> HashQualified' n -> Bool$/;"	ft	signature:(Eq n => n -> Reference -> HashQualified' n -> Bool)	line:98	language:Haskell
matchesNamedReference	./unison-core/src/Unison/HashQualified.hs	/^matchesNamedReference :: Name -> Reference -> HashQualified -> Bool$/;"	ft	signature:(Name -> Reference -> HashQualified -> Bool)	line:149	language:Haskell
matchesNamedReferent	./unison-core/src/Unison/HashQualified'.hs	/^matchesNamedReferent :: Eq n => n -> Referent -> HashQualified' n -> Bool$/;"	ft	signature:(Eq n => n -> Referent -> HashQualified' n -> Bool)	line:93	language:Haskell
matchesNamedReferent	./unison-core/src/Unison/HashQualified.hs	/^matchesNamedReferent :: Name -> Referent -> HashQualified -> Bool$/;"	ft	signature:(Name -> Referent -> HashQualified -> Bool)	line:143	language:Haskell
matchingLeftBrace	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^matchingRightBrace, matchingLeftBrace :: Char -> Maybe Char $/;"	ft	signature:(Char -> Maybe Char)	line:345	language:Haskell
matchingLeftBrace	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^matchingLeftBrace = flip lookup (map (\\(c,d) -> (d,c)) braceList)$/;"	fi	line:347	language:Haskell
matchingRightBrace	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^matchingRightBrace, matchingLeftBrace :: Char -> Maybe Char $/;"	ft	signature:(Char -> Maybe Char)	line:345	language:Haskell
maxArgs	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^maxArgs :: InputPattern -> Maybe Int$/;"	ft	signature:(InputPattern -> Maybe Int)	line:78	language:Haskell
maxCol	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  Delta { line :: !Int, col :: !Int, maxCol :: !Int }$/;"	c_a	cons:Delta.Delta	line:646	language:Haskell
maxHistorySize	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^                     maxHistorySize :: !(Maybe Int),$/;"	c_a	cons:Prefs.Prefs	line:34	language:Haskell
maxWidth	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^maxWidth :: DumbTermM Int$/;"	ft	signature:(DumbTermM Int)	line:70	language:Haskell
mayColumn2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^mayColumn2 = lines . (group <$>) . ((uncurry (<>)) <$>) . align'$/;"	fi	line:476	language:Haskell
maybeAddHistory	./yaks/haskeline/System/Console/Haskeline.hs	/^maybeAddHistory :: forall m . MonadIO m => Maybe String -> InputT m ()$/;"	ft	signature:(forall m . MonadIO m => Maybe String -> InputT m ())	line:182	language:Haskell
maybeDropLast	./yaks/haskeline/System/Console/Haskeline/History.hs	/^maybeDropLast :: Maybe Int -> Seq a -> Seq a$/;"	ft	signature:(Maybe Int -> Seq a -> Seq a)	line:89	language:Haskell
maybeReadNewline	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            maybeReadNewline :: IO ()$/;"	c_a	cons:FileOps.FileOps	line:76	language:Haskell
maybeToOptional	./parser-typechecker/src/Unison/Runtime/IR.hs	/^maybeToOptional :: Maybe (Value e cont) -> Value e cont$/;"	ft	signature:(Maybe (Value e cont) -> Value e cont)	line:116	language:Haskell
measure	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  measure b = Sum (B.length b)$/;"	fi	instance:T-Measured (Sum Int) B-ByteString	line:84	language:Haskell
member	./unison-core/src/Unison/Util/Relation.hs	/^member :: (Ord a, Ord b) => a -> b -> Relation a b -> Bool$/;"	ft	signature:((Ord a, Ord b) => a -> b -> Relation a b -> Bool)	line:248	language:Haskell
member	./unison-core/src/Unison/Util/Relation3.hs	/^member :: (Ord a, Ord b, Ord c) => a -> b -> c -> Relation3 a b c -> Bool$/;"	ft	signature:((Ord a, Ord b, Ord c) => a -> b -> c -> Relation3 a b c -> Bool)	line:37	language:Haskell
memberD1	./parser-typechecker/src/Unison/Util/Star3.hs	/^memberD1 :: (Ord fact, Ord d1) => (fact,d1) -> Star3 fact d1 d2 d3 -> Bool$/;"	ft	signature:((Ord fact, Ord d1) => (fact, d1) -> Star3 fact d1 d2 d3 -> Bool)	line:135	language:Haskell
memberD2	./parser-typechecker/src/Unison/Util/Star3.hs	/^memberD2 :: (Ord fact, Ord d2) => (fact,d2) -> Star3 fact d1 d2 d3 -> Bool$/;"	ft	signature:((Ord fact, Ord d2) => (fact, d2) -> Star3 fact d1 d2 d3 -> Bool)	line:138	language:Haskell
memberD3	./parser-typechecker/src/Unison/Util/Star3.hs	/^memberD3 :: (Ord fact, Ord d3) => (fact,d3) -> Star3 fact d1 d2 d3 -> Bool$/;"	ft	signature:((Ord fact, Ord d3) => (fact, d3) -> Star3 fact d1 d2 d3 -> Bool)	line:141	language:Haskell
memberDom	./unison-core/src/Unison/Util/Relation.hs	/^memberDom :: Ord a => a -> Relation a b -> Bool$/;"	ft	signature:(Ord a => a -> Relation a b -> Bool)	line:219	language:Haskell
memberRan	./unison-core/src/Unison/Util/Relation.hs	/^memberRan :: Ord b => b -> Relation a b -> Bool$/;"	ft	signature:(Ord b => b -> Relation a b -> Bool)	line:223	language:Haskell
members	./unison-core/src/Unison/Reference.hs	/^newtype Component = Component { members :: Set Reference }$/;"	c_a	cons:Component.Component	line:113	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  mempty = BranchDiff mempty mempty mempty mempty mempty$/;"	fi	instance:Monoid BranchDiff	line:199	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  mempty = BranchAttentions [] []$/;"	fi	instance:Monoid BranchAttentions	line:827	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  mempty = RefCollisions mempty mempty$/;"	fi	instance:Monoid RefCollisions	line:838	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/CodeLookup.hs	/^  mempty = CodeLookup (const $ pure Nothing) (const $ pure Nothing)$/;"	fi	instance:Monad m => Monoid (CodeLookup v m a)	line:50	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  mempty = MetadataDiff mempty mempty$/;"	fi	instance:Monoid (MetadataDiff tm)	line:44	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^  mempty = SlurpComponent mempty mempty$/;"	fi	instance:Ord v => Monoid (SlurpComponent v)	line:38	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  mempty = Patch mempty mempty$/;"	fi	instance:Monoid Patch	line:121	language:Haskell
mempty	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  mempty = PatchDiff mempty mempty mempty mempty$/;"	fi	instance:Monoid PatchDiff	line:137	language:Haskell
mempty	./parser-typechecker/src/Unison/Lexer.hs	/^  mempty = Pos 0 0$/;"	fi	instance:Monoid Pos	line:128	language:Haskell
mempty	./parser-typechecker/src/Unison/Parser.hs	/^  mempty = UniqueName (\\_ _ -> Nothing)$/;"	fi	instance:Monoid UniqueName	line:59	language:Haskell
mempty	./parser-typechecker/src/Unison/Parser.hs	/^  mempty = External$/;"	fi	instance:Monoid Ann	line:120	language:Haskell
mempty	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  mempty = PrettyPrintEnv (const Nothing) (const Nothing)$/;"	fi	instance:Monoid PrettyPrintEnv	line:116	language:Haskell
mempty	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  mempty = CompilationEnv mempty mempty$/;"	fi	instance:Monoid (CompilationEnv e cont)	line:988	language:Haskell
mempty	./parser-typechecker/src/Unison/TermPrinter.hs	/^  mempty = PrintAnnotation { usages = Map.empty }$/;"	fi	instance:Monoid PrintAnnotation	line:766	language:Haskell
mempty	./parser-typechecker/src/Unison/Typechecker.hs	/^  mempty = Notes mempty mempty mempty$/;"	fi	instance:Monoid (Notes v loc)	line:54	language:Haskell
mempty	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  mempty = mzero$/;"	fi	instance:Monoid (SubseqExtractor' n a)	line:344	language:Haskell
mempty	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^  mempty = TypeLookup mempty mempty mempty$/;"	fi	instance:Monoid (TypeLookup v a)	line:59	language:Haskell
mempty	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  mempty = AnnotatedText Seq.empty$/;"	fi	instance:Monoid (AnnotatedText a)	line:35	language:Haskell
mempty	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  mempty = Bytes mempty$/;"	fi	instance:Monoid Bytes	line:78	language:Haskell
mempty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  mempty = Pretty mempty Empty$/;"	fi	instance:Monoid (Pretty s)	line:637	language:Haskell
mempty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  mempty = Delta 0 0 0$/;"	fi	instance:Monoid Delta	line:651	language:Haskell
mempty	./parser-typechecker/src/Unison/Util/Star3.hs	/^  mempty = Star3 mempty mempty mempty mempty$/;"	fi	instance:(Ord fact, Ord d1, Ord d2, Ord d3) => Monoid (Star3 fact d1 d2 d3)	line:191	language:Haskell
mempty	./unison-core/src/Unison/ABT.hs	/^  mempty = Path (const Nothing)$/;"	fi	instance:Monoid (Path s t a b m)	line:65	language:Haskell
mempty	./unison-core/src/Unison/Names2.hs	/^  mempty = Names mempty mempty$/;"	fi	instance:Ord n => Monoid (Names' n)	line:326	language:Haskell
mempty	./unison-core/src/Unison/Util/Relation.hs	/^  mempty = empty$/;"	fi	instance:(Ord a, Ord b) => Monoid (Relation a b)	line:473	language:Haskell
mempty	./unison-core/src/Unison/Util/Relation3.hs	/^  mempty = Relation3 mempty mempty mempty$/;"	fi	instance:(Ord a, Ord b, Ord c) => Monoid (Relation3 a b c)	line:112	language:Haskell
mempty	./unison-core/src/Unison/Util/Relation4.hs	/^  mempty = Relation4 mempty mempty mempty mempty$/;"	fi	instance:(Ord a, Ord b, Ord c, Ord d) => Monoid (Relation4 a b c d)	line:113	language:Haskell
menu1	./parser-typechecker/src/Unison/Util/Menu.hs	/^menu1 :: forall a mc$/;"	ft	signature:(forall a mc . Console -> Caption -> (a -> Stylized) -> (mc -> Stylized) -> [(Keyword, a)] -> [(Keyword, mc)] -> Maybe Keyword -> IO (Maybe (Either mc a)))	line:85	language:Haskell
menu1	./parser-typechecker/src/Unison/Util/Menu.hs	/^menu1 console caption render renderMeta groups metas initial = do$/;"	fi	line:94	language:Haskell
menuCompletion	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^menuCompletion :: Monad m => Key -> [InsertMode] -> Command m InsertMode InsertMode$/;"	ft	signature:(Monad m => Key -> [InsertMode] -> Command m InsertMode InsertMode)	line:57	language:Haskell
menuN	./parser-typechecker/src/Unison/Util/Menu.hs	/^menuN :: Console$/;"	ft	signature:(Console -> Caption -> (a -> Stylized) -> (mc -> Stylized) -> [([Keyword], [a])] -> [([Keyword], mc)] -> [Keyword] -> IO (Either mc [[a]]))	line:203	language:Haskell
menuN	./parser-typechecker/src/Unison/Util/Menu.hs	/^menuN _console _caption _render _renderMeta _groups _metas _initials = pure (Right [])$/;"	fi	line:211	language:Haskell
merge	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^merge :: forall m . Monad m => Branch m -> Branch m -> m (Branch m)$/;"	ft	signature:(forall m . Monad m => Branch m -> Branch m -> m (Branch m))	line:344	language:Haskell
merge	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^merge :: Metadata -> Metadata -> Metadata$/;"	ft	signature:(Metadata -> Metadata -> Metadata)	line:49	language:Haskell
merge	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^merge :: (B.FiniteBits bits, UV.Unbox a)$/;"	ft	signature:((B.FiniteBits bits, UV.Unbox a) => SparseVector bits a -> SparseVector bits a -> SparseVector bits a)	line:98	language:Haskell
merge	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^merge :: Causal M h [Int64]$/;"	ft	signature:(Causal M h [Int64] -> Causal M h [Int64] -> M (Causal M h [Int64]))	line:253	language:Haskell
merge''	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^merge'' :: (Monad m, Semigroup e)$/;"	ft	signature:((Monad m, Semigroup e) => (Causal m h e -> m (Causal m h e)) -> Causal m h e -> Causal m h e -> m (Causal m h e))	line:268	language:Haskell
merge0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^merge0 :: forall m. Monad m => Branch0 m -> Branch0 m -> m (Branch0 m)$/;"	ft	signature:(forall m. Monad m => Branch0 m -> Branch0 m -> m (Branch0 m))	line:397	language:Haskell
mergeBranchAndPropagateDefaultPatch	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^mergeBranchAndPropagateDefaultPatch :: (Monad m, Var v) =>$/;"	ft	signature:((Monad m, Var v) => InputDescription -> Maybe (Output v) -> Branch m -> Maybe Path.Path' -> Path.Absolute -> Action' m v ())	line:1914	language:Haskell
mergeBuiltins	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^mergeBuiltins :: InputPattern$/;"	ft	signature:(InputPattern)	line:74	language:Haskell
mergeInternal	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^mergeInternal f a b =$/;"	fi	line:239	language:Haskell
mergeLocal	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^mergeLocal :: InputPattern$/;"	ft	signature:(InputPattern)	line:750	language:Haskell
mergeWithM	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^mergeWithM f = mergeInternal merge0$/;"	fi	line:254	language:Haskell
messageBeep	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^messageBeep :: IO ()$/;"	ft	signature:(IO ())	line:230	language:Haskell
messageText	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^newtype Message = Message {messageText :: String}$/;"	c_a	cons:Message.Message	line:378	language:Haskell
messages	./yaks/easytest/src/EasyTest.hs	/^      , messages :: String$/;"	c_a	cons:Env.Env	line:38	language:Haskell
metaChar	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^simpleChar, metaChar, ctrlChar :: Char -> Key$/;"	ft	signature:(Char -> Key)	line:53	language:Haskell
metaChar	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^metaChar = metaKey . simpleChar$/;"	fi	line:55	language:Haskell
metaKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^metaKey :: Key -> Key$/;"	ft	signature:(Key -> Key)	line:47	language:Haskell
metaPretty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^metaPretty :: Show s => Pretty s -> Pretty String$/;"	ft	signature:(Show s => Pretty s -> Pretty String)	line:782	language:Haskell
metadata	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  metadata :: Relation3 r Name Metadata.Value$/;"	c_a	cons:NamespaceSlice.NamespaceSlice	line:28	language:Haskell
metadata.isPropagated	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^metadata.isPropagated = IsPropagated.IsPropagated$/;"	fi	line:195	language:Haskell
metadata.isTest	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^metadata.isTest = IsTest.IsTest$/;"	fi	line:194	language:Haskell
mfix	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^    mfix f = InputT (mfix (unInputT . f))$/;"	fi	instance:(MonadFix m) => MonadFix (InputT m)	line:59	language:Haskell
minArgs	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^minArgs :: InputPattern -> Int$/;"	ft	signature:(InputPattern -> Int)	line:70	language:Haskell
minTTY	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^minTTY :: Handle -> IO Bool$/;"	ft	signature:(Handle -> IO Bool)	line:131	language:Haskell
minimalCodebaseStructure	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^minimalCodebaseStructure :: CodebasePath -> [FilePath]$/;"	ft	signature:(CodebasePath -> [FilePath])	line:293	language:Haskell
minimize	./parser-typechecker/src/Unison/Typechecker/Components.hs	/^minimize (Term.LetRecNamedAnnotatedTop' isTop ann bs e) =$/;"	fi	line:43	language:Haskell
minimize'	./parser-typechecker/src/Unison/Typechecker/Components.hs	/^minimize' term = fromMaybe term <$> minimize term$/;"	fi	line:88	language:Haskell
minimizeCyclesOrCrash	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^minimizeCyclesOrCrash :: Var v => Term v a -> Term v a$/;"	ft	signature:(Var v => Term v a -> Term v a)	line:95	language:Haskell
mismatchSite	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^             , mismatchSite :: C.Term v loc$/;"	c_a	cons:TypeError.Mismatch	line:30	language:Haskell
mismatchSite	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                    , mismatchSite       :: C.Term v loc$/;"	c_a	cons:TypeError.BooleanMismatch	line:34	language:Haskell
mismatchSite	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , mismatchSite           :: C.Term v loc$/;"	c_a	cons:TypeError.ExistentialMismatch	line:42	language:Haskell
missingResult	./unison-core/src/Unison/Var.hs	/^missingResult = typed MissingResult$/;"	fi	line:69	language:Haskell
mkAnn	./parser-typechecker/src/Unison/Parser.hs	/^mkAnn :: (Annotated a, Annotated b) => a -> b -> Ann$/;"	ft	signature:((Annotated a, Annotated b) => a -> b -> Ann)	line:206	language:Haskell
mkDataDecl	./unison-core/src/Unison/DataDeclaration.hs	/^mkDataDecl :: Modifier -> [v] -> [(v, Type v ())] -> DataDeclaration' v ()$/;"	ft	signature:(Modifier -> [v] -> [(v, Type v ())] -> DataDeclaration' v ())	line:266	language:Haskell
mkDataDecl'	./unison-core/src/Unison/DataDeclaration.hs	/^mkDataDecl' = DataDeclaration$/;"	fi	line:264	language:Haskell
mkEffectDecl	./unison-core/src/Unison/DataDeclaration.hs	/^mkEffectDecl :: Modifier -> [v] -> [(v, Type v ())] -> EffectDeclaration' v ()$/;"	ft	signature:(Modifier -> [v] -> [(v, Type v ())] -> EffectDeclaration' v ())	line:259	language:Haskell
mkEffectDecl'	./unison-core/src/Unison/DataDeclaration.hs	/^mkEffectDecl' m a b cs = EffectDeclaration (DataDeclaration m a b cs)$/;"	fi	line:257	language:Haskell
mkErrorType	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^mkErrorType :: Text -> DD.ConstructorId$/;"	ft	signature:(Text -> DD.ConstructorId)	line:106	language:Haskell
mkSettor	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^mkSettor :: Read a => (a -> Prefs -> Prefs) -> String -> Prefs -> Prefs$/;"	ft	signature:(Read a => (a -> Prefs -> Prefs) -> String -> Prefs -> Prefs)	line:82	language:Haskell
modEnv	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^modEnv :: (Env v loc -> Env v loc) -> M v loc ()$/;"	ft	signature:((Env v loc -> Env v loc) -> M v loc ())	line:200	language:Haskell
modEnv'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^modEnv' :: (Env v loc -> (a, Env v loc)) -> M v loc a$/;"	ft	signature:((Env v loc -> (a, Env v loc)) -> M v loc a)	line:203	language:Haskell
modifier	./parser-typechecker/src/Unison/FileParser.hs	/^modifier :: Var v => P v (L.Token DD.Modifier)$/;"	ft	signature:(Var v => P v (L.Token DD.Modifier))	line:176	language:Haskell
modifier	./unison-core/src/Unison/DataDeclaration.hs	/^  modifier :: Modifier,$/;"	c_a	cons:DataDeclaration'.DataDeclaration	line:75	language:Haskell
modify	./unison-core/src/Unison/Paths.hs	/^modify :: Var v => (Target v -> Target (V v)) -> Path -> Target v -> Maybe (Target v)$/;"	ft	signature:(Var v => (Target v -> Target (V v)) -> Path -> Target v -> Maybe (Target v))	line:135	language:Haskell
modify	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^modify :: MonadState s m => (s -> s) -> m ()$/;"	ft	signature:(MonadState s m => (s -> s) -> m ())	line:58	language:Haskell
modify'	./unison-core/src/Unison/ABT.hs	/^modify' :: Path s t a b m -> (m -> a -> b) -> s -> Maybe t$/;"	ft	signature:(Path s t a b m -> (m -> a -> b) -> s -> Maybe t)	line:81	language:Haskell
modifyAt	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^modifyAt :: Applicative m$/;"	ft	signature:(Applicative m => Path -> (Branch m -> Branch m) -> Branch m -> Branch m)	line:700	language:Haskell
modifyAtM	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^modifyAtM path f b = case Path.uncons path of$/;"	fi	line:714	language:Haskell
modifyBaseChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^modifyBaseChar :: (Char -> Char) -> Grapheme -> Grapheme$/;"	ft	signature:((Char -> Char) -> Grapheme -> Grapheme)	line:86	language:Haskell
modifyContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^modifyContext :: (Context v loc -> M v loc (Context v loc)) -> M v loc ()$/;"	ft	signature:((Context v loc -> M v loc (Context v loc)) -> M v loc ())	line:455	language:Haskell
modifyHistory	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^modifyHistory :: MonadIO m => (History -> History) -> InputT m ()$/;"	ft	signature:(MonadIO m => (History -> History) -> InputT m ())	line:70	language:Haskell
modifyPatches	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^modifyPatches seg f = mapMOf edits update$/;"	fi	line:674	language:Haskell
modifyTerm	./unison-core/src/Unison/Paths.hs	/^modifyTerm :: Var v => (Term v -> Term (V v)) -> Path -> Term v -> Maybe (Term v)$/;"	ft	signature:(Var v => (Term v -> Term (V v)) -> Path -> Term v -> Maybe (Term v))	line:138	language:Haskell
modifyTerm'	./unison-core/src/Unison/Paths.hs	/^modifyTerm' :: Var v => (Term v -> Term (V v)) -> Path -> Term v -> Term v$/;"	ft	signature:(Var v => (Term v -> Term (V v)) -> Path -> Term v -> Term v)	line:144	language:Haskell
modifyType	./unison-core/src/Unison/Paths.hs	/^modifyType :: Var v => (Type v -> Type (V v)) -> Path -> Type v -> Maybe (Type v)$/;"	ft	signature:(Var v => (Type v -> Type (V v)) -> Path -> Type v -> Maybe (Type v))	line:147	language:Haskell
modifyWord	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^modifyWord :: ([Grapheme] -> [Grapheme]) -> InsertMode -> InsertMode$/;"	ft	signature:(([Grapheme] -> [Grapheme]) -> InsertMode -> InsertMode)	line:94	language:Haskell
monotype	./unison-core/src/Unison/Type.hs	/^monotype :: ABT.Var v => Type v a -> Maybe (Monotype v a)$/;"	ft	signature:(ABT.Var v => Type v a -> Maybe (Monotype v a))	line:90	language:Haskell
move	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^move :: Applicative m$/;"	ft	signature:(Applicative m => Path -> Path -> Branch m -> Either ForkFailure (Branch m))	line:535	language:Haskell
movePatch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^movePatch :: String -> String -> Either (P.Pretty CT.ColorText) Input$/;"	ft	signature:(String -> String -> Either (P.Pretty CT.ColorText) Input)	line:526	language:Haskell
movePosLeft	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^movePosRight, movePosLeft :: [Grapheme] -> DrawM ()$/;"	ft	signature:([Grapheme] -> DrawM ())	line:311	language:Haskell
movePosLeft	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^movePosLeft str = do$/;"	fi	line:329	language:Haskell
movePosRight	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^movePosRight, movePosLeft :: [Grapheme] -> DrawM ()$/;"	ft	signature:([Grapheme] -> DrawM ())	line:311	language:Haskell
moveRelative	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^moveRelative :: Int -> ActionM ()$/;"	ft	signature:(Int -> ActionM ())	line:238	language:Haskell
moveToEnd	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goLeft, goRight, moveToStart, moveToEnd :: s -> s$/;"	ft	signature:(s -> s)	class:Move	line:184	language:Haskell
moveToEnd	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    moveToEnd (IMode xs ys) = IMode (reverse ys ++ xs) []$/;"	fi	instance:Move InsertMode	line:210	language:Haskell
moveToEnd	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    moveToEnd (CMode xs c ys) = let zs = reverse ys ++ (c:xs) in CMode (tail zs) (head zs) []$/;"	fi	instance:Move CommandMode	line:292	language:Haskell
moveToNextLine	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    moveToNextLine _ = printText crlf$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	line:43	language:Haskell
moveToNextLine	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    moveToNextLine _ = runActionT moveToNextLineT$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:361	language:Haskell
moveToNextLine	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    moveToNextLine s = do$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:363	language:Haskell
moveToNextLine	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    moveToNextLine :: LineChars -> m ()$/;"	ft	signature:(LineChars -> m ())	class:Term	line:22	language:Haskell
moveToNextLineT	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^moveToNextLineT :: ActionM ()$/;"	ft	signature:(ActionM ())	line:336	language:Haskell
moveToPos	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^moveToPos :: TermPos -> ActionM ()$/;"	ft	signature:(TermPos -> ActionM ())	line:232	language:Haskell
moveToStart	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    goLeft, goRight, moveToStart, moveToEnd :: s -> s$/;"	ft	signature:(s -> s)	class:Move	line:184	language:Haskell
moveToStart	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    moveToStart (IMode xs ys) = IMode [] (reverse xs ++ ys)$/;"	fi	instance:Move InsertMode	line:209	language:Haskell
moveToStart	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    moveToStart (CMode xs c ys) = let zs = reverse xs ++ (c:ys) in CMode [] (head zs) (tail zs)$/;"	fi	instance:Move CommandMode	line:289	language:Haskell
movements	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^movements :: [(Key,InsertMode -> InsertMode)]$/;"	ft	signature:([(Key, InsertMode -> InsertMode)])	line:259	language:Haskell
mplus	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  mplus (SubseqExtractor' f1) (SubseqExtractor' f2) =$/;"	fi	instance:MonadPlus (SubseqExtractor' n)	line:340	language:Haskell
mplus	./yaks/easytest/src/EasyTest.hs	/^  mplus = (<|>)$/;"	fi	instance:MonadPlus Test	line:420	language:Haskell
mreplicate	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^mreplicate :: Monoid m => Int -> m -> m$/;"	ft	signature:(Monoid m => Int -> m -> m)	line:214	language:Haskell
mu	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^mu :: Vec a -> Nat -> Maybe a$/;"	ft	signature:(Vec a -> Nat -> Maybe a)	line:26	language:Haskell
multimap	./unison-core/src/Unison/Util/List.hs	/^multimap :: Foldable f => Ord k => f (k, v) -> Map k [v]$/;"	ft	signature:(Foldable f => Ord k => f (k, v) -> Map k [v])	line:9	language:Haskell
mySettings	./yaks/haskeline/examples/Test.hs	/^mySettings :: Settings IO$/;"	ft	signature:(Settings IO)	line:18	language:Haskell
mzero	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  mzero = SubseqExtractor' $ \\_ -> []$/;"	fi	instance:MonadPlus (SubseqExtractor' n)	line:339	language:Haskell
mzero	./yaks/easytest/src/EasyTest.hs	/^  mzero = empty$/;"	fi	instance:MonadPlus Test	line:419	language:Haskell
n	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^pattern Tm n t r as = Tm' (TermResult' n t r as)$/;"	fi	line:31	language:Haskell
n	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^pattern Tp n t r as = Tp' (TypeResult' n t r as)$/;"	fi	line:32	language:Haskell
n	./unison-core/src/Unison/Pattern.hs	/^pattern Int n = IntP () n$/;"	fi	line:101	language:Haskell
n	./unison-core/src/Unison/Pattern.hs	/^pattern Nat n = NatP () n$/;"	fi	line:102	language:Haskell
n	./unison-core/src/Unison/Pattern.hs	/^pattern Float n = FloatP () n$/;"	fi	line:103	language:Haskell
name	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^name :: SearchResult -> HashQualified$/;"	ft	signature:(SearchResult -> HashQualified)	line:50	language:Haskell
name	./unison-core/src/Unison/Var.hs	/^name :: Var v => v -> Text$/;"	ft	signature:(Var v => v -> Text)	line:40	language:Haskell
nameConflicts	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^  , nameConflicts :: Names0$/;"	c_a	cons:TodoOutput.TodoOutput	line:31	language:Haskell
nameFrom	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^nameFrom :: Var v => v -> Type v loc -> v$/;"	ft	signature:(Var v => v -> Type v loc -> v)	line:1487	language:Haskell
nameLength	./unison-core/src/Unison/HashQualified'.hs	/^nameLength :: HashQualified' Name -> Int$/;"	ft	signature:(HashQualified' Name -> Int)	line:44	language:Haskell
nameStr	./unison-core/src/Unison/Var.hs	/^nameStr :: Var v => v -> String$/;"	ft	signature:(Var v => v -> String)	line:130	language:Haskell
nameb	./unison-core/src/Unison/Blank.hs	/^nameb :: Blank loc -> Maybe String$/;"	ft	signature:(Blank loc -> Maybe String)	line:9	language:Haskell
named	./unison-core/src/Unison/Var.hs	/^named :: Var v => Text -> v$/;"	ft	signature:(Var v => Text -> v)	line:33	language:Haskell
nameds	./unison-core/src/Unison/Var.hs	/^nameds :: Var v => String -> v$/;"	ft	signature:(Var v => String -> v)	line:133	language:Haskell
names	./parser-typechecker/src/Unison/Builtin.hs	/^names :: Names$/;"	ft	signature:(Names)	line:55	language:Haskell
names	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  names :: Relation r Name,$/;"	c_a	cons:NamespaceSlice.NamespaceSlice	line:27	language:Haskell
names	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^names :: InputPattern$/;"	ft	signature:(InputPattern)	line:1097	language:Haskell
names	./parser-typechecker/src/Unison/Parser.hs	/^             , names :: Names$/;"	c_a	cons:ParsingEnv.ParsingEnv	line:52	language:Haskell
names	./parser-typechecker/src/Unison/UnisonFile.hs	/^  , names   :: Names0$/;"	c_a	cons:Env.Env	line:259	language:Haskell
names0	./parser-typechecker/src/Unison/Builtin.hs	/^names0 :: Names0$/;"	ft	signature:(Names0)	line:58	language:Haskell
names0	./unison-core/src/Unison/Names3.hs	/^names0 :: Relation Name Referent -> Relation Name Reference -> Names0$/;"	ft	signature:(Relation Name Referent -> Relation Name Reference -> Names0)	line:108	language:Haskell
names0ToNames	./unison-core/src/Unison/Names2.hs	/^names0ToNames :: Names0 -> Names$/;"	ft	signature:(Names0 -> Names)	line:77	language:Haskell
namesDiff	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^namesDiff :: Branch m -> Branch m -> Names.Diff$/;"	ft	signature:(Branch m -> Branch m -> Names.Diff)	line:792	language:Haskell
namesForReference	./unison-core/src/Unison/Names2.hs	/^namesForReference :: Names' n -> Reference -> Set n$/;"	ft	signature:(Names' n -> Reference -> Set n)	line:195	language:Haskell
namesForReferent	./unison-core/src/Unison/Names2.hs	/^namesForReferent :: Names' n -> Referent -> Set n$/;"	ft	signature:(Names' n -> Referent -> Set n)	line:192	language:Haskell
namespace	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^namespace io where$/;"	fi	line:216	language:Haskell
namespaceBlock	./parser-typechecker/src/Unison/TermParser.hs	/^namespaceBlock :: Var v => P v (BlockElement v)$/;"	ft	signature:(Var v => P v (BlockElement v))	line:755	language:Haskell
namespaceHashPath	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^namespaceHashPath :: P (Maybe ShortBranchHash, Path)$/;"	ft	signature:(P (Maybe ShortBranchHash, Path))	line:143	language:Haskell
namespaceUpdates	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^namespaceUpdates :: Ord r => DiffSlice r -> Map Name (Set r, Set r)$/;"	ft	signature:(Ord r => DiffSlice r -> Map Name (Set r, Set r))	line:153	language:Haskell
namespaced	./unison-core/src/Unison/Var.hs	/^namespaced :: Var v => [v] -> v$/;"	ft	signature:(Var v => [v] -> v)	line:127	language:Haskell
nat	./unison-core/src/Unison/Term.hs	/^nat :: Ord v => a -> Word64 -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Word64 -> Term2 vt at ap v a)	line:491	language:Haskell
nat	./unison-core/src/Unison/Type.hs	/^nat :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:231	language:Haskell
natRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
natRef	./unison-core/src/Unison/Type.hs	/^natRef = Reference.Builtin "Nat"$/;"	fi	line:214	language:Haskell
nest	./parser-typechecker/src/Unison/Util/Pretty.hs	/^nest :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s)	line:604	language:Haskell
nestD12	./unison-core/src/Unison/Util/Relation3.hs	/^nestD12 :: (Ord a, Ord b, Ord c) => Relation3 a b c -> Relation (a,b) c$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation3 a b c -> Relation (a, b) c)	line:60	language:Haskell
new	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^new :: Int -> IO (CycleTable k v)$/;"	ft	signature:(Int -> IO (CycleTable k v))	line:18	language:Haskell
newIO	./parser-typechecker/src/Unison/Util/TQueue.hs	/^newIO :: MonadIO m => m (TQueue a)$/;"	ft	signature:(MonadIO m => m (TQueue a))	line:14	language:Haskell
newNameArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^newNameArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1305	language:Haskell
newRefNames	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^                  , newRefNames :: Set Name }$/;"	c_a	cons:Aliases.UpdateAliases	line:38	language:Haskell
newTermConflicts	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  newTermConflicts      :: [UpdateTermDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:51	language:Haskell
newTerms	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  , newTerms :: Map Reference (Term v Ann, Type v Ann)$/;"	c_a	cons:Edits.Edits	line:57	language:Haskell
newTypeConflicts	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  newTypeConflicts      :: [UpdateTypeDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:50	language:Haskell
newTypes	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  , newTypes :: Map Reference (Decl v Ann)$/;"	c_a	cons:Edits.Edits	line:60	language:Haskell
newUnisonHandle	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^newUnisonHandle :: Handle -> UIO RT.Value$/;"	ft	signature:(Handle -> UIO RT.Value)	line:135	language:Haskell
newUnisonSocket	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^newUnisonSocket :: Net.Socket -> UIO RT.Value$/;"	ft	signature:(Net.Socket -> UIO RT.Value)	line:142	language:Haskell
newline	./parser-typechecker/src/Unison/Util/Pretty.hs	/^newline :: IsString s => Pretty s$/;"	ft	signature:(IsString s => Pretty s)	line:283	language:Haskell
nl	./yaks/haskeline/tests/Unit.hs	/^nl :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:276	language:Haskell
noArg	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^noArg :: Monad m => Command m s (ArgMode s)$/;"	ft	signature:(Monad m => Command m s (ArgMode s))	line:394	language:Haskell
noCache	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^noCache :: Reference -> IO (Maybe (Term v))$/;"	ft	signature:(Reference -> IO (Maybe (Term v)))	line:39	language:Haskell
noCompletion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^noCompletion :: Monad m => CompletionFunc m$/;"	ft	signature:(Monad m => CompletionFunc m)	line:46	language:Haskell
noCompletions	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^noCompletions :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1310	language:Haskell
noConflicts	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^noConflicts :: TodoOutput v a -> Bool$/;"	ft	signature:(TodoOutput v a -> Bool)	line:57	language:Haskell
noEdits	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^noEdits :: Edits v$/;"	ft	signature:(Edits v)	line:65	language:Haskell
noEdits	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^noEdits :: TodoOutput v a -> Bool$/;"	ft	signature:(TodoOutput v a -> Bool)	line:61	language:Haskell
noImportRefs	./parser-typechecker/src/Unison/TermPrinter.hs	/^noImportRefs :: Reference -> Bool$/;"	ft	signature:(Reference -> Bool)	line:845	language:Haskell
noLcaPair	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^noLcaPair = do$/;"	fi	line:143	language:Haskell
noLcaPairTest	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^noLcaPairTest :: Test ()$/;"	ft	signature:(Test ())	line:150	language:Haskell
noModifier	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^noModifier :: Modifier$/;"	ft	signature:(Modifier)	line:33	language:Haskell
noResults	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^noResults :: Pretty$/;"	ft	signature:(Pretty)	line:1649	language:Haskell
noSuchThingId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^noSuchThingId = mkErrorType "io.ErrorType.NoSuchThing"$/;"	fi	line:112	language:Haskell
noSuggestions	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^noSuggestions _ _ _ _ = pure []$/;"	fi	line:94	language:Haskell
noYieldsError	./parser-typechecker/tests/Unison/Test/Typechecker/TypeError.hs	/^noYieldsError :: Var v => String -> ErrorExtractor v Ann a -> Bool$/;"	ft	signature:(Var v => String -> ErrorExtractor v Ann a -> Bool)	line:50	language:Haskell
nonEmpty	./parser-typechecker/src/Unison/UnisonFile.hs	/^nonEmpty :: TypecheckedUnisonFile v a -> Bool$/;"	ft	signature:(TypecheckedUnisonFile v a -> Bool)	line:208	language:Haskell
nonEmpty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^nonEmpty :: (Foldable f, IsString s) => f (Pretty s) -> [Pretty s]$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> [Pretty s])	line:369	language:Haskell
nonEmpty	./unison-core/src/Unison/Util/Monoid.hs	/^isEmpty, nonEmpty :: (Eq a, Monoid a) => a -> Bool$/;"	ft	signature:((Eq a, Monoid a) => a -> Bool)	line:22	language:Haskell
nonEmpty	./unison-core/src/Unison/Util/Monoid.hs	/^nonEmpty = not . isEmpty$/;"	fi	line:24	language:Haskell
nonNewlineSpaces	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^nonNewlineSpaces :: P ()$/;"	ft	signature:(P ())	line:374	language:Haskell
noneId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
noneId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^noneId = constructorNamed optionReference "Optional.None"$/;"	fi	line:96	language:Haskell
normalizeErrs	./yaks/haskeline/tests/RunTTY.hs	/^normalizeErrs = BC.pack . loop . BC.unpack$/;"	fi	line:127	language:Haskell
notLayout	./parser-typechecker/src/Unison/Lexer.hs	/^notLayout :: Token Lexeme -> Bool$/;"	ft	signature:(Token Lexeme -> Bool)	line:77	language:Haskell
notMember	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^notMember :: (Var v, Ord loc) => v -> Set (TypeVar v loc) -> Bool$/;"	ft	signature:((Var v, Ord loc) => v -> Set (TypeVar v loc) -> Bool)	line:694	language:Haskell
notMember	./unison-core/src/Unison/Util/Relation.hs	/^notMember :: (Ord a, Ord b) => a -> b -> Relation a b -> Bool$/;"	ft	signature:((Ord a, Ord b) => a -> b -> Relation a b -> Bool)	line:256	language:Haskell
note	./parser-typechecker/src/Unison/CommandLine.hs	/^note :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s)	line:85	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^             , note         :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.Mismatch	line:31	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                    , note               :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.BooleanMismatch	line:36	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , note                   :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.ExistentialMismatch	line:43	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , note         :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.FunctionApplication	line:53	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                           , note :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.NotFunctionApplication	line:57	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , note                    :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.AbilityCheckFailure	line:62	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                         , note :: C.ErrorNote v loc }$/;"	c_a	cons:TypeError.UnguardedLetRecCycle	line:66	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                , note         :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.UnknownType	line:69	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                , note         :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.UnknownTerm	line:75	language:Haskell
note	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                         , note  :: C.ErrorNote v loc$/;"	c_a	cons:TypeError.DuplicateDefinitions	line:78	language:Haskell
note	./yaks/easytest/src/EasyTest.hs	/^note :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:184	language:Haskell
note'	./yaks/easytest/src/EasyTest.hs	/^note' :: Show s => s -> Test ()$/;"	ft	signature:(Show s => s -> Test ())	line:191	language:Haskell
noteScoped	./yaks/easytest/src/EasyTest.hs	/^noteScoped :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:331	language:Haskell
noteTopLevelType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^noteTopLevelType e binding typ = case binding of$/;"	fi	line:807	language:Haskell
note_	./yaks/easytest/src/EasyTest.hs	/^      , note_ :: String -> IO ()$/;"	c_a	cons:Env.Env	line:40	language:Haskell
notes	./parser-typechecker/src/Unison/Result.hs	/^pattern Result notes may = MaybeT (WriterT (Identity (may, notes)))$/;"	fi	line:50	language:Haskell
nothingTodo	./parser-typechecker/src/Unison/CommandLine.hs	/^nothingTodo :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s)	line:103	language:Haskell
notifyNumbered	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^notifyNumbered :: Var v => NumberedOutput v -> (Pretty, NumberedArgs)$/;"	ft	signature:(Var v => NumberedOutput v -> (Pretty, NumberedArgs))	line:127	language:Haskell
notifyUser	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^notifyUser :: forall v . Var v => FilePath -> Output v -> IO Pretty$/;"	ft	signature:(forall v . Var v => FilePath -> Output v -> IO Pretty)	line:242	language:Haskell
nubOrdOn	./unison-core/src/Unison/Util/List.hs	/^uniqueBy, nubOrdOn :: (Foldable f, Ord b) => (a -> b) -> f a -> [a]$/;"	ft	signature:((Foldable f, Ord b) => (a -> b) -> f a -> [a])	line:22	language:Haskell
nubOrdOn	./unison-core/src/Unison/Util/List.hs	/^nubOrdOn = uniqueBy$/;"	fi	line:30	language:Haskell
null	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  null (AnnotatedText at) = all (null . fst) at$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:75	language:Haskell
null	./parser-typechecker/src/Unison/Util/Bytes.hs	/^null :: Bytes -> Bool$/;"	ft	signature:(Bytes -> Bool)	line:21	language:Haskell
null	./unison-core/src/Unison/Util/Relation.hs	/^null :: Relation a b -> Bool$/;"	ft	signature:(Relation a b -> Bool)	line:241	language:Haskell
nullaryMain	./parser-typechecker/src/Unison/Codebase/MainTerm.hs	/^nullaryMain :: Ord v => a -> Type.Type v a$/;"	ft	signature:(Ord v => a -> Type.Type v a)	line:61	language:Haskell
num	./parser-typechecker/src/Unison/Util/Pretty.hs	/^num :: (Show n, Num n, IsString s) => n -> Pretty s$/;"	ft	signature:((Show n, Num n, IsString s) => n -> Pretty s)	line:568	language:Haskell
numHashChars	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^numHashChars :: Branch m -> Int$/;"	ft	signature:(Branch m -> Int)	line:444	language:Haskell
numHashChars	./unison-core/src/Unison/Names2.hs	/^numHashChars :: Names' n -> Int$/;"	ft	signature:(Names' n -> Int)	line:175	language:Haskell
number	./parser-typechecker/src/Unison/TermParser.hs	/^number :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:857	language:Haskell
number'	./parser-typechecker/src/Unison/TermParser.hs	/^number' i u f = fmap go numeric$/;"	fi	line:866	language:Haskell
numbered	./parser-typechecker/src/Unison/Util/Pretty.hs	/^numbered num ps = column2 (fmap num [1 ..] `zip` toList ps)$/;"	fi	line:414	language:Haskell
numberedColumn2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^numberedColumn2 num ps = numbered num (align $ toList ps)$/;"	fi	line:426	language:Haskell
numberedList	./parser-typechecker/src/Unison/Util/Pretty.hs	/^numberedList :: Foldable f => f (Pretty ColorText) -> Pretty ColorText$/;"	ft	signature:(Foldable f => f (Pretty ColorText) -> Pretty ColorText)	line:429	language:Haskell
numeric	./parser-typechecker/src/Unison/Parser.hs	/^numeric :: Ord v => P v (L.Token String)$/;"	ft	signature:(Ord v => P v (L.Token String))	line:379	language:Haskell
numericLit	./parser-typechecker/src/Unison/Lexer.hs	/^numericLit :: String -> Either Err (Maybe (String,String))$/;"	ft	signature:(String -> Either Err (Maybe (String, String)))	line:597	language:Haskell
occurrences	./unison-core/src/Unison/ABT.hs	/^occurrences :: (Foldable f, Var v) => v -> Term f v a -> Int$/;"	ft	signature:((Foldable f, Var v) => v -> Term f v a -> Int)	line:356	language:Haskell
occurrences	./unison-core/src/Unison/ABT.hs	/^occurrences v t = case out t of$/;"	fi	line:358	language:Haskell
ok	./yaks/easytest/src/EasyTest.hs	/^ok :: Test ()$/;"	ft	signature:(Test ())	line:337	language:Haskell
okCallout	./parser-typechecker/src/Unison/Util/Pretty.hs	/^okCallout = callout "â"$/;"	fi	line:773	language:Haskell
okConstructorId	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorId, failConstructorId, docBlobId, docLinkId, docSignatureId, docSourceId, docEvaluateId, docJoinId, linkTermId, linkTypeId :: ConstructorId$/;"	ft	signature:(ConstructorId)	line:430	language:Haskell
okConstructorReferent	./unison-core/src/Unison/DataDeclaration.hs	/^okConstructorReferent, failConstructorReferent :: Referent.Referent$/;"	ft	signature:(Referent.Referent)	line:442	language:Haskell
oldNames	./unison-core/src/Unison/Names3.hs	/^data Names = Names { currentNames :: Names0, oldNames :: Names0 } deriving Show$/;"	c_a	cons:Names.Names	line:28	language:Haskell
oldRefNames	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  | UpdateAliases { oldRefNames :: Set Name$/;"	c_a	cons:Aliases.UpdateAliases	line:37	language:Haskell
onError	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^onError :: MonadError e m => MonadIO m => IO () -> m () -> m ()$/;"	ft	signature:(MonadError e m => MonadIO m => IO () -> m () -> m ())	line:106	language:Haskell
one	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^one :: Branch0 m -> Branch m$/;"	ft	signature:(Branch0 m -> Branch m)	line:588	language:Haskell
one	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^one :: Hashable e => e -> Causal m h e$/;"	ft	signature:(Hashable e => e -> Causal m h e)	line:313	language:Haskell
oneCausal	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^oneCausal :: Causal Identity Hash (Set Int64)$/;"	ft	signature:(Causal Identity Hash (Set Int64))	line:189	language:Haskell
oneRemoved	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^oneRemoved :: Causal Identity Hash (Set Int64)$/;"	ft	signature:(Causal Identity Hash (Set Int64))	line:157	language:Haskell
openBlock	./parser-typechecker/src/Unison/Parser.hs	/^openBlock :: Ord v => P v (L.Token String)$/;"	ft	signature:(Ord v => P v (L.Token String))	line:255	language:Haskell
openBlockWith	./parser-typechecker/src/Unison/Parser.hs	/^openBlockWith :: Ord v => String -> P v (L.Token ())$/;"	ft	signature:(Ord v => String -> P v (L.Token ()))	line:261	language:Haskell
openInCodingMode	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^openInCodingMode :: FilePath -> IOMode -> IO ExternalHandle$/;"	ft	signature:(FilePath -> IOMode -> IO ExternalHandle)	line:61	language:Haskell
openTerm	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^openTerm :: IOMode -> MaybeT IO ExternalHandle$/;"	ft	signature:(IOMode -> MaybeT IO ExternalHandle)	line:273	language:Haskell
openingKeyword	./parser-typechecker/src/Unison/Lexer.hs	/^openingKeyword :: BlockName -> String$/;"	ft	signature:(BlockName -> String)	line:733	language:Haskell
optimize	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^optimize :: forall a v . (Semigroup a, Var v) => Term v a -> Term v a$/;"	ft	signature:(forall a v . (Semigroup a, Var v) => Term v a -> Term v a)	line:54	language:Haskell
optionReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^optionReference = typeNamed "Optional"$/;"	fi	line:74	language:Haskell
optionalRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef :: Reference$/;"	ft	signature:(Reference)	line:409	language:Haskell
optionalType	./unison-core/src/Unison/DataDeclaration.hs	/^optionalType a = Type.ref a optionalRef$/;"	fi	line:558	language:Haskell
optionalWordyNameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^optionalWordyNameSegment :: String -> Either String NameSegment$/;"	ft	signature:(String -> Either String NameSegment)	line:144	language:Haskell
or	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^or = booleanMismatch0 OrMismatch (Ex.inSynthesizeApp >> Ex.inOrApp)$/;"	fi	line:181	language:Haskell
or	./unison-core/src/Unison/Term.hs	/^or :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:539	language:Haskell
orElse	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^orElse :: M v loc a -> M v loc a -> M v loc a$/;"	ft	signature:(M v loc a -> M v loc a -> M v loc a)	line:603	language:Haskell
orElse	./parser-typechecker/src/Unison/Util/Pretty.hs	/^orElse :: Pretty s -> Pretty s -> Pretty s$/;"	ft	signature:(Pretty s -> Pretty s -> Pretty s)	line:148	language:Haskell
orElse	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^orElse :: Monad m => MaybeT m a -> m a -> m a$/;"	ft	signature:(Monad m => MaybeT m a -> m a -> m a)	line:134	language:Haskell
orElses	./parser-typechecker/src/Unison/Util/Pretty.hs	/^orElses :: [Pretty s] -> Pretty s$/;"	ft	signature:([Pretty s] -> Pretty s)	line:151	language:Haskell
ordered	./parser-typechecker/src/Unison/Typechecker/Components.hs	/^ordered :: Var v => [(v,Term' vt v a)] -> [[(v,Term' vt v a)]]$/;"	ft	signature:(Var v => [(v, Term' vt v a)] -> [[ (v, Term' vt v a) ]])	line:22	language:Haskell
ordered	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^ordered :: (Var v, Ord loc) => Context v loc -> v -> v -> Bool$/;"	ft	signature:((Var v, Ord loc) => Context v loc -> v -> v -> Bool)	line:419	language:Haskell
orderedComponents	./unison-core/src/Unison/ABT.hs	/^orderedComponents :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]$/;"	ft	signature:(Var v => [(v, Term f v a)] -> [[ (v, Term f v a) ]])	line:585	language:Haskell
orderedComponents'	./unison-core/src/Unison/ABT.hs	/^orderedComponents' :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]$/;"	ft	signature:(Var v => [(v, Term f v a)] -> [[ (v, Term f v a) ]])	line:563	language:Haskell
originalFile	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^    originalFile :: UF.TypecheckedUnisonFile v Ann$/;"	c_a	cons:SlurpResult.SlurpResult	line:43	language:Haskell
originalNames	./unison-core/src/Unison/Names3.hs	/^  Diff { originalNames :: Names0$/;"	c_a	cons:Diff.Diff	line:72	language:Haskell
out	./parser-typechecker/src/Unison/Util/Pretty.hs	/^data Pretty s = Pretty { delta :: Delta, out :: F s (Pretty s) } deriving Eq$/;"	c_a	cons:Pretty.Pretty	line:125	language:Haskell
out	./unison-core/src/Unison/ABT.hs	/^data Term f v a = Term { freeVars :: Set v, annotation :: a, out :: ABT f v (Term f v a) }$/;"	c_a	cons:Term.Term	line:38	language:Haskell
outerJoinDomMultimaps	./unison-core/src/Unison/Util/Relation.hs	/^outerJoinDomMultimaps :: (Ord a, Ord b, Ord c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Map a (Set b, Set c))	line:99	language:Haskell
outerJoinRanMultimaps	./unison-core/src/Unison/Util/Relation.hs	/^outerJoinRanMultimaps :: (Ord a, Ord b, Ord c)$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Map c (Set a, Set b))	line:107	language:Haskell
output	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^output :: TermAction -> ActionM ()$/;"	ft	signature:(TermAction -> ActionM ())	line:198	language:Haskell
output	./yaks/haskeline/tests/Unit.hs	/^output :: Int -> B.ByteString -> B.ByteString$/;"	ft	signature:(Int -> B.ByteString -> B.ByteString)	line:279	language:Haskell
outputStr	./yaks/haskeline/System/Console/Haskeline.hs	/^outputStr :: MonadIO m => String -> InputT m ()$/;"	ft	signature:(MonadIO m => String -> InputT m ())	line:118	language:Haskell
outputStrLn	./yaks/haskeline/System/Console/Haskeline.hs	/^outputStrLn :: MonadIO m => String -> InputT m ()$/;"	ft	signature:(MonadIO m => String -> InputT m ())	line:124	language:Haskell
outputText	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^outputText :: String -> ActionM ()$/;"	ft	signature:(String -> ActionM ())	line:203	language:Haskell
overChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^overChar, beforeChar, afterChar :: (Char -> Bool) -> InsertMode -> Bool$/;"	ft	signature:((Char -> Bool) -> InsertMode -> Bool)	line:415	language:Haskell
overlaps	./parser-typechecker/src/Unison/Util/Range.hs	/^overlaps :: Range -> Range -> Bool$/;"	ft	signature:(Range -> Range -> Bool)	line:9	language:Haskell
oxfordCommas	./parser-typechecker/src/Unison/Util/Pretty.hs	/^oxfordCommas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:307	language:Haskell
oxfordCommasWith	./parser-typechecker/src/Unison/Util/Pretty.hs	/^oxfordCommasWith end xs = case toList xs of$/;"	fi	line:314	language:Haskell
p	./unison-core/src/Unison/Pattern.hs	/^pattern As p = AsP () p$/;"	fi	line:107	language:Haskell
p	./unison-core/src/Unison/Pattern.hs	/^pattern EffectPure p = EffectPureP () p$/;"	fi	line:108	language:Haskell
padWords	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^padWords :: Int -> [String] -> String$/;"	ft	signature:(Int -> [String] -> String)	line:134	language:Haskell
pageCompletions	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^pageCompletions :: MonadReader Layout m => [String] -> CmdM m ()$/;"	ft	signature:(MonadReader Layout m => [String] -> CmdM m ())	line:96	language:Haskell
pagingCompletion	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^pagingCompletion :: MonadReader Layout m => Key -> Prefs$/;"	ft	signature:(MonadReader Layout m => Key -> Prefs -> [Completion] -> Command m InsertMode InsertMode)	line:70	language:Haskell
pair	./parser-typechecker/src/Unison/Runtime/IR.hs	/^pair :: (Value e cont, Value e cont) -> Value e cont$/;"	ft	signature:((Value e cont, Value e cont) -> Value e cont)	line:124	language:Haskell
pair	./yaks/easytest/src/EasyTest.hs	/^pair :: Test a -> Test b -> Test (a,b)$/;"	ft	signature:(Test a -> Test b -> Test (a, b))	line:289	language:Haskell
pairCtorRef	./unison-core/src/Unison/DataDeclaration.hs	/^pairCtorRef, unitCtorRef :: Referent$/;"	ft	signature:(Referent)	line:421	language:Haskell
pairRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef :: Reference$/;"	ft	signature:(Reference)	line:409	language:Haskell
pairType	./unison-core/src/Unison/DataDeclaration.hs	/^pairType a = Type.ref a pairRef$/;"	fi	line:556	language:Haskell
paragraphyText	./parser-typechecker/src/Unison/Util/Pretty.hs	/^paragraphyText :: (LL.ListLike s Char, IsString s) => Text -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Text -> Pretty s)	line:181	language:Haskell
paren	./parser-typechecker/src/Unison/TermPrinter.hs	/^paren :: Bool -> Pretty SyntaxText -> Pretty SyntaxText$/;"	ft	signature:(Bool -> Pretty SyntaxText -> Pretty SyntaxText)	line:596	language:Haskell
parenIfInfix	./parser-typechecker/src/Unison/TermPrinter.hs	/^parenIfInfix name ic =$/;"	fi	line:602	language:Haskell
parent	./parser-typechecker/src/Unison/Path.hs	/^  parent :: p -> p$/;"	ft	signature:(p -> p)	class:Path	line:25	language:Haskell
parent	./parser-typechecker/src/Unison/Path.hs	/^  parent _ = Nothing$/;"	fi	instance:Eq a => Path (Maybe a)	line:38	language:Haskell
parent	./parser-typechecker/src/Unison/Path.hs	/^  parent p | null p = []$/;"	fi	instance:Eq a => Path [a]	line:45	language:Haskell
parent	./parser-typechecker/src/Unison/Path.hs	/^  parent _ = ()$/;"	fi	instance:Path ()	line:52	language:Haskell
parent	./unison-core/src/Unison/Name.hs	/^parent :: Name -> Maybe Name$/;"	ft	signature:(Name -> Maybe Name)	line:111	language:Haskell
parent	./unison-core/src/Unison/Paths.hs	/^parent :: Path -> Maybe Path$/;"	ft	signature:(Path -> Maybe Path)	line:184	language:Haskell
parent'	./unison-core/src/Unison/Paths.hs	/^parent' :: Path -> Path$/;"	ft	signature:(Path -> Path)	line:188	language:Haskell
parenthesize	./parser-typechecker/src/Unison/Parser.hs	/^parenthesize :: Ord v => P v a -> P v a$/;"	ft	signature:(Ord v => P v a -> P v a)	line:335	language:Haskell
parenthesize	./parser-typechecker/src/Unison/Util/Pretty.hs	/^parenthesize :: IsString s => Pretty s -> Pretty s$/;"	ft	signature:(IsString s => Pretty s -> Pretty s)	line:375	language:Haskell
parenthesizeCommas	./parser-typechecker/src/Unison/Util/Pretty.hs	/^parenthesizeCommas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:326	language:Haskell
parenthesizeIf	./parser-typechecker/src/Unison/Util/Pretty.hs	/^parenthesizeIf :: IsString s => Bool -> Pretty s -> Pretty s$/;"	ft	signature:(IsString s => Bool -> Pretty s -> Pretty s)	line:378	language:Haskell
parse	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^parse :: String -> Text -> Either Err [Stanza]$/;"	ft	signature:(String -> Text -> Either Err [Stanza])	line:101	language:Haskell
parse	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  , parse       :: [String] -> Either (P.Pretty CT.ColorText) Input$/;"	c_a	cons:InputPattern.InputPattern	line:33	language:Haskell
parse	./parser-typechecker/src/Unison/Parsers.hs	/^parse p = Parser.run (Parser.root p)$/;"	fi	line:34	language:Haskell
parseAndSynthesizeAsFile	./parser-typechecker/tests/Unison/Test/Common.hs	/^parseAndSynthesizeAsFile ambient filename s = FP.parseAndSynthesizeFile$/;"	fi	line:67	language:Haskell
parseAndSynthesizeFile	./parser-typechecker/src/Unison/FileParsers.hs	/^parseAndSynthesizeFile ambient typeLookupf env filePath src = do$/;"	fi	line:69	language:Haskell
parseAugmented	./parser-typechecker/tests/Unison/Test/UriParser.hs	/^parseAugmented :: (Text, (RemoteRepo, Maybe ShortBranchHash, Path)) -> Test ()$/;"	ft	signature:((Text, (RemoteRepo, Maybe ShortBranchHash, Path)) -> Test ())	line:74	language:Haskell
parseBaseKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^parseBaseKey :: String -> Maybe BaseKey$/;"	ft	signature:(String -> Maybe BaseKey)	line:107	language:Haskell
parseBranchId	./parser-typechecker/src/Unison/Codebase/Editor/Input.hs	/^parseBranchId :: String -> Either String BranchId$/;"	ft	signature:(String -> Either String BranchId)	line:34	language:Haskell
parseEscapeChar	./parser-typechecker/src/Unison/Lexer.hs	/^parseEscapeChar :: Char -> Maybe Char$/;"	ft	signature:(Char -> Maybe Char)	line:588	language:Haskell
parseFile	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^parseFile :: FilePath -> IO (Either Err [Stanza])$/;"	ft	signature:(FilePath -> IO (Either Err [Stanza]))	line:92	language:Haskell
parseFile	./parser-typechecker/src/Unison/Parsers.hs	/^parseFile filename s = Parser.run' (Parser.rootFile FileParser.file) s filename$/;"	fi	line:56	language:Haskell
parseHQSplit	./parser-typechecker/src/Unison/Codebase/Path.hs	/^parseHQSplit :: String -> Either String HQSplit$/;"	ft	signature:(String -> Either String HQSplit)	line:188	language:Haskell
parseHQSplit'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^parseHQSplit' :: String -> Either String HQSplit'$/;"	ft	signature:(String -> Either String HQSplit')	line:195	language:Haskell
parseInput	./parser-typechecker/src/Unison/CommandLine.hs	/^parseInput patterns ss = case ss of$/;"	fi	line:167	language:Haskell
parseKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^parseKey :: String -> Maybe Key$/;"	ft	signature:(String -> Maybe Key)	line:100	language:Haskell
parseModifier	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^parseModifier :: String -> (Modifier -> Modifier)$/;"	ft	signature:(String -> (Modifier -> Modifier))	line:86	language:Haskell
parseModifiers	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^parseModifiers :: [String] -> BaseKey -> Key$/;"	ft	signature:([String] -> BaseKey -> Key)	line:82	language:Haskell
parsePath'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^parsePath' :: String -> Either String Path'$/;"	ft	signature:(String -> Either String Path')	line:103	language:Haskell
parsePath'Impl	./parser-typechecker/src/Unison/Codebase/Path.hs	/^parsePath'Impl :: String -> Either String (Path', String)$/;"	ft	signature:(String -> Either String (Path', String))	line:119	language:Haskell
parsePattern	./parser-typechecker/src/Unison/TermParser.hs	/^parsePattern :: forall v. Var v => P v (Pattern Ann, [(Ann, v)])$/;"	ft	signature:(forall v. Var v => P v (Pattern Ann, [(Ann, v)]))	line:146	language:Haskell
parseProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^parseProtocol :: P GitProtocol$/;"	ft	signature:(P GitProtocol)	line:95	language:Haskell
parseSearchType	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^parseSearchType :: (Monad m, Var v)$/;"	ft	signature:((Monad m, Var v) => Input -> String -> Action' m v (Either (Output v) (Type v Ann)))	line:2372	language:Haskell
parseShortHashOrHQSplit'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^parseShortHashOrHQSplit' :: String -> Either String (Either SH.ShortHash HQSplit')$/;"	ft	signature:(String -> Either String (Either SH.ShortHash HQSplit'))	line:167	language:Haskell
parseSplit'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^parseSplit' :: (String -> Either String NameSegment)$/;"	ft	signature:((String -> Either String NameSegment) -> String -> Either String Split')	line:159	language:Haskell
parseTerm	./parser-typechecker/src/Unison/Parsers.hs	/^parseTerm = parse TermParser.term$/;"	fi	line:41	language:Haskell
parseType	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^parseType :: (Monad m, Var v)$/;"	ft	signature:((Monad m, Var v) => Input -> String -> Action' m v (Either (Output v) (Type v Ann)))	line:2376	language:Haskell
parseType	./parser-typechecker/src/Unison/Parsers.hs	/^parseType = Parser.run (Parser.root TypeParser.valueType)$/;"	fi	line:48	language:Haskell
parseUri	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^parseUri :: IsString b => String -> String -> Either b RemoteNamespace$/;"	ft	signature:(IsString b => String -> String -> Either b RemoteNamespace)	line:745	language:Haskell
parseWith	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^parseWith :: P Symbol a -> String -> Test ()$/;"	ft	signature:(P Symbol a -> String -> Test ())	line:222	language:Haskell
parses	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  parses :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:130	language:Haskell
parses	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^parses :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:219	language:Haskell
parsingEnv	./parser-typechecker/tests/Unison/Test/Common.hs	/^parsingEnv :: Parser.ParsingEnv$/;"	ft	signature:(Parser.ParsingEnv)	line:74	language:Haskell
passwordChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^                          passwordChar :: Maybe Char}$/;"	c_a	cons:Password.Password	line:387	language:Haskell
passwordState	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^data Password = Password {passwordState :: [Char], -- ^ reversed$/;"	c_a	cons:Password.Password	line:386	language:Haskell
pasteCommand	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^pasteCommand :: (Save s, MonadState KillRing m, MonadState Undo m)$/;"	ft	signature:((Save s, MonadState KillRing m, MonadState Undo m) => ([Grapheme] -> s -> s) -> Command m (ArgMode s) s)	line:38	language:Haskell
pasteGraphemesAfter	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^pasteGraphemesBefore, pasteGraphemesAfter :: [Grapheme] -> CommandMode -> CommandMode$/;"	ft	signature:([Grapheme] -> CommandMode -> CommandMode)	line:306	language:Haskell
pasteGraphemesAfter	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^pasteGraphemesAfter [] = id$/;"	fi	line:310	language:Haskell
pasteGraphemesBefore	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^pasteGraphemesBefore, pasteGraphemesAfter :: [Grapheme] -> CommandMode -> CommandMode$/;"	ft	signature:([Grapheme] -> CommandMode -> CommandMode)	line:306	language:Haskell
patch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^patch :: InputPattern$/;"	ft	signature:(InputPattern)	line:235	language:Haskell
patchArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^patchArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1264	language:Haskell
patchDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^patchDiff :: forall m. Monad m => Branch0 m -> Branch0 m -> m (Map Name (DiffType PatchDiff))$/;"	ft	signature:(forall m. Monad m => Branch0 m -> Branch0 m -> m (Map Name (DiffType PatchDiff)))	line:56	language:Haskell
patchesDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  , patchesDiff :: Map Name (DiffType PatchDiff)$/;"	c_a	cons:BranchDiff.BranchDiff	line:44	language:Haskell
path	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  path :: Seq (PathElement v loc)$/;"	c_a	cons:ErrorNote.ErrorNote	line:265	language:Haskell
path	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^path :: ErrorExtractor v loc [C.PathElement v loc]$/;"	ft	signature:(ErrorExtractor v loc [C.PathElement v loc])	line:294	language:Haskell
path	./parser-typechecker/tests/Unison/Test/UriParser.hs	/^path :: [Text] -> Path$/;"	ft	signature:([Text] -> Path)	line:80	language:Haskell
pathArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^pathArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:1301	language:Haskell
pathCompletor	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^pathCompletor filterQuery getNames query _code b p = let$/;"	fi	line:1290	language:Haskell
pathExtend	./unison-core/src/Unison/Paths.hs	/^pathExtend :: PathElement -> Path -> Path$/;"	ft	signature:(PathElement -> Path -> Path)	line:181	language:Haskell
pathPrefixes	./unison-core/src/Unison/Paths.hs	/^pathPrefixes :: Path -> [Path]$/;"	ft	signature:(Path -> [Path])	line:177	language:Haskell
pathStart	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^pathStart :: SubseqExtractor' n ()$/;"	ft	signature:(SubseqExtractor' n ())	line:148	language:Haskell
patternMap	./unison-core/src/Unison/Term.hs	/^patternMap :: (Pattern ap -> Pattern ap2) -> Term2 vt at ap v a -> Term2 vt at ap2 v a$/;"	ft	signature:((Pattern ap -> Pattern ap2) -> Term2 vt at ap v a -> Term2 vt at ap2 v a)	line:188	language:Haskell
patternName	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  { patternName :: String$/;"	c_a	cons:InputPattern.InputPattern	line:29	language:Haskell
patternName	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^patternName :: InputPattern -> P.Pretty P.ColorText$/;"	ft	signature:(InputPattern -> P.Pretty P.ColorText)	line:53	language:Haskell
patternName	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^patternName :: PrettyPrintEnv -> Reference -> Int -> HashQualified$/;"	ft	signature:(PrettyPrintEnv -> Reference -> Int -> HashQualified)	line:109	language:Haskell
patternShortHash	./unison-core/src/Unison/Referent.hs	/^patternShortHash :: Reference -> Int -> ShortHash$/;"	ft	signature:(Reference -> Int -> ShortHash)	line:45	language:Haskell
patterns	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^patterns :: PrettyPrintEnv -> Reference -> Int -> Maybe HashQualified$/;"	ft	signature:(PrettyPrintEnv -> Reference -> Int -> Maybe HashQualified)	line:29	language:Haskell
payload	./parser-typechecker/src/Unison/Lexer.hs	/^  payload :: a,$/;"	c_a	cons:Token.Token	line:72	language:Haskell
peek	./parser-typechecker/src/Unison/Util/TQueue.hs	/^peek :: TQueue a -> STM a$/;"	ft	signature:(TQueue a -> STM a)	line:28	language:Haskell
peek	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    peek p = do$/;"	fi	instance:Storable Coord	line:172	language:Haskell
peek	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^peek :: Stack a -> Maybe a$/;"	ft	signature:(Stack a -> Maybe a)	line:17	language:Haskell
peekAny	./parser-typechecker/src/Unison/Parser.hs	/^peekAny :: Ord v => P v (L.Token L.Lexeme)$/;"	ft	signature:(Ord v => P v (L.Token L.Lexeme))	line:212	language:Haskell
peekEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^peekEvent :: Ptr () -> IO InputEvent$/;"	ft	signature:(Ptr () -> IO InputEvent)	line:131	language:Haskell
peekWhile	./parser-typechecker/src/Unison/Util/TQueue.hs	/^peekWhile :: (a -> Bool) -> TQueue a -> STM [a]$/;"	ft	signature:((a -> Bool) -> TQueue a -> STM [a])	line:85	language:Haskell
pending	./yaks/easytest/src/EasyTest.hs	/^pending :: Test a -> Test a$/;"	ft	signature:(Test a -> Test a)	line:356	language:Haskell
permissionDeniedId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^permissionDeniedId = mkErrorType "io.ErrorType.PermissionDenied"$/;"	fi	line:117	language:Haskell
ph	./unison-core/src/Unison/Pattern.hs	/^pattern SequenceOp ph op pt = SequenceOpP () ph op pt$/;"	fi	line:111	language:Haskell
pick	./yaks/easytest/src/EasyTest.hs	/^pick :: [a] -> Test a$/;"	ft	signature:([a] -> Test a)	line:262	language:Haskell
picker	./yaks/easytest/src/EasyTest.hs	/^picker :: Int -> [a] -> (Int -> Maybe a)$/;"	ft	signature:(Int -> [a] -> (Int -> Maybe a))	line:268	language:Haskell
placeholder	./unison-core/src/Unison/Term.hs	/^placeholder :: Ord v => a -> String -> Term2 vt a ap v a$/;"	ft	signature:(Ord v => a -> String -> Term2 vt a ap v a)	line:511	language:Haskell
plural	./parser-typechecker/src/Unison/CommandLine.hs	/^plural :: Foldable f => f a -> b -> b -> b$/;"	ft	signature:(Foldable f => f a -> b -> b -> b)	line:185	language:Haskell
plural	./parser-typechecker/src/Unison/Util/Pretty.hs	/^plural :: Foldable f$/;"	ft	signature:(Foldable f => f a -> Pretty ColorText -> Pretty ColorText)	line:687	language:Haskell
plural'	./parser-typechecker/src/Unison/CommandLine.hs	/^plural' :: Integral a => a -> b -> b -> b$/;"	ft	signature:(Integral a => a -> b -> b -> b)	line:190	language:Haskell
poke	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    poke p c = do$/;"	fi	instance:Storable Coord	line:176	language:Haskell
pop	./parser-typechecker/src/Unison/Lexer.hs	/^pop :: [a] -> [a]$/;"	ft	signature:([a] -> [a])	line:166	language:Haskell
pos	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^data Window = Window {pos :: Int -- ^ # of visible chars to left of cursor$/;"	c_a	cons:Window.Window	line:17	language:Haskell
positionAt1	./parser-typechecker/src/Unison/Parser.hs	/^  positionAt1 _ sp t = setPos sp (L.start t)$/;"	fi	instance:P-Stream Input	line:151	language:Haskell
positionAtN	./parser-typechecker/src/Unison/Parser.hs	/^  positionAtN pxy sp =$/;"	fi	instance:P-Stream Input	line:153	language:Haskell
positionalVar	./parser-typechecker/src/Unison/Parser.hs	/^positionalVar :: (Annotated a, Var v) => a -> v -> v$/;"	ft	signature:((Annotated a, Var v) => a -> v -> v)	line:439	language:Haskell
posixFileRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^posixFileRunTerm :: Handles -> IO RunTerm$/;"	ft	signature:(Handles -> IO RunTerm)	line:316	language:Haskell
posixLayouts	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^posixLayouts :: Handles -> [IO (Maybe Layout)]$/;"	ft	signature:(Handles -> [IO (Maybe Layout)])	line:64	language:Haskell
posixRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^posixRunTerm ::$/;"	ft	signature:(Handles -> [IO (Maybe Layout)] -> [(String, Key)] -> (forall m b . MonadException m => m b -> m b) -> (forall m . (MonadException m, CommandMonad m) => EvalTerm (PosixT m)) -> IO RunTerm)	line:278	language:Haskell
ppEnv	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^ppEnv :: PPE.PrettyPrintEnv$/;"	ft	signature:(PPE.PrettyPrintEnv)	line:58	language:Haskell
precedence	./parser-typechecker/src/Unison/TermPrinter.hs	/^    precedence :: Int$/;"	c_a	cons:AmbientContext.AmbientContext	line:64	language:Haskell
preferTerm	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^preferTerm :: Behavior$/;"	ft	signature:(Behavior)	line:188	language:Haskell
preferredHeight	./parser-typechecker/src/Unison/Util/Pretty.hs	/^preferredHeight :: Pretty s -> Width$/;"	ft	signature:(Pretty s -> Width)	line:663	language:Haskell
preferredWidth	./parser-typechecker/src/Unison/Util/Pretty.hs	/^preferredWidth :: Pretty s -> Width$/;"	ft	signature:(Pretty s -> Width)	line:660	language:Haskell
prefix	./parser-typechecker/src/Unison/Codebase/Path.hs	/^prefix :: Absolute -> Path' -> Path$/;"	ft	signature:(Absolute -> Path' -> Path)	line:94	language:Haskell
prefix	./parser-typechecker/src/Unison/Util/Logger.hs	/^         , prefix :: String -> String$/;"	c_a	cons:Logger.Logger	line:29	language:Haskell
prefix	./unison-core/src/Unison/ShortHash.hs	/^  | ShortHash { prefix :: Text, cycle :: Maybe Text, cid :: Maybe Text }$/;"	c_a	cons:ShortHash.ShortHash	line:14	language:Haskell
prefix0	./unison-core/src/Unison/Names2.hs	/^prefix0 :: Name -> Names0 -> Names0$/;"	ft	signature:(Name -> Names0 -> Names0)	line:283	language:Haskell
prefixDefinitionName	./parser-typechecker/src/Unison/Parser.hs	/^prefixDefinitionName :: Var v => P v (L.Token v)$/;"	ft	signature:(Var v => P v (L.Token v))	line:290	language:Haskell
prefixFindInBranch	./parser-typechecker/src/Unison/Util/Find.hs	/^prefixFindInBranch ::$/;"	ft	signature:(Names0 -> HashQualified -> [(SearchResult, P.Pretty P.ColorText)])	line:116	language:Haskell
prefixIncomplete	./parser-typechecker/src/Unison/CommandLine.hs	/^prefixIncomplete :: String -> [String] -> [Line.Completion]$/;"	ft	signature:(String -> [String] -> [Line.Completion])	line:144	language:Haskell
prefixName	./parser-typechecker/src/Unison/Codebase/Path.hs	/^prefixName :: Absolute -> Name -> Name$/;"	ft	signature:(Absolute -> Name -> Name)	line:249	language:Haskell
prefixed	./parser-typechecker/src/Unison/Util/Pretty.hs	/^prefixed :: (Foldable f, LL.ListLike s Char, IsString s)$/;"	ft	signature:((Foldable f, LL.ListLike s Char, IsString s) => Pretty s -> Pretty s -> f (Pretty s) -> Pretty s)	line:392	language:Haskell
prepSearch	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^prepSearch :: SearchMode -> HistLog -> ([Grapheme],[([Grapheme],HistLog)])$/;"	ft	signature:(SearchMode -> HistLog -> ([Grapheme], [([Grapheme], HistLog)]))	line:126	language:Haskell
prepareTDNR	./unison-core/src/Unison/Term.hs	/^prepareTDNR :: Var v => ABT.Term (F vt b ap) v b -> ABT.Term (F vt b ap) v b$/;"	ft	signature:(Var v => ABT.Term (F vt b ap) v b -> ABT.Term (F vt b ap) v b)	line:179	language:Haskell
prepareTranscriptDir	./parser-typechecker/unison/Main.hs	/^prepareTranscriptDir :: Bool -> Maybe FilePath -> IO FilePath$/;"	ft	signature:(Bool -> Maybe FilePath -> IO FilePath)	line:152	language:Haskell
presentCompletions	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^presentCompletions :: (MonadReader Prefs m, MonadReader Layout m)$/;"	ft	signature:((MonadReader Prefs m, MonadReader Layout m) => Key -> InsertMode -> InsertMode -> [Completion] -> CmdM m InsertMode)	line:44	language:Haskell
pretty	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^pretty isPast ppe sr =$/;"	fi	line:169	language:Haskell
pretty	./parser-typechecker/src/Unison/TermPrinter.hs	/^pretty :: Var v => PrettyPrintEnv -> Term v a -> Pretty ColorText$/;"	ft	signature:(Var v => PrettyPrintEnv -> Term v a -> Pretty ColorText)	line:50	language:Haskell
pretty	./parser-typechecker/src/Unison/TypePrinter.hs	/^pretty :: forall v a . (Var v) => PrettyPrintEnv -> Type v a -> Pretty ColorText$/;"	ft	signature:(forall v a . (Var v) => PrettyPrintEnv -> Type v a -> Pretty ColorText)	line:26	language:Haskell
pretty'	./parser-typechecker/src/Unison/TermPrinter.hs	/^pretty' :: Var v => Maybe Int -> PrettyPrintEnv -> Term v a -> ColorText$/;"	ft	signature:(Var v => Maybe Int -> PrettyPrintEnv -> Term v a -> ColorText)	line:53	language:Haskell
pretty'	./parser-typechecker/src/Unison/TypePrinter.hs	/^pretty' :: Var v => Maybe Int -> PrettyPrintEnv -> Type v a -> String$/;"	ft	signature:(Var v => Maybe Int -> PrettyPrintEnv -> Type v a -> String)	line:29	language:Haskell
pretty0	./parser-typechecker/src/Unison/TermPrinter.hs	/^pretty0$/;"	fi	line:152	language:Haskell
pretty0	./parser-typechecker/src/Unison/TypePrinter.hs	/^pretty0 n im p tp = prettyRaw n im p (cleanup (removePureEffects tp))$/;"	fi	line:62	language:Haskell
prettyBinding	./parser-typechecker/src/Unison/TermPrinter.hs	/^prettyBinding n = prettyBinding0 n $ ac (-1) Block Map.empty MaybeDoc$/;"	fi	line:488	language:Haskell
prettyBinding'	./parser-typechecker/src/Unison/TermPrinter.hs	/^prettyBinding' ::$/;"	ft	signature:(Var v => Int -> PrettyPrintEnv -> HQ.HashQualified -> Term v a -> ColorText)	line:490	language:Haskell
prettyBinding0	./parser-typechecker/src/Unison/TermPrinter.hs	/^prettyBinding0 env a@AmbientContext { imports = im, docContext = doc } v term = go$/;"	fi	line:501	language:Haskell
prettyCompletion	./parser-typechecker/src/Unison/CommandLine.hs	/^prettyCompletion :: (String, P.Pretty P.ColorText) -> Line.Completion$/;"	ft	signature:((String, P.Pretty P.ColorText) -> Line.Completion)	line:112	language:Haskell
prettyCompletion'	./parser-typechecker/src/Unison/CommandLine.hs	/^prettyCompletion' :: (String, P.Pretty P.ColorText) -> Line.Completion$/;"	ft	signature:((String, P.Pretty P.ColorText) -> Line.Completion)	line:119	language:Haskell
prettyCompletion''	./parser-typechecker/src/Unison/CommandLine.hs	/^prettyCompletion'' :: Bool -> (String, P.Pretty P.ColorText) -> Line.Completion$/;"	ft	signature:(Bool -> (String, P.Pretty P.ColorText) -> Line.Completion)	line:122	language:Haskell
prettyDataDecl	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyDataDecl env r name dd =$/;"	fi	line:87	language:Haskell
prettyDataHeader	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyDataHeader :: Var v => HashQualified -> DD.DataDeclaration' v a -> Pretty SyntaxText$/;"	ft	signature:(Var v => HashQualified -> DD.DataDeclaration' v a -> Pretty SyntaxText)	line:156	language:Haskell
prettyDecl	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyDecl ppe r hq d = case d of $/;"	fi	line:43	language:Haskell
prettyDeclHeader	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyDeclHeader name (Left e) = prettyEffectHeader name e$/;"	fi	line:176	language:Haskell
prettyDeclOrBuiltinHeader	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyDeclOrBuiltinHeader name (DD.Builtin ctype) = case ctype of$/;"	fi	line:184	language:Haskell
prettyDeclPair	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyDeclPair :: Var v =>$/;"	ft	signature:(Var v => PPE.PrettyPrintEnv -> (Reference, DisplayThing (DD.Decl v a)) -> Pretty)	line:1149	language:Haskell
prettyDeclTriple	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyDeclTriple :: Var v =>$/;"	ft	signature:(Var v => (HQ.HashQualified, Reference.Reference, DisplayThing (DD.Decl v a)) -> Pretty)	line:1139	language:Haskell
prettyDiff	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyDiff :: Names.Diff -> Pretty$/;"	ft	signature:(Names.Diff -> Pretty)	line:1749	language:Haskell
prettyDoc	./parser-typechecker/src/Unison/TermPrinter.hs	/^prettyDoc :: Var v => PrettyPrintEnv -> Imports -> Term3 v a -> Pretty SyntaxText$/;"	ft	signature:(Var v => PrettyPrintEnv -> Imports -> Term3 v a -> Pretty SyntaxText)	line:564	language:Haskell
prettyEffectDecl	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyEffectDecl ppe r name = prettyGADT ppe r name . toDataDecl$/;"	fi	line:54	language:Haskell
prettyEffectHeader	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyEffectHeader :: Var v => HashQualified -> DD.EffectDeclaration' v a -> Pretty SyntaxText$/;"	ft	signature:(Var v => HashQualified -> DD.EffectDeclaration' v a -> Pretty SyntaxText)	line:164	language:Haskell
prettyGADT	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyGADT env r name dd = P.hang header . P.lines $ constructor <$> zip$/;"	fi	line:63	language:Haskell
prettyHashQualified	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyHashQualified :: HQ.HashQualified -> Pretty SyntaxText$/;"	ft	signature:(HQ.HashQualified -> Pretty SyntaxText)	line:21	language:Haskell
prettyHashQualified'	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyHashQualified' :: HQ'.HashQualified -> Pretty SyntaxText$/;"	ft	signature:(HQ'.HashQualified -> Pretty SyntaxText)	line:24	language:Haskell
prettyHashQualified0	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyHashQualified0 :: IsString s => HQ.HashQualified -> Pretty s$/;"	ft	signature:(IsString s => HQ.HashQualified -> Pretty s)	line:27	language:Haskell
prettyIR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^prettyIR :: PPE.PrettyPrintEnv$/;"	ft	signature:(PPE.PrettyPrintEnv -> (e -> P.Pretty String) -> (cont -> P.Pretty String) -> IR e cont -> P.Pretty String)	line:255	language:Haskell
prettyModifier	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyModifier :: DD.Modifier -> Pretty SyntaxText$/;"	ft	signature:(DD.Modifier -> Pretty SyntaxText)	line:151	language:Haskell
prettyName	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyName :: IsString s => Name -> Pretty s$/;"	ft	signature:(IsString s => Name -> Pretty s)	line:18	language:Haskell
prettyNamedReference	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyNamedReference :: Int -> Name -> Reference -> Pretty SyntaxText$/;"	ft	signature:(Int -> Name -> Reference -> Pretty SyntaxText)	line:32	language:Haskell
prettyNamedReferent	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyNamedReferent :: Int -> Name -> Referent -> Pretty SyntaxText$/;"	ft	signature:(Int -> Name -> Referent -> Pretty SyntaxText)	line:38	language:Haskell
prettyParseError	./parser-typechecker/src/Unison/PrintError.hs	/^prettyParseError s = \\case$/;"	fi	line:904	language:Haskell
prettyPath'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyPath' :: Path.Path' -> Pretty$/;"	ft	signature:(Path.Path' -> Pretty)	line:951	language:Haskell
prettyPattern	./parser-typechecker/src/Unison/DeclPrinter.hs	/^prettyPattern env r namespace n = styleHashQualified'' (fmt S.Constructor)$/;"	fi	line:75	language:Haskell
prettyPattern	./parser-typechecker/src/Unison/TermPrinter.hs	/^prettyPattern n c@(AmbientContext { imports = im }) p vs patt = case patt of$/;"	fi	line:374	language:Haskell
prettyPrintEnv	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^prettyPrintEnv :: Names -> Action' m v PPE.PrettyPrintEnv$/;"	ft	signature:(Names -> Action' m v PPE.PrettyPrintEnv)	line:2366	language:Haskell
prettyPrintEnvDecl	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^prettyPrintEnvDecl :: Names -> Action' m v PPE.PrettyPrintEnvDecl$/;"	ft	signature:(Names -> Action' m v PPE.PrettyPrintEnvDecl)	line:2369	language:Haskell
prettyRaw	./parser-typechecker/src/Unison/TypePrinter.hs	/^prettyRaw n im p tp = go n im p tp$/;"	fi	line:74	language:Haskell
prettyReference	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyReference :: Int -> Reference -> Pretty SyntaxText$/;"	ft	signature:(Int -> Reference -> Pretty SyntaxText)	line:43	language:Haskell
prettyReferent	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyReferent :: Int -> Referent -> Pretty SyntaxText$/;"	ft	signature:(Int -> Referent -> Pretty SyntaxText)	line:48	language:Haskell
prettyRelative	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyRelative :: Path.Relative -> Pretty$/;"	ft	signature:(Path.Relative -> Pretty)	line:957	language:Haskell
prettyRemoteNamespace	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyRemoteNamespace :: (RemoteRepo.RemoteRepo,$/;"	ft	signature:((RemoteRepo.RemoteRepo, Maybe ShortBranchHash, Path.Path) -> P.Pretty P.ColorText)	line:236	language:Haskell
prettyResolutionFailures	./parser-typechecker/src/Unison/PrintError.hs	/^prettyResolutionFailures s failures = Pr.callout "â" $ Pr.linesNonEmpty$/;"	fi	line:1208	language:Haskell
prettySBH	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettySBH :: ShortBranchHash -> P.Pretty CT.ColorText$/;"	ft	signature:(ShortBranchHash -> P.Pretty CT.ColorText)	line:960	language:Haskell
prettyShortHash	./parser-typechecker/src/Unison/NamePrinter.hs	/^prettyShortHash :: IsString s => ShortHash -> Pretty s$/;"	ft	signature:(IsString s => ShortHash -> Pretty s)	line:52	language:Haskell
prettySignatures	./parser-typechecker/src/Unison/TypePrinter.hs	/^prettySignatures env ts = PP.lines $$/;"	fi	line:172	language:Haskell
prettySignatures'	./parser-typechecker/src/Unison/TypePrinter.hs	/^prettySignatures' env ts = map PP.syntaxToColor $ PP.align$/;"	fi	line:139	language:Haskell
prettySignaturesAlt	./parser-typechecker/src/Unison/TypePrinter.hs	/^prettySignaturesAlt env ts = PP.lines $$/;"	fi	line:180	language:Haskell
prettySignaturesAlt'	./parser-typechecker/src/Unison/TypePrinter.hs	/^prettySignaturesAlt' env ts = map PP.syntaxToColor $ PP.align$/;"	fi	line:154	language:Haskell
prettyStatus	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^prettyStatus :: Status -> P.Pretty P.ColorText$/;"	ft	signature:(Status -> P.Pretty P.ColorText)	line:142	language:Haskell
prettyTypeInfo	./parser-typechecker/src/Unison/PrintError.hs	/^prettyTypeInfo n e =$/;"	fi	line:1189	language:Haskell
prettyTypeResultHeader'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyTypeResultHeader' :: Var v => SR'.TypeResult' v a -> Pretty$/;"	ft	signature:(Var v => SR'.TypeResult' v a -> Pretty)	line:1121	language:Haskell
prettyTypeResultHeaderFull'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^prettyTypeResultHeaderFull' :: Var v => SR'.TypeResult' v a -> Pretty$/;"	ft	signature:(Var v => SR'.TypeResult' v a -> Pretty)	line:1129	language:Haskell
prettyTypecheckError	./parser-typechecker/src/Unison/PrintError.hs	/^prettyTypecheckError = renderTypeError . typeErrorFromNote$/;"	fi	line:1182	language:Haskell
prettyValue	./parser-typechecker/src/Unison/Runtime/IR.hs	/^prettyValue :: PPE.PrettyPrintEnv$/;"	ft	signature:(PPE.PrettyPrintEnv -> (e -> P.Pretty String) -> (cont -> P.Pretty String) -> Value e cont -> P.Pretty String)	line:347	language:Haskell
prettyVar	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^prettyVar :: Var v => v -> P.Pretty P.ColorText$/;"	ft	signature:(Var v => v -> P.Pretty P.ColorText)	line:156	language:Haskell
prettyVar	./parser-typechecker/src/Unison/PrintError.hs	/^prettyVar :: Var v => v -> Pretty ColorText$/;"	ft	signature:(Var v => v -> Pretty ColorText)	line:771	language:Haskell
prettyZ	./parser-typechecker/src/Unison/Runtime/IR.hs	/^prettyZ :: PPE.PrettyPrintEnv$/;"	ft	signature:(PPE.PrettyPrintEnv -> (e -> P.Pretty String) -> (cont -> P.Pretty String) -> Z e cont -> P.Pretty String)	line:244	language:Haskell
prevHistories	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^prevHistories :: [Grapheme] -> HistLog -> [([Grapheme],HistLog)]$/;"	ft	signature:([Grapheme] -> HistLog -> [([Grapheme], HistLog)])	line:22	language:Haskell
prevHistory	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^prevHistory, firstHistory :: Save s => s -> HistLog -> (s, HistLog)$/;"	ft	signature:(Save s => s -> HistLog -> (s, HistLog))	line:46	language:Haskell
prevHistoryM	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^prevHistoryM :: [Grapheme] -> HistLog -> Maybe ([Grapheme],HistLog)$/;"	ft	signature:([Grapheme] -> HistLog -> Maybe ([Grapheme], HistLog))	line:16	language:Haskell
previewAdd	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^previewAdd :: InputPattern$/;"	ft	signature:(InputPattern)	line:158	language:Haskell
previewMergeLocal	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^previewMergeLocal :: InputPattern$/;"	ft	signature:(InputPattern)	line:787	language:Haskell
previewUpdate	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^previewUpdate :: InputPattern$/;"	ft	signature:(InputPattern)	line:214	language:Haskell
previouslyTypecheckedVars	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^       , previouslyTypecheckedVars :: Set v -- term vars already typechecked$/;"	c_a	cons:Info.Info	line:334	language:Haskell
printAfter	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^printAfter :: [Grapheme] -> DrawM ()$/;"	ft	signature:([Grapheme] -> DrawM ())	line:289	language:Haskell
printAnnotate	./parser-typechecker/src/Unison/TermPrinter.hs	/^printAnnotate :: (Var v, Ord v) => PrettyPrintEnv -> Term2 v at ap v a -> Term3 v PrintAnnotation$/;"	ft	signature:((Var v, Ord v) => PrettyPrintEnv -> Term2 v at ap v a -> Term3 v PrintAnnotation)	line:788	language:Haskell
printCase	./parser-typechecker/src/Unison/TermPrinter.hs	/^printCase env im doc ms = PP.lines $ map each gridArrowsAligned where$/;"	fi	line:445	language:Haskell
printDebugPaths	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^printDebugPaths :: Branch m -> String$/;"	ft	signature:(Branch m -> String)	line:421	language:Haskell
printError	./unison-src/parser-tests/GenerateErrors.hs	/^printError :: Var v => String -> Err v -> IO ()$/;"	ft	signature:(Var v => String -> Err v -> IO ())	line:33	language:Haskell
printLines	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    printLines = mapM_ (printText . (++ crlf))$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	line:42	language:Haskell
printLines	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    printLines = mapM_ $ \\line -> runActionT $ do$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:357	language:Haskell
printLines	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    printLines [] = return ()$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:358	language:Haskell
printLines	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    printLines :: [String] -> m ()$/;"	ft	signature:([String] -> m ())	class:Term	line:23	language:Haskell
printNamespace	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^printNamespace :: RemoteRepo -> Maybe ShortBranchHash -> Path -> Text$/;"	ft	signature:(RemoteRepo -> Maybe ShortBranchHash -> Path -> Text)	line:19	language:Haskell
printNoteWithSource	./parser-typechecker/src/Unison/PrintError.hs	/^printNoteWithSource env  _s (TypeInfo  n) = prettyTypeInfo n env$/;"	fi	line:865	language:Haskell
printPage	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^printPage :: MonadReader Layout m => [String] -> CmdM m ()$/;"	ft	signature:(MonadReader Layout m => [String] -> CmdM m ())	line:110	language:Haskell
printPreservingLineChars	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^printPreservingLineChars :: Term m => LineChars -> String -> m ()$/;"	ft	signature:(Term m => LineChars -> String -> m ())	line:63	language:Haskell
printProtocol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^printProtocol :: GitProtocol -> Text$/;"	ft	signature:(GitProtocol -> Text)	line:59	language:Haskell
printRepo	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^printRepo :: RemoteRepo -> Text$/;"	ft	signature:(RemoteRepo -> Text)	line:16	language:Haskell
printText	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^printText :: MonadIO m => String -> DumbTerm m ()$/;"	ft	signature:(MonadIO m => String -> DumbTerm m ())	line:48	language:Haskell
printText	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^printText :: [Grapheme] -> ActionM ()$/;"	ft	signature:([Grapheme] -> ActionM ())	line:273	language:Haskell
printText	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^printText :: MonadIO m => String -> Draw m ()$/;"	ft	signature:(MonadIO m => String -> Draw m ())	line:284	language:Haskell
problem	./parser-typechecker/src/Unison/CommandLine.hs	/^problem :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s)	line:94	language:Haskell
processEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^processEvent :: InputEvent -> Maybe Event$/;"	ft	signature:(InputEvent -> Maybe Event)	line:76	language:Haskell
processFile	./unison-src/parser-tests/GenerateErrors.hs	/^processFile :: FilePath -> IO ()$/;"	ft	signature:(FilePath -> IO ())	line:36	language:Haskell
prog	./yaks/haskeline/tests/RunTTY.hs	/^            prog :: FilePath$/;"	c_a	cons:Invocation.Invocation	line:27	language:Haskell
progArgs	./yaks/haskeline/tests/RunTTY.hs	/^            , progArgs :: [String]$/;"	c_a	cons:Invocation.Invocation	line:28	language:Haskell
prompt	./parser-typechecker/src/Unison/CommandLine.hs	/^prompt :: String$/;"	ft	signature:(String)	line:179	language:Haskell
prompt	./yaks/haskeline/tests/Unit.hs	/^prompt, prompt' :: Int -> B.ByteString$/;"	ft	signature:(Int -> B.ByteString)	line:265	language:Haskell
prompt'	./yaks/haskeline/tests/Unit.hs	/^prompt, prompt' :: Int -> B.ByteString$/;"	ft	signature:(Int -> B.ByteString)	line:265	language:Haskell
prompt'	./yaks/haskeline/tests/Unit.hs	/^prompt' k = utf8 (T.pack (show k ++ ":"))$/;"	fi	line:268	language:Haskell
promptedInput	./yaks/haskeline/System/Console/Haskeline.hs	/^promptedInput :: MonadIO m => (TermOps -> String -> InputT m a)$/;"	ft	signature:(MonadIO m => (TermOps -> String -> InputT m a) -> (FileOps -> IO a) -> String -> InputT m a)	line:276	language:Haskell
propagate	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^propagate patch b = case validatePatch patch of$/;"	fi	line:137	language:Haskell
propagateAndApply	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^propagateAndApply patch branch = do$/;"	fi	line:74	language:Haskell
propagatePatch	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^propagatePatch :: (Monad m, Var v) =>$/;"	ft	signature:((Monad m, Var v) => InputDescription -> Patch -> Path.Absolute -> Action' m v Bool)	line:1651	language:Haskell
propagatedUpdates	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^propagatedUpdates :: Ord r => DiffSlice r -> Map Name (Set r)$/;"	ft	signature:(Ord r => DiffSlice r -> Map Name (Set r))	line:161	language:Haskell
propagatedUpdates	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  propagatedUpdates :: Int,$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:54	language:Haskell
proxy	./parser-typechecker/src/Unison/Parser.hs	/^proxy :: Proxy Input$/;"	ft	signature:(Proxy Input)	line:226	language:Haskell
ps	./unison-core/src/Unison/Pattern.hs	/^pattern SequenceLiteral ps = SequenceLiteralP () ps$/;"	fi	line:110	language:Haskell
pull	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^pull :: InputPattern$/;"	ft	signature:(InputPattern)	line:612	language:Haskell
pullBranch	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^pullBranch localPath uri treeish = do$/;"	fi	line:44	language:Haskell
pullGitBranch	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^pullGitBranch localPath codebase url treeish loadInfo = do$/;"	fi	line:83	language:Haskell
pullGitRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^pullGitRootBranch localPath loadMode codebase url treeish =$/;"	fi	line:69	language:Haskell
pullRemoteBranchAt	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^pullRemoteBranchAt p' input inputDescription ns p = do$/;"	fi	line:1905	language:Haskell
pure	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  pure = PutT . pure . pure$/;"	fi	instance:Applicative m => Applicative (PutT m)	line:46	language:Haskell
pure	./parser-typechecker/src/Unison/Lexer.hs	/^  pure a = Token a (Pos 0 0) (Pos 0 0)$/;"	fi	instance:Applicative Token	line:117	language:Haskell
pure	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  pure = Success mempty$/;"	fi	instance:Applicative (Result v loc)	line:136	language:Haskell
pure	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  pure a = MT (\\menv -> pure (a, env menv))$/;"	fi	instance:Monad f => Applicative (MT v loc f)	line:1805	language:Haskell
pure	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  pure = return$/;"	fi	instance:Applicative (SubseqExtractor' n)	line:312	language:Haskell
pure	./parser-typechecker/src/Unison/Util/Free.hs	/^  pure = Pure$/;"	fi	instance:Applicative (Free f)	line:65	language:Haskell
pure	./yaks/easytest/src/EasyTest.hs	/^  pure = return$/;"	fi	instance:Applicative Test	line:396	language:Haskell
pure	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    pure  = Result$/;"	fi	instance:Monad m => Applicative (CmdM m)	line:69	language:Haskell
pure	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    pure x = StateT $ \\s -> return $ \\f -> f x s$/;"	fi	instance:Monad m => Applicative (StateT s m)	line:78	language:Haskell
pureMovements	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^pureMovements :: InputKeyCmd (ArgMode CommandMode) CommandMode$/;"	ft	signature:(InputKeyCmd (ArgMode CommandMode) CommandMode)	line:146	language:Haskell
purple	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
purple	./parser-typechecker/src/Unison/Util/ColorText.hs	/^purple = style Purple$/;"	fi	line:30	language:Haskell
purple	./parser-typechecker/src/Unison/Util/Pretty.hs	/^purple = map CT.purple$/;"	fi	line:673	language:Haskell
push	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^push :: InputPattern$/;"	ft	signature:(InputPattern)	line:657	language:Haskell
push	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^push :: Size -> Value -> Stack -> IO Stack$/;"	ft	signature:(Size -> Value -> Stack -> IO Stack)	line:167	language:Haskell
push	./unison-core/src/Unison/Names3.hs	/^push :: Names0 -> Names -> Names$/;"	ft	signature:(Names0 -> Names -> Names)	line:86	language:Haskell
push	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^push :: a -> Stack a -> Stack a$/;"	ft	signature:(a -> Stack a -> Stack a)	line:27	language:Haskell
pushGitRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/Git.hs	/^pushGitRootBranch localPath codebase branch url gitbranch = do$/;"	fi	line:129	language:Haskell
pushMany	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^pushMany :: Foldable f$/;"	ft	signature:(Foldable f => Size -> f Value -> Stack -> IO (Size, Stack))	line:175	language:Haskell
pushManyZ	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^pushManyZ :: Foldable f => Size -> f Z -> Stack -> IO (Size, Stack)$/;"	ft	signature:(Foldable f => Size -> f Z -> Stack -> IO (Size, Stack))	line:186	language:Haskell
pushPull	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^pushPull :: a -> a -> PushPull -> a$/;"	ft	signature:(a -> a -> PushPull -> a)	line:65	language:Haskell
put	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^  put :: Put a$/;"	c_a	cons:Format.Format	line:19	language:Haskell
put	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    put :: s -> m ()$/;"	ft	signature:(s -> m ())	class:MonadState	line:53	language:Haskell
put	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    put s = s `seq` StateT $ \\_ -> return $ \\f -> f () s$/;"	fi	instance:Monad m => MonadState s (StateT s m)	line:110	language:Haskell
put	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    put = lift . put$/;"	fi	instance:(MonadState s m, MonadTrans t, Monad (t m)) => MonadState s (t m)	line:115	language:Haskell
put	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    put s = ask >>= liftIO . flip writeIORef s$/;"	fi	instance:MonadIO m => MonadState s (ReaderT (IORef s) m)	line:121	language:Haskell
putABT	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putABT putVar putA putF abt =$/;"	fi	line:316	language:Haskell
putBackref	./parser-typechecker/src/Unison/Codecs.hs	/^putBackref :: MonadPut m => Pos -> m ()$/;"	ft	signature:(MonadPut m => Pos -> m ())	line:269	language:Haskell
putBoolean	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putBoolean :: MonadPut m => Bool -> m ()$/;"	ft	signature:(MonadPut m => Bool -> m ())	line:204	language:Haskell
putBranchStar	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putBranchStar :: MonadPut m => (a -> m ()) -> (n -> m ()) -> Branch.Star a n -> m ()$/;"	ft	signature:(MonadPut m => (a -> m ()) -> (n -> m ()) -> Branch.Star a n -> m ())	line:660	language:Haskell
putByteString	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putByteString = PutT . pure . putByteString$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:15	language:Haskell
putBytes	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^putBytes :: Put a -> a -> ByteString$/;"	ft	signature:(Put a -> a -> ByteString)	line:37	language:Haskell
putChar	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putChar :: MonadPut m => Char -> m ()$/;"	ft	signature:(MonadPut m => Char -> m ())	line:673	language:Haskell
putConstructorType	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putConstructorType :: MonadPut m => CT.ConstructorType -> m ()$/;"	ft	signature:(MonadPut m => CT.ConstructorType -> m ())	line:257	language:Haskell
putDataDeclaration	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putDataDeclaration :: (MonadPut m, Ord v)$/;"	ft	signature:((MonadPut m, Ord v) => (v -> m ()) -> (a -> m ()) -> DataDeclaration' v a -> m ())	line:712	language:Haskell
putDecl	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^putDecl putV putA path h decl = liftIO $ do$/;"	fi	line:536	language:Haskell
putEdits	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putEdits :: MonadPut m => Patch -> m ()$/;"	ft	signature:(MonadPut m => Patch -> m ())	line:761	language:Haskell
putEffectDeclaration	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putEffectDeclaration ::$/;"	ft	signature:((MonadPut m, Ord v) => (v -> m ()) -> (a -> m ()) -> EffectDeclaration' v a -> m ())	line:739	language:Haskell
putEither	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putEither :: (MonadPut m) => (a -> m ()) -> (b -> m ()) -> Either a b -> m ()$/;"	ft	signature:((MonadPut m) => (a -> m ()) -> (b -> m ()) -> Either a b -> m ())	line:748	language:Haskell
putFloat	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putFloat :: MonadPut m => Double -> m ()$/;"	ft	signature:(MonadPut m => Double -> m ())	line:186	language:Haskell
putFoldable	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putFoldable putA as = do$/;"	fi	line:288	language:Haskell
putHash	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putHash :: MonadPut m => Hash -> m ()$/;"	ft	signature:(MonadPut m => Hash -> m ())	line:214	language:Haskell
putHistory	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^putHistory :: MonadIO m => History -> InputT m ()$/;"	ft	signature:(MonadIO m => History -> InputT m ())	line:66	language:Haskell
putInput	./yaks/haskeline/tests/Pty.hs	/^putInput :: Fd -> B.ByteString -> IO ()$/;"	ft	signature:(Fd -> B.ByteString -> IO ())	line:50	language:Haskell
putInt	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putInt :: MonadPut m => Int64 -> m ()$/;"	ft	signature:(MonadPut m => Int64 -> m ())	line:198	language:Haskell
putKind	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putKind :: MonadPut m => Kind -> m ()$/;"	ft	signature:(MonadPut m => Kind -> m ())	line:357	language:Haskell
putLazyByteString	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putLazyByteString = PutT . pure . putLazyByteString$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:17	language:Haskell
putLength	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putLength ::$/;"	ft	signature:((MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ())	line:162	language:Haskell
putLength	./parser-typechecker/src/Unison/Codecs.hs	/^putLength :: (MonadPut m, Integral n, Integral (Unsigned n),$/;"	ft	signature:((MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ())	line:272	language:Haskell
putLink	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putLink :: MonadPut m => (Hash, mb) -> m ()$/;"	ft	signature:(MonadPut m => (Hash, mb) -> m ())	line:667	language:Haskell
putMap	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()$/;"	ft	signature:(MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ())	line:597	language:Haskell
putMaybe	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putMaybe :: MonadPut m => Maybe a -> (a -> m ()) -> m ()$/;"	ft	signature:(MonadPut m => Maybe a -> (a -> m ()) -> m ())	line:276	language:Haskell
putMetadataType	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putMetadataType :: MonadPut m => Metadata.Type -> m ()$/;"	ft	signature:(MonadPut m => Metadata.Type -> m ())	line:695	language:Haskell
putMetadataValue	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putMetadataValue :: MonadPut m => Metadata.Value -> m ()$/;"	ft	signature:(MonadPut m => Metadata.Value -> m ())	line:701	language:Haskell
putModifier	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putModifier :: MonadPut m => DataDeclaration.Modifier -> m ()$/;"	ft	signature:(MonadPut m => DataDeclaration.Modifier -> m ())	line:729	language:Haskell
putNameSegment	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putNameSegment :: MonadPut m => NameSegment -> m ()$/;"	ft	signature:(MonadPut m => NameSegment -> m ())	line:679	language:Haskell
putNat	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putNat :: MonadPut m => Word64 -> m ()$/;"	ft	signature:(MonadPut m => Word64 -> m ())	line:192	language:Haskell
putOut	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^putOut :: IO (String -> IO ())$/;"	ft	signature:(IO (String -> IO ()))	line:421	language:Haskell
putPair	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a,b) -> m ()$/;"	ft	signature:(MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ())	line:565	language:Haskell
putPair''	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putPair'' putA putBn (a, b) = pure (putA a) *> putBn b$/;"	fi	line:574	language:Haskell
putPattern	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putPattern :: MonadPut m => (a -> m ()) -> Pattern a -> m ()$/;"	ft	signature:(MonadPut m => (a -> m ()) -> Pattern a -> m ())	line:403	language:Haskell
putPretty'	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^putPretty' :: P.Pretty CT.ColorText -> IO ()$/;"	ft	signature:(P.Pretty CT.ColorText -> IO ())	line:40	language:Haskell
putPrettyLn	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^putPrettyLn :: P.Pretty CT.ColorText -> IO ()$/;"	ft	signature:(P.Pretty CT.ColorText -> IO ())	line:15	language:Haskell
putPrettyLn'	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^putPrettyLn' :: P.Pretty CT.ColorText -> IO ()$/;"	ft	signature:(P.Pretty CT.ColorText -> IO ())	line:27	language:Haskell
putPrettyLnUnpaged	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^putPrettyLnUnpaged :: P.Pretty CT.ColorText -> IO ()$/;"	ft	signature:(P.Pretty CT.ColorText -> IO ())	line:21	language:Haskell
putPrettyNonempty	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^putPrettyNonempty :: P.Pretty P.ColorText -> IO ()$/;"	ft	signature:(P.Pretty P.ColorText -> IO ())	line:49	language:Haskell
putRawBranch	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putRawBranch :: MonadPut m => Branch.Raw -> m ()$/;"	ft	signature:(MonadPut m => Branch.Raw -> m ())	line:685	language:Haskell
putRawCausal	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putRawCausal :: MonadPut m => (a -> m ()) -> Causal.Raw h a -> m ()$/;"	ft	signature:(MonadPut m => (a -> m ()) -> Causal.Raw h a -> m ())	line:91	language:Haskell
putReference	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putReference :: MonadPut m => Reference -> m ()$/;"	ft	signature:(MonadPut m => Reference -> m ())	line:226	language:Haskell
putReferent	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putReferent :: MonadPut m => Referent -> m ()$/;"	ft	signature:(MonadPut m => Referent -> m ())	line:246	language:Haskell
putRelation	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putRelation :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Relation a b -> m ()$/;"	ft	signature:(MonadPut m => (a -> m ()) -> (b -> m ()) -> Relation a b -> m ())	line:591	language:Haskell
putResult	./yaks/easytest/src/EasyTest.hs	/^putResult :: Status -> ReaderT Env IO ()$/;"	ft	signature:(Status -> ReaderT Env IO ())	line:359	language:Haskell
putRootBranch	./parser-typechecker/src/Unison/Codebase.hs	/^           , putRootBranch      :: Branch m -> m ()$/;"	c_a	cons:Codebase.Codebase	line:56	language:Haskell
putRootBranch	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^putRootBranch :: MonadIO m => CodebasePath -> Branch m -> m ()$/;"	ft	signature:(MonadIO m => CodebasePath -> Branch m -> m ())	line:351	language:Haskell
putSeqOp	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putSeqOp :: MonadPut m => SeqOp -> m ()$/;"	ft	signature:(MonadPut m => SeqOp -> m ())	line:437	language:Haskell
putStar3	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putStar3 putF putD1 putD2 putD3 s = do$/;"	fi	line:640	language:Haskell
putStrOut	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            putStrOut :: String -> IO (),$/;"	c_a	cons:RunTerm.RunTerm	line:35	language:Haskell
putSymbol	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putSymbol :: MonadPut m => Symbol -> m ()$/;"	ft	signature:(MonadPut m => Symbol -> m ())	line:397	language:Haskell
putTerm	./parser-typechecker/src/Unison/Codebase.hs	/^           , putTerm            :: Reference.Id -> Term v a -> Type v a -> m ()$/;"	c_a	cons:Codebase.Codebase	line:52	language:Haskell
putTerm	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^putTerm putV putA path h e typ = liftIO $ do$/;"	fi	line:507	language:Haskell
putTerm	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putTerm :: (MonadPut m, Ord v)$/;"	ft	signature:((MonadPut m, Ord v) => (v -> m ()) -> (a -> m ()) -> Term v a -> m ())	line:479	language:Haskell
putTermEdit	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putTermEdit :: MonadPut m => TermEdit -> m ()$/;"	ft	signature:(MonadPut m => TermEdit -> m ())	line:603	language:Haskell
putText	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putText :: MonadPut m => Text -> m ()$/;"	ft	signature:(MonadPut m => Text -> m ())	line:174	language:Haskell
putTuple3'	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putTuple3' putA putB putC (a, b, c) = putA a *> putB b *> putC c$/;"	fi	line:586	language:Haskell
putType	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putType :: (MonadPut m, Ord v)$/;"	ft	signature:((MonadPut m, Ord v) => (v -> m ()) -> (a -> m ()) -> Type v a -> m ())	line:368	language:Haskell
putTypeDeclaration	./parser-typechecker/src/Unison/Codebase.hs	/^           , putTypeDeclaration :: Reference.Id -> Decl v a -> m ()$/;"	c_a	cons:Codebase.Codebase	line:53	language:Haskell
putTypeEdit	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^putTypeEdit :: MonadPut m => TypeEdit -> m ()$/;"	ft	signature:(MonadPut m => TypeEdit -> m ())	line:622	language:Haskell
putWatch	./parser-typechecker/src/Unison/Codebase.hs	/^           , putWatch           :: UF.WatchKind -> Reference.Id -> Term v a -> m ()$/;"	c_a	cons:Codebase.Codebase	line:74	language:Haskell
putWatch	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^putWatch putV putA path k id e = liftIO $ S.putWithParentDirs$/;"	fi	line:569	language:Haskell
putWithParentDirs	./parser-typechecker/src/Unison/Codebase/Serialization.hs	/^putWithParentDirs :: Put a -> FilePath -> a -> IO ()$/;"	ft	signature:(Put a -> FilePath -> a -> IO ())	line:40	language:Haskell
putWord16be	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord16be   = PutT . pure . putWord16be$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:23	language:Haskell
putWord16host	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord16host = PutT . pure . putWord16host$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:25	language:Haskell
putWord16le	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord16le   = PutT . pure . putWord16le$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:21	language:Haskell
putWord32be	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord32be   = PutT . pure . putWord32be$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:29	language:Haskell
putWord32host	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord32host = PutT . pure . putWord32host$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:31	language:Haskell
putWord32le	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord32le   = PutT . pure . putWord32le$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:27	language:Haskell
putWord64be	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord64be   = PutT . pure . putWord64be$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:35	language:Haskell
putWord64host	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord64host = PutT . pure . putWord64host$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:37	language:Haskell
putWord64le	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord64le   = PutT . pure . putWord64le$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:33	language:Haskell
putWord8	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWord8 = PutT . pure . putWord8$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:13	language:Haskell
putWordhost	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^  putWordhost   = PutT . pure . putWordhost$/;"	fi	instance:Monad m => MonadPut (PutT m)	line:39	language:Haskell
queryInput	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^queryInput :: InputState -> InputT IO a -> IO a$/;"	ft	signature:(InputState -> InputT IO a -> IO a)	line:94	language:Haskell
queryToken	./parser-typechecker/src/Unison/Parser.hs	/^queryToken :: Ord v => (L.Lexeme -> Maybe a) -> P v (L.Token a)$/;"	ft	signature:(Ord v => (L.Lexeme -> Maybe a) -> P v (L.Token a))	line:249	language:Haskell
quit	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^quit :: InputPattern$/;"	ft	signature:(InputPattern)	line:1012	language:Haskell
r	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  r                     <*> CompilerBug bug es' is' = CompilerBug bug (typeErrors r <> es') (infoNotes r <> is')$/;"	fi	instance:Applicative (Result v loc)	line:138	language:Haskell
r	./unison-core/src/Unison/Pattern.hs	/^pattern Constructor r cid ps = ConstructorP () r cid ps$/;"	fi	line:106	language:Haskell
r	./unison-core/src/Unison/Pattern.hs	/^pattern EffectBind r cid ps k = EffectBindP () r cid ps k$/;"	fi	line:109	language:Haskell
r	./unison-core/src/Unison/Referent.hs	/^pattern Ref r = Ref' r$/;"	fi	line:24	language:Haskell
r	./unison-core/src/Unison/Referent.hs	/^pattern Con r i t = Con' r i t$/;"	fi	line:26	language:Haskell
r	./unison-core/src/Unison/Util/Relation.hs	/^r |> t = fromList$/;"	fi	line:359	language:Haskell
r	./unison-core/src/Unison/Util/Relation.hs	/^r ||> t = fromList [ (a,b) | (a,b) <- toList r, not (b `S.member` t)]$/;"	fi	line:369	language:Haskell
rBoxStyle2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^lBoxStyle1, lBoxStyle2, rBoxStyle2 :: IsString s => BoxStyle s$/;"	ft	signature:(IsString s => BoxStyle s)	line:723	language:Haskell
rBoxStyle2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^rBoxStyle2 = ((" â", " â")$/;"	fi	line:732	language:Haskell
raceIO	./parser-typechecker/src/Unison/Util/TQueue.hs	/^raceIO :: MonadUnliftIO m => STM a -> STM b -> m (Either a b)$/;"	ft	signature:(MonadUnliftIO m => STM a -> STM b -> m (Either a b))	line:67	language:Haskell
ran	./unison-core/src/Unison/Util/Relation.hs	/^ran :: Relation a b -> Set b$/;"	ft	signature:(Relation a b -> Set b)	line:273	language:Haskell
random	./yaks/easytest/src/EasyTest.hs	/^random :: Random a => Test a$/;"	ft	signature:(Random a => Test a)	line:195	language:Haskell
random'	./yaks/easytest/src/EasyTest.hs	/^random' :: Random a => a -> a -> Test a$/;"	ft	signature:(Random a => a -> a -> Test a)	line:205	language:Haskell
range	./unison-core/src/Unison/Util/Relation.hs	/^                              , range  ::  M.Map b (Set a)$/;"	c_a	cons:Relation.Relation	line:34	language:Haskell
rangeForAnnotated	./parser-typechecker/src/Unison/PrintError.hs	/^rangeForAnnotated :: Annotated a => a -> Maybe Range$/;"	ft	signature:(Annotated a => a -> Maybe Range)	line:838	language:Haskell
rangeForToken	./parser-typechecker/src/Unison/PrintError.hs	/^rangeForToken :: L.Token a -> Range$/;"	ft	signature:(L.Token a -> Range)	line:804	language:Haskell
rangeToEnglish	./parser-typechecker/src/Unison/PrintError.hs	/^rangeToEnglish :: IsString s => Range -> s$/;"	ft	signature:(IsString s => Range -> s)	line:807	language:Haskell
raw	./parser-typechecker/src/Unison/Util/Logger.hs	/^         , raw :: String -> IO () }$/;"	c_a	cons:Logger.Logger	line:31	language:Haskell
raw	./yaks/haskeline/tests/Unit.hs	/^raw :: [Word8] -> B.ByteString$/;"	ft	signature:([Word8] -> B.ByteString)	line:292	language:Haskell
rawHead	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^rawHead :: Raw h e -> e$/;"	ft	signature:(Raw h e -> e)	line:102	language:Haskell
reabs	./unison-core/src/Unison/ABT.hs	/^reabs :: Ord v => [v] -> Term f v () -> Term f v ()$/;"	ft	signature:(Ord v => [v] -> Term f v () -> Term f v ())	line:474	language:Haskell
read	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^read deserializeRaw deserializeEdits h = Branch <$> Causal.read d h$/;"	fi	line:456	language:Haskell
read	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^read :: Functor m => Deserialize m h e -> RawHash h -> m (Causal m h e)$/;"	ft	signature:(Functor m => Deserialize m h e -> RawHash h -> m (Causal m h e))	line:115	language:Haskell
readAndParseFile	./parser-typechecker/src/Unison/Parsers.hs	/^readAndParseFile penv fileName = do$/;"	fi	line:63	language:Haskell
readEvents	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^readEvents :: HANDLE -> IO [InputEvent]$/;"	ft	signature:(HANDLE -> IO [InputEvent])	line:140	language:Haskell
readHistory	./yaks/haskeline/System/Console/Haskeline/History.hs	/^readHistory :: FilePath -> IO History$/;"	ft	signature:(FilePath -> IO History)	line:58	language:Haskell
readMaybe	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^readMaybe :: Read a => String -> Maybe a$/;"	ft	signature:(Read a => String -> Maybe a)	line:85	language:Haskell
readPrefs	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^readPrefs :: FilePath -> IO Prefs$/;"	ft	signature:(FilePath -> IO Prefs)	line:128	language:Haskell
readPrefsFromHome	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^readPrefsFromHome :: IO Prefs$/;"	ft	signature:(IO Prefs)	line:194	language:Haskell
readSuffix	./unison-core/src/Unison/Reference.hs	/^readSuffix :: Text -> Either String (Pos, Size)$/;"	ft	signature:(Text -> Either String (Pos, Size))	line:95	language:Haskell
readUTF8File	./yaks/haskeline/System/Console/Haskeline/History.hs	/^readUTF8File :: FilePath -> IO String$/;"	ft	signature:(FilePath -> IO String)	line:114	language:Haskell
readUtf8	./unison-core/src/Unison/Prelude.hs	/^readUtf8 :: FilePath -> IO Text$/;"	ft	signature:(FilePath -> IO Text)	line:36	language:Haskell
reader	./yaks/easytest/src/EasyTest.hs	/^  reader f = Test (Just <$> reader f)$/;"	fi	instance:MonadReader Env Test	line:374	language:Haskell
reannotateUp	./unison-core/src/Unison/ABT.hs	/^reannotateUp :: (Ord v, Foldable f, Functor f, Monoid b)$/;"	ft	signature:((Ord v, Foldable f, Functor f, Monoid b) => (Term f v a -> b) -> Term f v a -> Term f v (a, b))	line:489	language:Haskell
reason	./parser-typechecker/src/Unison/Codebase/Editor/Output.hs	/^  ReflogEntry { hash :: ShortBranchHash, reason :: Text }$/;"	c_a	cons:ReflogEntry.ReflogEntry	line:198	language:Haskell
reason	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^    , reason :: Text$/;"	c_a	cons:Entry.Entry	line:15	language:Haskell
rebuildUp	./unison-core/src/Unison/ABT.hs	/^rebuildUp :: (Ord v, Foldable f, Functor f)$/;"	ft	signature:((Ord v, Foldable f, Functor f) => (f (Term f v a) -> f (Term f v a)) -> Term f v a -> Term f v a)	line:364	language:Haskell
rebuildUp'	./unison-core/src/Unison/ABT.hs	/^rebuildUp' :: (Ord v, Foldable f, Functor f)$/;"	ft	signature:((Ord v, Foldable f, Functor f) => (Term f v a -> Term f v a) -> Term f v a -> Term f v a)	line:374	language:Haskell
red	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
red	./parser-typechecker/src/Unison/Util/ColorText.hs	/^red = style Red$/;"	fi	line:26	language:Haskell
red	./parser-typechecker/src/Unison/Util/Pretty.hs	/^red = map CT.red$/;"	fi	line:669	language:Haskell
redoFuture	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^undoPast, redoFuture :: Save s => s -> Undo -> (s,Undo)$/;"	ft	signature:(Save s => s -> Undo -> (s, Undo))	line:30	language:Haskell
redoFuture	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^redoFuture ls u@Undo {futureRedo = []} = (ls,u)$/;"	fi	line:35	language:Haskell
ref	./unison-core/src/Unison/Term.hs	/^ref :: Ord v => a -> Reference -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Reference -> Term2 vt at ap v a)	line:470	language:Haskell
ref	./unison-core/src/Unison/Type.hs	/^ref :: Ord v => a -> Reference -> Type v a$/;"	ft	signature:(Ord v => a -> Reference -> Type v a)	line:197	language:Haskell
refNamed	./unison-core/src/Unison/Var.hs	/^refNamed :: Var v => Reference -> v$/;"	ft	signature:(Var v => Reference -> v)	line:37	language:Haskell
refTermsNamed	./unison-core/src/Unison/Names2.hs	/^refTermsNamed :: Ord n => Names' n -> n -> Set Reference$/;"	ft	signature:(Ord n => Names' n -> n -> Set Reference)	line:185	language:Haskell
reference	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^  , reference   :: Reference$/;"	c_a	cons:TypeResult.TypeResult	line:29	language:Haskell
referenceToDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^referenceToDir :: Reference -> FilePath$/;"	ft	signature:(Reference -> FilePath)	line:197	language:Haskell
references	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^references :: TermEdit -> [Reference]$/;"	ft	signature:(TermEdit -> [Reference])	line:13	language:Haskell
references	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^references :: TypeEdit -> [Reference]$/;"	ft	signature:(TypeEdit -> [Reference])	line:10	language:Haskell
referent	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^  , referent    :: Referent$/;"	c_a	cons:TermResult.TermResult	line:23	language:Haskell
referent	./unison-core/src/Unison/LabeledDependency.hs	/^referent :: Referent -> LabeledDependency$/;"	ft	signature:(Referent -> LabeledDependency)	line:17	language:Haskell
referent	./unison-core/src/Unison/LabeledDependency.hs	/^referent = X . Right$/;"	fi	line:25	language:Haskell
referentFromString	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^referentFromString :: String -> Maybe Referent$/;"	ft	signature:(String -> Maybe Referent)	line:409	language:Haskell
referentToString	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^referentToString :: Referent -> String$/;"	ft	signature:(Referent -> String)	line:413	language:Haskell
referents	./unison-core/src/Unison/LabeledDependency.hs	/^referents :: Foldable f => f Referent -> Set LabeledDependency$/;"	ft	signature:(Foldable f => f Referent -> Set LabeledDependency)	line:29	language:Haskell
refitLine	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^refitLine :: ([Grapheme],[Grapheme]) -> DumbTermM ()$/;"	ft	signature:(([Grapheme], [Grapheme]) -> DumbTermM ())	line:97	language:Haskell
reflogPath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^reflogPath :: CodebasePath -> FilePath$/;"	ft	signature:(CodebasePath -> FilePath)	line:271	language:Haskell
reinputArg	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^reinputArg :: LineState s => InputKeyCmd (ArgMode s) (ArgMode s)$/;"	ft	signature:(LineState s => InputKeyCmd (ArgMode s) (ArgMode s))	line:244	language:Haskell
relative	./parser-typechecker/tests/Unison/Test/Codebase/Path.hs	/^relative :: Seq Text -> Path'$/;"	ft	signature:(Seq Text -> Path')	line:66	language:Haskell
relativeEmpty'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^relativeEmpty' :: Path'$/;"	ft	signature:(Path')	line:226	language:Haskell
relativeSingleton	./parser-typechecker/src/Unison/Codebase/Path.hs	/^relativeSingleton :: NameSegment -> Relative$/;"	ft	signature:(NameSegment -> Relative)	line:229	language:Haskell
relativeToAncestor	./parser-typechecker/src/Unison/Codebase/Path.hs	/^relativeToAncestor :: Path -> Path -> (Path, Path, Path)$/;"	ft	signature:(Path -> Path -> (Path, Path, Path))	line:306	language:Haskell
rem	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^ceilDiv m n | m `rem` n == 0    =  m `div` n$/;"	fi	line:161	language:Haskell
removeAllEffectVars	./unison-core/src/Unison/Type.hs	/^removeAllEffectVars :: ABT.Var v => Type v a -> Type v a$/;"	ft	signature:(ABT.Var v => Type v a -> Type v a)	line:456	language:Haskell
removeEffectVars	./unison-core/src/Unison/Type.hs	/^removeEffectVars :: ABT.Var v => Set v -> Type v a -> Type v a$/;"	ft	signature:(ABT.Var v => Set v -> Type v a -> Type v a)	line:437	language:Haskell
removePureEffects	./unison-core/src/Unison/Settings.hs	/^removePureEffects :: Bool$/;"	ft	signature:(Bool)	line:14	language:Haskell
removePureEffects	./unison-core/src/Unison/Type.hs	/^removePureEffects :: ABT.Var v => Type v a -> Type v a$/;"	ft	signature:(ABT.Var v => Type v a -> Type v a)	line:465	language:Haskell
removed	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^  NameEdit { added :: Set Reference, removed :: Set Reference }$/;"	c_a	cons:NameEdit.NameEdit	line:9	language:Haskell
removedMetadata	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^               , removedMetadata :: [tm] }$/;"	c_a	cons:MetadataDiff.MetadataDiff	line:36	language:Haskell
removedNames	./unison-core/src/Unison/Names3.hs	/^       , removedNames  :: Names0$/;"	c_a	cons:Diff.Diff	line:74	language:Haskell
removedPatchEdited	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^    removedPatchEdited :: [Name]$/;"	c_a	cons:BranchAttentions.BranchAttentions	line:817	language:Haskell
removedPatches	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  removedPatches    :: [PatchDisplay],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:61	language:Haskell
removedTerms	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , removedTerms :: Star Referent NameSegment$/;"	c_a	cons:BranchDiff.BranchDiff	line:181	language:Haskell
removedTerms	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  removedTerms      :: [RemovedTermDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:60	language:Haskell
removedTypes	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  , removedTypes :: Star Reference NameSegment$/;"	c_a	cons:BranchDiff.BranchDiff	line:183	language:Haskell
removedTypes	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  removedTypes      :: [RemovedTypeDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:59	language:Haskell
rename	./unison-core/src/Unison/ABT.hs	/^rename :: (Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a$/;"	ft	signature:((Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a)	line:246	language:Haskell
renameBranch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^renameBranch :: InputPattern$/;"	ft	signature:(InputPattern)	line:552	language:Haskell
renamePatch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^renamePatch :: InputPattern$/;"	ft	signature:(InputPattern)	line:542	language:Haskell
renameTerm	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^renameTerm :: InputPattern$/;"	ft	signature:(InputPattern)	line:356	language:Haskell
renameType	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^renameType :: InputPattern$/;"	ft	signature:(InputPattern)	line:369	language:Haskell
renameTypeVar	./unison-core/src/Unison/Term.hs	/^renameTypeVar :: (Ord v, ABT.Var vt) => vt -> vt -> Term' vt v a -> Term' vt v a$/;"	ft	signature:((Ord v, ABT.Var vt) => vt -> vt -> Term' vt v a -> Term' vt v a)	line:354	language:Haskell
renamedTerms	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  renamedTerms      :: [RenameTermDisplay v a]$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:63	language:Haskell
renamedTypes	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  renamedTypes      :: [RenameTypeDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:62	language:Haskell
render	./parser-typechecker/src/Unison/Util/Pretty.hs	/^render :: (Monoid s, IsString s) => Width -> Pretty s -> s$/;"	ft	signature:((Monoid s, IsString s) => Width -> Pretty s -> s)	line:254	language:Haskell
renderChoices	./parser-typechecker/src/Unison/Util/Menu.hs	/^renderChoices :: forall a mc$/;"	ft	signature:(forall a mc . (a -> Stylized) -> (mc -> Stylized) -> [([Keyword], [a])] -> [([Keyword], mc)] -> (Keyword -> Bool) -> Stylized)	line:24	language:Haskell
renderContext	./parser-typechecker/src/Unison/PrintError.hs	/^renderContext env ctx@(C.Context es) = "  Î\\n    "$/;"	fi	line:679	language:Haskell
renderEditConflicts	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^renderEditConflicts ::$/;"	ft	signature:(PPE.PrettyPrintEnv -> Patch -> Pretty)	line:1173	language:Haskell
renderEx2	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^renderEx2 :: String$/;"	ft	signature:(String)	line:39	language:Haskell
renderFileName	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^renderFileName :: FilePath -> IO (Pretty)$/;"	ft	signature:(FilePath -> IO (Pretty))	line:124	language:Haskell
renderKind	./parser-typechecker/src/Unison/PrintError.hs	/^renderKind :: Kind -> Pretty (AnnotatedText a)$/;"	ft	signature:(Kind -> Pretty (AnnotatedText a))	line:774	language:Haskell
renderNameConflicts	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^renderNameConflicts :: Set.Set Name -> Set.Set Name -> Pretty$/;"	ft	signature:(Set.Set Name -> Set.Set Name -> Pretty)	line:1154	language:Haskell
renderNoteAsANSI	./parser-typechecker/src/Unison/PrintError.hs	/^renderNoteAsANSI w e s n = Pr.toANSI w $ printNoteWithSource e s n$/;"	fi	line:854	language:Haskell
renderParseErrorAsANSI	./parser-typechecker/src/Unison/PrintError.hs	/^renderParseErrorAsANSI :: Var v => Pr.Width -> String -> Parser.Err v -> String$/;"	ft	signature:(Var v => Pr.Width -> String -> Parser.Err v -> String)	line:856	language:Haskell
renderSuggestion	./parser-typechecker/src/Unison/PrintError.hs	/^renderSuggestion env sug =$/;"	fi	line:749	language:Haskell
renderTerm	./parser-typechecker/src/Unison/PrintError.hs	/^renderTerm :: (IsString s, Var v) => Env -> C.Term v loc -> s$/;"	ft	signature:((IsString s, Var v) => Env -> C.Term v loc -> s)	line:698	language:Haskell
renderTermMaxLength	./unison-core/src/Unison/Settings.hs	/^renderTermMaxLength :: Int$/;"	ft	signature:(Int)	line:8	language:Haskell
renderType	./parser-typechecker/src/Unison/PrintError.hs	/^renderType env f t = renderType0 env f (0 :: Int) (Type.removePureEffects t)$/;"	fi	line:718	language:Haskell
renderType'	./parser-typechecker/src/Unison/PrintError.hs	/^renderType' :: (IsString s, Var v) => Env -> Type v loc -> s$/;"	ft	signature:((IsString s, Var v) => Env -> Type v loc -> s)	line:706	language:Haskell
renderTypeError	./parser-typechecker/src/Unison/PrintError.hs	/^renderTypeError e env src = case e of$/;"	fi	line:150	language:Haskell
renderTypeInfo	./parser-typechecker/src/Unison/PrintError.hs	/^renderTypeInfo i env = case i of$/;"	fi	line:126	language:Haskell
renderUnbroken	./parser-typechecker/src/Unison/Util/Pretty.hs	/^renderUnbroken :: (Monoid s, IsString s) => Pretty s -> s$/;"	ft	signature:((Monoid s, IsString s) => Pretty s -> s)	line:251	language:Haskell
renderVar	./parser-typechecker/src/Unison/PrintError.hs	/^renderVar :: (IsString a, Var v) => v -> a$/;"	ft	signature:((IsString a, Var v) => v -> a)	line:763	language:Haskell
renderVar'	./parser-typechecker/src/Unison/PrintError.hs	/^renderVar' :: (Var v, Annotated a) => Env -> C.Context v a -> v -> String$/;"	ft	signature:((Var v, Annotated a) => Env -> C.Context v a -> v -> String)	line:766	language:Haskell
reorder	./parser-typechecker/src/Unison/Lexer.hs	/^reorder :: [T (Token Lexeme)] -> [T (Token Lexeme)]$/;"	ft	signature:([T (Token Lexeme)] -> [T (Token Lexeme)])	line:215	language:Haskell
reorderTree	./parser-typechecker/src/Unison/Lexer.hs	/^reorderTree :: ([T a] -> [T a]) -> T a -> T a$/;"	ft	signature:(([T a] -> [T a]) -> T a -> T a)	line:189	language:Haskell
repeatCount	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^                          repeatCount :: WORD,$/;"	c_a	cons:InputEvent.KeyEvent	line:120	language:Haskell
repeatN	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^repeatN :: Int -> (a -> a) -> a -> a$/;"	ft	signature:(Int -> (a -> a) -> a -> a)	line:370	language:Haskell
repeatableCmdMode	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^repeatableCmdMode :: InputKeyCmd (ArgMode CommandMode) CommandMode$/;"	ft	signature:(InputKeyCmd (ArgMode CommandMode) CommandMode)	line:188	language:Haskell
repeatableCmdToIMode	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^repeatableCmdToIMode :: InputKeyCmd (ArgMode CommandMode) EitherMode$/;"	ft	signature:(InputKeyCmd (ArgMode CommandMode) EitherMode)	line:210	language:Haskell
repeatableCommands	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^repeatableCommands :: InputKeyCmd (ArgMode CommandMode) EitherMode$/;"	ft	signature:(InputKeyCmd (ArgMode CommandMode) EitherMode)	line:179	language:Haskell
repeatedCommands	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^repeatedCommands :: InputKeyCmd CommandMode EitherMode$/;"	ft	signature:(InputKeyCmd CommandMode EitherMode)	line:134	language:Haskell
replace	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^replace :: (Var v, Ord loc) => Element v loc -> [Element v loc] -> Context v loc -> M v loc (Context v loc)$/;"	ft	signature:((Var v, Ord loc) => Element v loc -> [Element v loc] -> Context v loc -> M v loc (Context v loc))	line:395	language:Haskell
replaceChar	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^replaceChar :: Char -> CommandMode -> CommandMode$/;"	ft	signature:(Char -> CommandMode -> CommandMode)	line:300	language:Haskell
replaceCharIM	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^replaceCharIM :: Char -> InsertMode -> InsertMode$/;"	ft	signature:(Char -> InsertMode -> InsertMode)	line:251	language:Haskell
replaceContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^replaceContext :: (Var v, Ord loc) => Element v loc -> [Element v loc] -> M v loc ()$/;"	ft	signature:((Var v, Ord loc) => Element v loc -> [Element v loc] -> M v loc ())	line:472	language:Haskell
replaceDom	./unison-core/src/Unison/Util/Relation.hs	/^replaceDom :: (Ord a, Ord b) => a -> a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => a -> a -> Relation a b -> Relation a b)	line:402	language:Haskell
replaceEdit	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^replaceEdit f s = self$/;"	fi	line:819	language:Haskell
replaceFact	./parser-typechecker/src/Unison/Util/Star3.hs	/^replaceFact :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => fact -> fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3)	line:179	language:Haskell
replaceLoop	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^replaceLoop :: InputCmd CommandMode CommandMode$/;"	ft	signature:(InputCmd CommandMode CommandMode)	line:354	language:Haskell
replaceOnce	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^replaceOnce :: InputCmd CommandMode CommandMode$/;"	ft	signature:(InputCmd CommandMode CommandMode)	line:131	language:Haskell
replacePatch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^replacePatch :: Applicative m => NameSegment -> Patch -> Branch0 m -> Branch0 m$/;"	ft	signature:(Applicative m => NameSegment -> Patch -> Branch0 m -> Branch0 m)	line:683	language:Haskell
replaceRan	./unison-core/src/Unison/Util/Relation.hs	/^replaceRan :: (Ord a, Ord b) => b -> b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => b -> b -> Relation a b -> Relation a b)	line:406	language:Haskell
replaceTerm	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^replaceTerm :: InputPattern$/;"	ft	signature:(InputPattern)	line:857	language:Haskell
replaceType	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^replaceType :: InputPattern$/;"	ft	signature:(InputPattern)	line:854	language:Haskell
replacement	./parser-typechecker/src/Unison/Typechecker.hs	/^                 , replacement :: Either v Referent }$/;"	c_a	cons:NamedReference.NamedReference	line:64	language:Haskell
replacement	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^data Completion = Completion {replacement  :: String, -- ^ Text to insert in line.$/;"	c_a	cons:Completion.Completion	line:35	language:Haskell
repoPath	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^repoPath :: P RemoteNamespace$/;"	ft	signature:(P RemoteNamespace)	line:37	language:Haskell
reportBug	./unison-core/src/Unison/Prelude.hs	/^reportBug :: String -> String -> String$/;"	ft	signature:(String -> String -> String)	line:48	language:Haskell
reposition	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    reposition _ s = refitLine s$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	line:39	language:Haskell
reposition	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    reposition layout lc = runActionT $ repositionT layout lc$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:355	language:Haskell
reposition	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    reposition _ _ = return ()$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:356	language:Haskell
reposition	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    reposition :: Layout -> LineChars -> m ()$/;"	ft	signature:(Layout -> LineChars -> m ())	class:Term	line:21	language:Haskell
repositionT	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^repositionT :: Layout -> LineChars -> ActionM ()$/;"	ft	signature:(Layout -> LineChars -> ActionM ())	line:343	language:Haskell
requalify	./unison-core/src/Unison/HashQualified'.hs	/^requalify :: HashQualified -> Referent -> HashQualified$/;"	ft	signature:(HashQualified -> Referent -> HashQualified)	line:104	language:Haskell
requalify	./unison-core/src/Unison/HashQualified.hs	/^requalify :: HashQualified -> Referent -> HashQualified$/;"	ft	signature:(HashQualified -> Referent -> HashQualified)	line:156	language:Haskell
request	./unison-core/src/Unison/Term.hs	/^request :: Ord v => a -> Reference -> Int -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Reference -> Int -> Term2 vt at ap v a)	line:520	language:Haskell
requestVar	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^                        requestVar :: MVar (Maybe Request),$/;"	c_a	cons:InputState.HD	line:54	language:Haskell
requested	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , requested               :: [C.Type v loc]$/;"	c_a	cons:TypeError.AbilityCheckFailure	line:60	language:Haskell
reraiseIO	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^reraiseIO :: IO a -> UIO a$/;"	ft	signature:(IO a -> UIO a)	line:273	language:Haskell
rerun	./yaks/easytest/src/EasyTest.hs	/^rerun :: Int -> Test a -> IO ()$/;"	ft	signature:(Int -> Test a -> IO ())	line:104	language:Haskell
rerunOnly	./yaks/easytest/src/EasyTest.hs	/^rerunOnly :: Int -> String -> Test a -> IO ()$/;"	ft	signature:(Int -> String -> Test a -> IO ())	line:96	language:Haskell
reserveAll	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^reserveAll :: (Var v, Foldable t) => t v -> M v loc ()$/;"	ft	signature:((Var v, Foldable t) => t v -> M v loc ())	line:501	language:Haskell
reserved	./parser-typechecker/src/Unison/Parser.hs	/^reserved :: Ord v => String -> P v (L.Token String)$/;"	ft	signature:(Ord v => String -> P v (L.Token String))	line:368	language:Haskell
reservedOperators	./parser-typechecker/src/Unison/Lexer.hs	/^reservedOperators :: Set String$/;"	ft	signature:(Set String)	line:751	language:Haskell
reset	./unison-core/src/Unison/Var.hs	/^reset :: Var v => v -> v$/;"	ft	signature:(Var v => v -> v)	line:116	language:Haskell
resetContextAfter	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^resetContextAfter :: a -> M v loc a -> M v loc a$/;"	ft	signature:(a -> M v loc a -> M v loc a)	line:1149	language:Haskell
resetRoot	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^resetRoot :: InputPattern$/;"	ft	signature:(InputPattern)	line:598	language:Haskell
resolutionFailures	./parser-typechecker/src/Unison/FileParser.hs	/^resolutionFailures :: Ord v => [Names.ResolutionFailure v Ann] -> P v x$/;"	ft	signature:(Ord v => [Names.ResolutionFailure v Ann] -> P v x)	line:36	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve :: l -> r -> o$/;"	ft	signature:(l -> r -> o)	class:Resolve	line:379	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve (Path l) (Path r) = Path (l <> r)$/;"	fi	instance:Resolve Path Path Path	line:382	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve (Relative (Path l)) (Relative (Path r)) = Relative (Path (l <> r))$/;"	fi	instance:Resolve Relative Relative Relative	line:385	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve (Absolute l) (Relative r) = Absolute (resolve l r)$/;"	fi	instance:Resolve Absolute Relative Absolute	line:388	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve _ a@(Path' Left{}) = a$/;"	fi	instance:Resolve Path' Path' Path'	line:391	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve l r = resolve l (unsplit' r)$/;"	fi	instance:Resolve Path' Split' Path'	line:396	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve l (r, ns) = (resolve l r, ns)$/;"	fi	instance:Resolve Path' Split' Split'	line:399	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve l (r, hq) = (resolve l (Relative r), hq)$/;"	fi	instance:Resolve Absolute HQSplit HQSplitAbsolute	line:402	language:Haskell
resolve	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  resolve _ (Path' (Left a)) = a$/;"	fi	instance:Resolve Absolute Path' Absolute	line:405	language:Haskell
resolve	./unison-core/src/Unison/Term.hs	/^resolve :: Ord v => at -> ab -> String -> Term2 vt ab ap v at$/;"	ft	signature:(Ord v => at -> ab -> String -> Term2 vt ab ap v at)	line:514	language:Haskell
resolveHashQualified	./parser-typechecker/src/Unison/TermParser.hs	/^resolveHashQualified :: Var v => L.Token HQ.HashQualified -> TermP v$/;"	ft	signature:(Var v => L.Token HQ.HashQualified -> TermP v)	line:292	language:Haskell
resolveNames	./parser-typechecker/src/Unison/FileParsers.hs	/^resolveNames typeLookupf preexistingNames uf = do$/;"	fi	line:87	language:Haskell
resolveShortBranchHash	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^resolveShortBranchHash ::$/;"	ft	signature:(ShortBranchHash -> Action' m v (Either (Output v) (Branch m)))	line:1640	language:Haskell
resolvedLoc	./parser-typechecker/src/Unison/Typechecker.hs	/^             , resolvedLoc  :: loc$/;"	c_a	cons:Resolution.Resolution	line:170	language:Haskell
resolvedName	./parser-typechecker/src/Unison/Typechecker.hs	/^  Resolution { resolvedName :: Text$/;"	c_a	cons:Resolution.Resolution	line:168	language:Haskell
resolvedTermConflicts	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  resolvedTermConflicts :: [UpdateTermDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:53	language:Haskell
resolvedTypeConflicts	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  resolvedTypeConflicts :: [UpdateTypeDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:52	language:Haskell
resourceBusyId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^resourceBusyId = mkErrorType "io.ErrorType.ResourceBusy"$/;"	fi	line:113	language:Haskell
resourceExhaustedId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^resourceExhaustedId = mkErrorType "io.ErrorType.ResourceExhausted"$/;"	fi	line:114	language:Haskell
respond	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^respond :: Output v -> Action m i v ()$/;"	ft	signature:(Output v -> Action m i v ())	line:1883	language:Haskell
respondNumbered	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^respondNumbered :: NumberedOutput v -> Action m i v ()$/;"	ft	signature:(NumberedOutput v -> Action m i v ())	line:1886	language:Haskell
restore	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    restore :: InsertMode -> s$/;"	ft	signature:(InsertMode -> s)	class:Save	line:175	language:Haskell
restore	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    restore = id$/;"	fi	instance:Save InsertMode	line:200	language:Haskell
restore	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    restore = enterCommandModeRight$/;"	fi	instance:Save CommandMode	line:280	language:Haskell
restore	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    restore = startArg 0 . restore$/;"	fi	instance:Save s => Save (ArgMode s)	line:356	language:Haskell
restrictDom	./unison-core/src/Unison/Util/Relation.hs	/^(<|), restrictDom :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Set a -> Relation a b -> Relation a b)	line:347	language:Haskell
restrictDom	./unison-core/src/Unison/Util/Relation.hs	/^restrictDom = (<|)$/;"	fi	line:348	language:Haskell
restrictRan	./unison-core/src/Unison/Util/Relation.hs	/^(|>), restrictRan :: (Ord a, Ord b) => Relation a b -> Set b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Set b -> Relation a b)	line:357	language:Haskell
restrictRan	./unison-core/src/Unison/Util/Relation.hs	/^restrictRan = (|>)$/;"	fi	line:358	language:Haskell
restrictReferences	./unison-core/src/Unison/Names2.hs	/^restrictReferences :: Ord n => Set Reference -> Names' n -> Names' n$/;"	ft	signature:(Ord n => Set Reference -> Names' n -> Names' n)	line:99	language:Haskell
result	./parser-typechecker/src/Unison/Result.hs	/^result :: Result notes a -> Maybe a$/;"	ft	signature:(Result notes a -> Maybe a)	line:47	language:Haskell
result	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^result, result2 :: M (Causal.FoldHistoryResult (Set Int64))$/;"	ft	signature:(M (Causal.FoldHistoryResult (Set Int64)))	line:241	language:Haskell
result2	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^result, result2 :: M (Causal.FoldHistoryResult (Set Int64))$/;"	ft	signature:(M (Causal.FoldHistoryResult (Set Int64)))	line:241	language:Haskell
resultTest	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^resultTest rt uf filepath = do$/;"	fi	line:136	language:Haskell
results	./yaks/easytest/src/EasyTest.hs	/^      , results :: TBQueue (Maybe (TMVar (String, Status)))$/;"	c_a	cons:Env.Env	line:39	language:Haskell
retract0	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^retract0 :: (Var v, Ord loc) => Element v loc -> Context v loc -> Maybe (Context v loc, [Element v loc])$/;"	ft	signature:((Var v, Ord loc) => Element v loc -> Context v loc -> Maybe (Context v loc, [Element v loc]))	line:350	language:Haskell
return	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  return a = MT (\\menv -> pure (a, env menv))$/;"	fi	instance:Monad f => Monad (MT v loc f)	line:1795	language:Haskell
return	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  return a = SubseqExtractor' $ \\_ -> [Pure a]$/;"	fi	instance:Monad (SubseqExtractor' n)	line:320	language:Haskell
return	./parser-typechecker/src/Unison/Util/Free.hs	/^  return = Pure$/;"	fi	instance:Monad (Free f)	line:59	language:Haskell
return	./yaks/easytest/src/EasyTest.hs	/^  return a = Test $ do$/;"	fi	instance:Monad Test	line:378	language:Haskell
return	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^    return = pure$/;"	fi	instance:Monad m => Monad (CmdM m)	line:73	language:Haskell
return	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^    return = pure$/;"	fi	instance:Monad m => Monad (StateT s m)	line:82	language:Haskell
returnOnEOF	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^returnOnEOF :: MonadException m => a -> m a -> m a$/;"	ft	signature:(MonadException m => a -> m a -> m a)	line:196	language:Haskell
reverseHist	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^reverseHist :: MonadState HistLog m => m b -> m b$/;"	ft	signature:(MonadState HistLog m => m b -> m b)	line:68	language:Haskell
reverseTest	./yaks/easytest/tests/Suite.hs	/^reverseTest :: Test ()$/;"	ft	signature:(Test ())	line:15	language:Haskell
rewriteDown	./unison-core/src/Unison/ABT.hs	/^rewriteDown :: (Traversable f, Ord v)$/;"	ft	signature:((Traversable f, Ord v) => (Term f v a -> Term f v a) -> Term f v a -> Term f v a)	line:446	language:Haskell
right	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^left,right,up :: Int -> TermAction$/;"	ft	signature:(Int -> TermAction)	line:206	language:Haskell
right	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^right = flip rightA$/;"	fi	line:208	language:Haskell
rightPad	./parser-typechecker/src/Unison/Util/Pretty.hs	/^leftPad, rightPad :: IsString s => Int -> Pretty s -> Pretty s$/;"	ft	signature:(IsString s => Int -> Pretty s -> Pretty s)	line:432	language:Haskell
rightPad	./parser-typechecker/src/Unison/Util/Pretty.hs	/^rightPad n p =$/;"	fi	line:436	language:Haskell
ringBell	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^    ringBell True = printText "\\a"$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (DumbTerm m)	line:45	language:Haskell
ringBell	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^    ringBell True = runActionT $ output bellAudible$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:362	language:Haskell
ringBell	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    ringBell True = liftIO messageBeep$/;"	fi	instance:(MonadException m, MonadReader Layout m) => Term (Draw m)	line:367	language:Haskell
ringBell	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    ringBell :: Bool -> m ()$/;"	ft	signature:(Bool -> m ())	class:Term	line:26	language:Haskell
rmkx	./yaks/haskeline/tests/Unit.hs	/^smkx,rmkx :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:261	language:Haskell
rmkx	./yaks/haskeline/tests/Unit.hs	/^rmkx = utf8 "\\ESC[?1l\\ESC>"$/;"	fi	line:263	language:Haskell
rng	./yaks/easytest/src/EasyTest.hs	/^  Env { rng :: TVar Random.StdGen$/;"	c_a	cons:Env.Env	line:37	language:Haskell
root	./parser-typechecker/src/Unison/Parser.hs	/^root :: Ord v => P v a -> P v a$/;"	ft	signature:(Ord v => P v a -> P v a)	line:229	language:Haskell
root	./parser-typechecker/src/Unison/Path.hs	/^  root :: p$/;"	ft	signature:(p)	class:Path	line:18	language:Haskell
root	./parser-typechecker/src/Unison/Path.hs	/^  root = Nothing$/;"	fi	instance:Eq a => Path (Maybe a)	line:36	language:Haskell
root	./parser-typechecker/src/Unison/Path.hs	/^  root = []$/;"	fi	instance:Eq a => Path [a]	line:43	language:Haskell
root	./parser-typechecker/src/Unison/Path.hs	/^  root = ()$/;"	fi	instance:Path ()	line:51	language:Haskell
rootBranchUpdates	./parser-typechecker/src/Unison/Codebase.hs	/^           , rootBranchUpdates  :: m (m (), m (Set Branch.Hash))$/;"	c_a	cons:Codebase.Codebase	line:57	language:Haskell
rootFile	./parser-typechecker/src/Unison/Parser.hs	/^rootFile :: Ord v => P v a -> P v a$/;"	ft	signature:(Ord v => P v a -> P v a)	line:233	language:Haskell
rotate	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^rotate :: Stack a -> Stack a$/;"	ft	signature:(Stack a -> Stack a)	line:22	language:Haskell
rotatePaste	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^rotatePaste :: InputCmd InsertMode InsertMode$/;"	ft	signature:(InputCmd InsertMode InsertMode)	line:80	language:Haskell
rowLengths	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                    rowLengths :: !(Map.IntMap Int),$/;"	c_a	cons:TermRows.TermRows	line:85	language:Haskell
run	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^run :: FilePath -> FilePath -> [Stanza] -> Codebase IO Symbol Ann -> IO Text$/;"	ft	signature:(FilePath -> FilePath -> [Stanza] -> Codebase IO Symbol Ann -> IO Text)	line:106	language:Haskell
run	./parser-typechecker/src/Unison/Parser.hs	/^run :: Ord v => P v a -> String -> ParsingEnv -> Either (Err v) a$/;"	ft	signature:(Ord v => P v a -> String -> ParsingEnv -> Either (Err v) a)	line:245	language:Haskell
run	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^run :: (R.Reference -> ConstructorId -> [Value] -> IO Result)$/;"	ft	signature:((R.Reference -> ConstructorId -> [Value] -> IO Result) -> CompilationEnv -> IR -> IO Result)	line:412	language:Haskell
run	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^run ambient datas effects m =$/;"	fi	line:1697	language:Haskell
run	./yaks/easytest/src/EasyTest.hs	/^run :: Test a -> IO ()$/;"	ft	signature:(Test a -> IO ())	line:101	language:Haskell
run'	./parser-typechecker/src/Unison/Parser.hs	/^run' :: Ord v => P v a -> String -> String -> ParsingEnv -> Either (Err v) a$/;"	ft	signature:(Ord v => P v a -> String -> String -> ParsingEnv -> Either (Err v) a)	line:236	language:Haskell
run'	./yaks/easytest/src/EasyTest.hs	/^run' :: Int -> (String -> IO ()) -> String -> Test a -> IO ()$/;"	ft	signature:(Int -> (String -> IO ()) -> String -> Test a -> IO ())	line:107	language:Haskell
runActionT	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^runActionT :: MonadIO m => ActionT (Draw m) a -> Draw m a$/;"	ft	signature:(MonadIO m => ActionT (Draw m) a -> Draw m a)	line:189	language:Haskell
runCommandInPty	./yaks/haskeline/tests/Pty.hs	/^runCommandInPty :: String -> [String] -> Maybe [(String,String)]$/;"	ft	signature:(String -> [String] -> Maybe [(String, String)] -> [B.ByteString] -> IO [B.ByteString])	line:29	language:Haskell
runCommandLoop	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^runCommandLoop :: (CommandMonad m, MonadState Layout m, LineState s)$/;"	ft	signature:((CommandMonad m, MonadState Layout m, LineState s) => TermOps -> String -> KeyCommand m s a -> s -> m a)	line:12	language:Haskell
runCommandLoop'	./yaks/haskeline/System/Console/Haskeline/RunCommand.hs	/^runCommandLoop' :: forall m n s a . (Term n, CommandMonad n,$/;"	ft	signature:(forall m n s a . (Term n, CommandMonad n, MonadState Layout m, LineState s) => (forall b . m b -> n b) -> TermOps -> Prefix -> s -> KeyCommand m s a -> n Event -> n a)	line:22	language:Haskell
runCompletion	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^    runCompletion lcs = do$/;"	fi	instance:MonadException m => CommandMonad (InputCmdT m)	line:86	language:Haskell
runCompletion	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    runCompletion :: (String,String) -> m (String,[Completion])$/;"	ft	signature:((String, String) -> m (String, [Completion]))	class:CommandMonad	line:105	language:Haskell
runCompletion	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    runCompletion = lift . runCompletion$/;"	fi	instance:(MonadTrans t, CommandMonad m, MonadReader Prefs (t m), MonadException (t m), MonadReader Layout (t m)) => CommandMonad (t m)	line:111	language:Haskell
runDS	./parser-typechecker/src/Unison/Runtime/IR.hs	/^runDS :: DS (Term Symbol) -> IO (Term Symbol)$/;"	ft	signature:(DS (Term Symbol) -> IO (Term Symbol))	line:588	language:Haskell
runDraw	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^runDraw :: Handles -> MaybeT IO RunTerm$/;"	ft	signature:(Handles -> MaybeT IO RunTerm)	line:43	language:Haskell
runDraw	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^newtype Draw m a = Draw {runDraw :: ReaderT Handles m a}$/;"	c_a	cons:Draw.Draw	line:262	language:Haskell
runDumbTerm	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^runDumbTerm :: Handles -> MaybeT IO RunTerm$/;"	ft	signature:(Handles -> MaybeT IO RunTerm)	line:35	language:Haskell
runHaskeline	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^runHaskeline :: Settings IO -> MVar (Maybe Request) -> MVar () -> IO ()$/;"	ft	signature:(Settings IO -> MVar (Maybe Request) -> MVar () -> IO ())	line:67	language:Haskell
runHistoryFromFile	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^runHistoryFromFile :: MonadException m => Maybe FilePath -> Maybe Int$/;"	ft	signature:(MonadException m => Maybe FilePath -> Maybe Int -> ReaderT (IORef History) m a -> m a)	line:30	language:Haskell
runInTTY	./yaks/haskeline/tests/RunTTY.hs	/^            , runInTTY :: Bool$/;"	c_a	cons:Invocation.Invocation	line:29	language:Haskell
runInputCmdT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^runInputCmdT :: MonadIO m => TermOps -> InputCmdT m a -> InputT m a$/;"	ft	signature:(MonadIO m => TermOps -> InputCmdT m a -> InputT m a)	line:79	language:Haskell
runInputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^runInputT :: MonadException m => Settings m -> InputT m a -> m a$/;"	ft	signature:(MonadException m => Settings m -> InputT m a -> m a)	line:104	language:Haskell
runInputTBehavior	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^runInputTBehavior :: MonadException m => Behavior -> Settings m -> InputT m a -> m a$/;"	ft	signature:(MonadException m => Behavior -> Settings m -> InputT m a -> m a)	line:136	language:Haskell
runInputTBehaviorWithPrefs	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^runInputTBehaviorWithPrefs :: MonadException m$/;"	ft	signature:(MonadException m => Behavior -> Prefs -> Settings m -> InputT m a -> m a)	line:144	language:Haskell
runInputTWithPrefs	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^runInputTWithPrefs :: MonadException m => Prefs -> Settings m -> InputT m a -> m a$/;"	ft	signature:(MonadException m => Prefs -> Settings m -> InputT m a -> m a)	line:92	language:Haskell
runInvocation	./yaks/haskeline/tests/RunTTY.hs	/^runInvocation :: Invocation $/;"	ft	signature:(Invocation -> [B.ByteString] -> IO [B.ByteString])	line:47	language:Haskell
runKillRing	./yaks/haskeline/System/Console/Haskeline/Command/KillRing.hs	/^runKillRing :: MonadIO m => ReaderT (IORef KillRing) m a -> m a$/;"	ft	signature:(MonadIO m => ReaderT (IORef KillRing) m a -> m a)	line:32	language:Haskell
runM	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  runM :: MEnv v loc -> f (a, Env v loc)$/;"	c_a	cons:MT.MT	line:176	language:Haskell
runOnly	./yaks/easytest/src/EasyTest.hs	/^runOnly :: String -> Test a -> IO ()$/;"	ft	signature:(String -> Test a -> IO ())	line:89	language:Haskell
runPosixT	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^runPosixT :: Handles -> PosixT m a -> m a$/;"	ft	signature:(Handles -> PosixT m a -> m a)	line:306	language:Haskell
runReaderT'	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^runReaderT' :: r -> ReaderT r m a -> m a$/;"	ft	signature:(r -> ReaderT r m a -> m a)	line:68	language:Haskell
runResultT	./parser-typechecker/src/Unison/Result.hs	/^runResultT :: ResultT notes f a -> f (Maybe a, notes)$/;"	ft	signature:(ResultT notes f a -> f (Maybe a, notes))	line:62	language:Haskell
runStateT	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^runStateT :: Monad m => StateT s m a -> s -> m (a, s)$/;"	ft	signature:(Monad m => StateT s m a -> s -> m (a, s))	line:98	language:Haskell
runSubseq	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  SubseqExtractor' { runSubseq :: n -> [Ranged a] }$/;"	c_a	cons:SubseqExtractor'.SubseqExtractor'	line:62	language:Haskell
runTerminfoDraw	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^runTerminfoDraw :: Handles -> MaybeT IO RunTerm$/;"	ft	signature:(Handles -> MaybeT IO RunTerm)	line:127	language:Haskell
runTranscripts	./parser-typechecker/unison/Main.hs	/^runTranscripts :: Bool -> Bool -> Maybe FilePath -> [String] -> IO ()$/;"	ft	signature:(Bool -> Bool -> Maybe FilePath -> [String] -> IO ())	line:205	language:Haskell
runTranscripts'	./parser-typechecker/unison/Main.hs	/^runTranscripts' :: Maybe FilePath -> FilePath -> [String] -> IO Bool$/;"	ft	signature:(Maybe FilePath -> FilePath -> [String] -> IO Bool)	line:173	language:Haskell
runUndoT	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^runUndoT :: Monad m => UndoT m a -> m a$/;"	ft	signature:(Monad m => UndoT m a -> m a)	line:13	language:Haskell
runWrap	./yaks/easytest/src/EasyTest.hs	/^runWrap :: Env -> ReaderT Env IO (Maybe a) -> IO (Maybe a)$/;"	ft	signature:(Env -> ReaderT Env IO (Maybe a) -> IO (Maybe a))	line:306	language:Haskell
runtime	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^runtime :: Runtime Symbol$/;"	ft	signature:(Runtime Symbol)	line:461	language:Haskell
s	./unison-core/src/Unison/Util/Relation.hs	/^s <| r = fromList$/;"	fi	line:349	language:Haskell
s	./unison-core/src/Unison/Util/Relation.hs	/^s <|| r = fromList [ (a,b) | (a,b) <- toList r, not (a `S.member` s)]$/;"	fi	line:376	language:Haskell
s@	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  s@(Success _ a)       >>= f = s *> f a$/;"	fi	instance:Monad (Result v loc)	line:144	language:Haskell
safeChars	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^safeChars :: Set.Set Char$/;"	ft	signature:(Set.Set Char)	line:37	language:Haskell
safeHead	./unison-core/src/Unison/Util/List.hs	/^safeHead :: Foldable f => f a -> Maybe a$/;"	ft	signature:(Foldable f => f a -> Maybe a)	line:36	language:Haskell
safeReadUtf8	./unison-core/src/Unison/Prelude.hs	/^safeReadUtf8 :: FilePath -> IO (Either IOException Text)$/;"	ft	signature:(FilePath -> IO (Either IOException Text))	line:39	language:Haskell
safeReadUtf8StdIn	./unison-core/src/Unison/Prelude.hs	/^safeReadUtf8StdIn :: IO (Either IOException Text) $/;"	ft	signature:(IO (Either IOException Text))	line:42	language:Haskell
save	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    save :: s -> InsertMode$/;"	ft	signature:(s -> InsertMode)	class:Save	line:174	language:Haskell
save	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    save = id$/;"	fi	instance:Save InsertMode	line:199	language:Haskell
save	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    save = insertFromCommandMode$/;"	fi	instance:Save CommandMode	line:279	language:Haskell
save	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    save = save . argState$/;"	fi	instance:Save s => Save (ArgMode s)	line:355	language:Haskell
saveForUndo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^saveForUndo :: (Save s, MonadState Undo m)$/;"	ft	signature:((Save s, MonadState Undo m) => Â Command m s s)	line:41	language:Haskell
saveKeys	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^saveKeys :: TChan Event -> [Key] -> IO ()$/;"	ft	signature:(TChan Event -> [Key] -> IO ())	line:146	language:Haskell
saveSM	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^saveSM :: SearchMode -> [Grapheme]$/;"	ft	signature:(SearchMode -> [Grapheme])	line:100	language:Haskell
saveToUndo	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^saveToUndo :: Save s => s -> Undo -> Undo$/;"	ft	signature:(Save s => s -> Undo -> Undo)	line:20	language:Haskell
saveUnusedKeys	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    , saveUnusedKeys :: [Key] -> IO ()$/;"	c_a	cons:TermOps.TermOps	line:46	language:Haskell
sbh	./parser-typechecker/tests/Unison/Test/UriParser.hs	/^sbh :: Text -> Maybe ShortBranchHash$/;"	ft	signature:(Text -> Maybe ShortBranchHash)	line:83	language:Haskell
scanBraces	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^scanBraces :: Char -> Char -> [Grapheme] -> Maybe ([Grapheme],[Grapheme])$/;"	ft	signature:(Char -> Char -> [Grapheme] -> Maybe ([Grapheme], [Grapheme]))	line:335	language:Haskell
scope	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^scope :: PathElement v loc -> M v loc a -> M v loc a$/;"	ft	signature:(PathElement v loc -> M v loc a -> M v loc a)	line:312	language:Haskell
scope	./parser-typechecker/src/Unison/Util/Logger.hs	/^scope :: String -> Logger -> Logger$/;"	ft	signature:(String -> Logger -> Logger)	line:69	language:Haskell
scope	./yaks/easytest/src/EasyTest.hs	/^scope :: String -> Test a -> Test a$/;"	ft	signature:(String -> Test a -> Test a)	line:174	language:Haskell
scope'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^scope' :: PathElement v loc -> ErrorNote v loc -> ErrorNote v loc$/;"	ft	signature:(PathElement v loc -> ErrorNote v loc -> ErrorNote v loc)	line:308	language:Haskell
scope'	./parser-typechecker/src/Unison/Util/Logger.hs	/^scope' :: [String] -> Logger -> Logger$/;"	ft	signature:([String] -> Logger -> Logger)	line:75	language:Haskell
searchBackwards	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^searchBackwards :: Bool -> SearchMode -> HistLog -> Maybe (SearchMode, HistLog)$/;"	ft	signature:(Bool -> SearchMode -> HistLog -> Maybe (SearchMode, HistLog))	line:132	language:Haskell
searchBranchExact	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^searchBranchExact :: Int -> Names -> [HQ.HashQualified] -> [[SearchResult]]$/;"	ft	signature:(Int -> Names -> [HQ.HashQualified] -> [[SearchResult]])	line:1857	language:Haskell
searchBranchScored	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^searchBranchScored :: forall score. (Ord score)$/;"	ft	signature:(forall score. (Ord score) => Names0 -> (Name -> Name -> Maybe score) -> [HQ.HashQualified] -> [SearchResult])	line:1797	language:Haskell
searchChar	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^                    searchChar :: Char$/;"	c_a	cons:SearchEntry.SearchEntry	line:402	language:Haskell
searchForPrefix	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^searchForPrefix :: MonadState HistLog m => Direction$/;"	ft	signature:(MonadState HistLog m => Direction -> Command m InsertMode InsertMode)	line:176	language:Haskell
searchHistories	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^searchHistories :: Direction -> [Grapheme] -> [([Grapheme],HistLog)]$/;"	ft	signature:(Direction -> [Grapheme] -> [([Grapheme], HistLog)] -> Maybe (SearchMode, HistLog))	line:110	language:Haskell
searchHistory	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^searchHistory :: MonadState HistLog m => KeyCommand m InsertMode InsertMode$/;"	ft	signature:(MonadState HistLog m => KeyCommand m InsertMode InsertMode)	line:149	language:Haskell
searchResultToHQString	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^searchResultToHQString :: SearchResult -> String$/;"	ft	signature:(SearchResult -> String)	line:1759	language:Haskell
searchResultsFor	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^searchResultsFor :: Names0 -> [Referent] -> [Reference] -> [SearchResult]$/;"	ft	signature:(Names0 -> [Referent] -> [Reference] -> [SearchResult])	line:1786	language:Haskell
searchTerm	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^data SearchMode = SearchMode {searchTerm :: [Grapheme],$/;"	c_a	cons:SearchMode.SearchMode	line:78	language:Haskell
searchText	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^searchText :: SearchEntry -> [Grapheme]$/;"	ft	signature:(SearchEntry -> [Grapheme])	line:405	language:Haskell
seekModeReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^seekModeReference = typeNamed "io.SeekMode"$/;"	fi	line:77	language:Haskell
segments	./unison-core/src/Unison/Codebase/NameSegment.hs	/^segments :: Name.Name -> [NameSegment]$/;"	ft	signature:(Name.Name -> [NameSegment])	line:36	language:Haskell
select1D3	./parser-typechecker/src/Unison/Util/Star3.hs	/^select1D3 = selectD3 . Set.singleton$/;"	fi	line:98	language:Haskell
selectD3	./parser-typechecker/src/Unison/Util/Star3.hs	/^selectD3 d3s s = Star3 fact' d1' d2' d3' where$/;"	fi	line:105	language:Haskell
selectD3	./unison-core/src/Unison/Util/Relation4.hs	/^selectD3 :: (Ord a, Ord b, Ord c, Ord d)$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => c -> Relation4 a b c d -> Relation4 a b c d)	line:50	language:Haskell
selectD34	./unison-core/src/Unison/Util/Relation4.hs	/^selectD34 :: (Ord a, Ord b, Ord c, Ord d)$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => c -> d -> Relation4 a b c d -> Relation4 a b c d)	line:55	language:Haskell
selectFact	./parser-typechecker/src/Unison/Util/Star3.hs	/^selectFact fs s = Star3 fact' d1' d2' d3' where$/;"	fi	line:89	language:Haskell
semi	./parser-typechecker/src/Unison/Parser.hs	/^semi :: Ord v => P v (L.Token ())$/;"	ft	signature:(Ord v => P v (L.Token ()))	line:275	language:Haskell
sep	./parser-typechecker/src/Unison/Util/Pretty.hs	/^sep :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s)	line:346	language:Haskell
sepBy	./parser-typechecker/src/Unison/Parser.hs	/^sepBy :: Ord v => P v a -> P v b -> P v [b]$/;"	ft	signature:(Ord v => P v a -> P v b -> P v [b])	line:384	language:Haskell
sepBy1	./parser-typechecker/src/Unison/Parser.hs	/^sepBy1 :: Ord v => P v a -> P v b -> P v [b]$/;"	ft	signature:(Ord v => P v a -> P v b -> P v [b])	line:387	language:Haskell
sepNonEmpty	./parser-typechecker/src/Unison/Util/Pretty.hs	/^sepNonEmpty :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s)	line:349	language:Haskell
sepSpaced	./parser-typechecker/src/Unison/Util/Pretty.hs	/^sepSpaced :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s)	line:343	language:Haskell
seq	./parser-typechecker/src/Unison/Parser.hs	/^seq :: Ord v => (Ann -> [a] -> a) -> P v a -> P v a$/;"	ft	signature:(Ord v => (Ann -> [a] -> a) -> P v a -> P v a)	line:410	language:Haskell
seq	./parser-typechecker/src/Unison/TermParser.hs	/^seq :: Var v => TermP v -> TermP v$/;"	ft	signature:(Var v => TermP v -> TermP v)	line:280	language:Haskell
seq	./unison-core/src/Unison/Term.hs	/^seq :: Ord v => a -> [Term2 vt at ap v a] -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> [Term2 vt at ap v a] -> Term2 vt at ap v a)	line:542	language:Haskell
seq'	./unison-core/src/Unison/Term.hs	/^seq' :: Ord v => a -> Seq (Term2 vt at ap v a) -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Seq (Term2 vt at ap v a) -> Term2 vt at ap v a)	line:545	language:Haskell
seqOp	./parser-typechecker/src/Unison/TermParser.hs	/^seqOp :: Ord v => P v Pattern.SeqOp$/;"	ft	signature:(Ord v => P v Pattern.SeqOp)	line:624	language:Haskell
sequenceTyp	./parser-typechecker/src/Unison/TypeParser.hs	/^sequenceTyp :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:84	language:Haskell
serializationTest	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^serializationTest :: TFile -> Test ()$/;"	ft	signature:(TFile -> Test ())	line:161	language:Haskell
serializeBoolean	./parser-typechecker/src/Unison/Codecs.hs	/^serializeBoolean :: MonadPut m => Bool -> m ()$/;"	ft	signature:(MonadPut m => Bool -> m ())	line:252	language:Haskell
serializeCase1	./parser-typechecker/src/Unison/Codecs.hs	/^serializeCase1 :: (Var v, MonadPut m, MonadState Pos m)$/;"	ft	signature:((Var v, MonadPut m, MonadState Pos m) => MatchCase p (Term v a) -> m (MatchCase p Pos))	line:262	language:Haskell
serializeCase2	./parser-typechecker/src/Unison/Codecs.hs	/^serializeCase2 :: MonadPut m => MatchCase loc Pos -> m ()$/;"	ft	signature:(MonadPut m => MatchCase loc Pos -> m ())	line:256	language:Haskell
serializeConstructorArities	./parser-typechecker/src/Unison/Codecs.hs	/^serializeConstructorArities :: MonadPut m => Reference -> [Int] -> m ()$/;"	ft	signature:(MonadPut m => Reference -> [Int] -> m ())	line:321	language:Haskell
serializeConstructorType	./parser-typechecker/src/Unison/Codecs.hs	/^serializeConstructorType :: MonadPut m => ConstructorType.ConstructorType -> m ()$/;"	ft	signature:(MonadPut m => ConstructorType.ConstructorType -> m ())	line:302	language:Haskell
serializeEdits	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^serializeEdits root h medits = do$/;"	fi	line:369	language:Haskell
serializeFile	./parser-typechecker/src/Unison/Codecs.hs	/^serializeFile uf@(UnisonFile dataDecls effectDecls _ _) tm = do$/;"	fi	line:329	language:Haskell
serializeFloat	./parser-typechecker/src/Unison/Codecs.hs	/^serializeFloat :: MonadPut m => Double -> m ()$/;"	ft	signature:(MonadPut m => Double -> m ())	line:237	language:Haskell
serializeFoldable	./parser-typechecker/src/Unison/Codecs.hs	/^serializeFoldable :: (MonadPut m, Foldable f) => (a -> m ()) -> f a -> m ()$/;"	ft	signature:((MonadPut m, Foldable f) => (a -> m ()) -> f a -> m ())	line:288	language:Haskell
serializeInt	./parser-typechecker/src/Unison/Codecs.hs	/^serializeInt :: MonadPut m => Int64 -> m ()$/;"	ft	signature:(MonadPut m => Int64 -> m ())	line:247	language:Haskell
serializeMaybe	./parser-typechecker/src/Unison/Codecs.hs	/^serializeMaybe :: (MonadPut m) => (a -> m ()) -> Maybe a -> m ()$/;"	ft	signature:((MonadPut m) => (a -> m ()) -> Maybe a -> m ())	line:277	language:Haskell
serializeNat	./parser-typechecker/src/Unison/Codecs.hs	/^serializeNat :: MonadPut m => Word64 -> m ()$/;"	ft	signature:(MonadPut m => Word64 -> m ())	line:242	language:Haskell
serializePattern	./parser-typechecker/src/Unison/Codecs.hs	/^serializePattern :: MonadPut m => Pattern a -> m ()$/;"	ft	signature:(MonadPut m => Pattern a -> m ())	line:207	language:Haskell
serializeRawBranch	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^serializeRawBranch root (RawHash h) = liftIO$/;"	fi	line:364	language:Haskell
serializeReference	./parser-typechecker/src/Unison/Codecs.hs	/^serializeReference :: MonadPut m => Reference -> m ()$/;"	ft	signature:(MonadPut m => Reference -> m ())	line:307	language:Haskell
serializeReferent	./parser-typechecker/src/Unison/Codecs.hs	/^serializeReferent :: MonadPut m => Referent.Referent -> m ()$/;"	ft	signature:(MonadPut m => Referent.Referent -> m ())	line:293	language:Haskell
serializeTerm	./parser-typechecker/src/Unison/Codecs.hs	/^serializeTerm :: (MonadPut m, MonadState Pos m, Var v)$/;"	ft	signature:((MonadPut m, MonadState Pos m, Var v) => Term v a -> m Pos)	line:37	language:Haskell
setAt	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^setAt :: Applicative m => Path -> Branch m -> Branch m -> Branch m$/;"	ft	signature:(Applicative m => Path -> Branch m -> Branch m -> Branch m)	line:559	language:Haskell
setCharInput	./yaks/haskeline/tests/Unit.hs	/^setCharInput i = i { progArgs = ["chars"] }$/;"	fi	line:178	language:Haskell
setChildBranch	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^setChildBranch :: NameSegment -> Branch m -> Branch0 m -> Branch0 m$/;"	ft	signature:(NameSegment -> Branch m -> Branch0 m -> Branch0 m)	line:659	language:Haskell
setCombine	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^setCombine :: Applicative m => Ord a => Set a -> Set a -> m (Set a)$/;"	ft	signature:(Applicative m => Ord a => Set a -> Set a -> m (Set a))	line:171	language:Haskell
setComplete	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^setComplete :: CompletionFunc m -> Settings m -> Settings m$/;"	ft	signature:(CompletionFunc m -> Settings m -> Settings m)	line:35	language:Haskell
setContext	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^setContext :: Context v loc -> M v loc ()$/;"	ft	signature:(Context v loc -> M v loc ())	line:452	language:Haskell
setControlBits	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^setControlBits :: Char -> Char$/;"	ft	signature:(Char -> Char)	line:59	language:Haskell
setDiff	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^setDiff :: Applicative m => Ord a => Set a -> Set a -> m (Set a, Set a)$/;"	ft	signature:(Applicative m => Ord a => Set a -> Set a -> m (Set a, Set a))	line:174	language:Haskell
setEnv	./yaks/haskeline/tests/RunTTY.hs	/^setEnv :: String -> String -> Invocation -> Invocation$/;"	ft	signature:(String -> String -> Invocation -> Invocation)	line:33	language:Haskell
setIfNotExists	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^setIfNotExists dest b root = case getAt dest root of$/;"	fi	line:555	language:Haskell
setLang	./yaks/haskeline/tests/RunTTY.hs	/^setLang = setEnv "LANG"$/;"	fi	line:39	language:Haskell
setLatin1	./yaks/haskeline/tests/RunTTY.hs	/^setLatin1 = setLang "en_US.ISO8859-1"$/;"	fi	line:44	language:Haskell
setLoc	./unison-core/src/Unison/Pattern.hs	/^setLoc :: PatternP loc -> loc -> PatternP loc$/;"	ft	signature:(PatternP loc -> loc -> PatternP loc)	line:88	language:Haskell
setLoc	./unison-core/src/Unison/PatternP.hs	/^setLoc :: P.PatternP loc -> loc -> P.PatternP loc$/;"	ft	signature:(P.PatternP loc -> loc -> P.PatternP loc)	line:38	language:Haskell
setPatch	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^setPatch :: Applicative m => Ord a => Set a -> (Set a, Set a) -> m (Set a)$/;"	ft	signature:(Applicative m => Ord a => Set a -> (Set a, Set a) -> m (Set a))	line:177	language:Haskell
setPos	./parser-typechecker/src/Unison/Parser.hs	/^setPos :: P.SourcePos -> L.Pos -> P.SourcePos$/;"	ft	signature:(P.SourcePos -> L.Pos -> P.SourcePos)	line:172	language:Haskell
setPos	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^setPos :: Coord -> DrawM ()$/;"	ft	signature:(Coord -> DrawM ())	line:273	language:Haskell
setPosition	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^setPosition :: HANDLE -> Coord -> IO ()$/;"	ft	signature:(HANDLE -> Coord -> IO ())	line:184	language:Haskell
setReplacement	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^setReplacement :: (String -> String) -> Completion -> Completion$/;"	ft	signature:((String -> String) -> Completion -> Completion)	line:105	language:Haskell
setRow	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^setRow :: Int -> Int -> TermRows -> TermRows$/;"	ft	signature:(Int -> Int -> TermRows -> TermRows)	line:97	language:Haskell
setState	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^setState :: (Monad m, LineState s) => Command m s s$/;"	ft	signature:((Monad m, LineState s) => Command m s s)	line:156	language:Haskell
setTerm	./yaks/haskeline/tests/RunTTY.hs	/^setTerm = setEnv "TERM"$/;"	fi	line:40	language:Haskell
setUTF8	./yaks/haskeline/tests/RunTTY.hs	/^setUTF8 = setLang "en_US.UTF-8"$/;"	fi	line:43	language:Haskell
settors	./yaks/haskeline/System/Console/Haskeline/Prefs.hs	/^settors :: [(String, String -> Prefs -> Prefs)]$/;"	ft	signature:([(String, String -> Prefs -> Prefs)])	line:91	language:Haskell
shadowing	./unison-core/src/Unison/Names3.hs	/^shadowing :: Names0 -> Names -> Names$/;"	ft	signature:(Names0 -> Names -> Names)	line:120	language:Haskell
shortBranchHash	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^shortBranchHash :: P ShortBranchHash$/;"	ft	signature:(P ShortBranchHash)	line:164	language:Haskell
shortHash	./parser-typechecker/src/Unison/Lexer.hs	/^shortHash :: String -> Either Err (ShortHash, String)$/;"	ft	signature:(String -> Either Err (ShortHash, String))	line:684	language:Haskell
shortName	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shortName :: FilePath -> FilePath$/;"	ft	signature:(FilePath -> FilePath)	line:126	language:Haskell
shortenDirectory	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^shortenDirectory :: FilePath -> IO FilePath$/;"	ft	signature:(FilePath -> IO FilePath)	line:117	language:Haskell
shouldFailLater	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldFailLater :: IO [FilePath]$/;"	ft	signature:(IO [FilePath])	line:95	language:Haskell
shouldFailNow	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldFailNow :: IO [FilePath]$/;"	ft	signature:(IO [FilePath])	line:89	language:Haskell
shouldFailPath	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldPassPath, shouldFailPath :: String$/;"	ft	signature:(String)	line:82	language:Haskell
shouldFailPath	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldFailPath = "unison-src\/errors"$/;"	fi	line:84	language:Haskell
shouldPassLater	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldPassLater :: IO [FilePath]$/;"	ft	signature:(IO [FilePath])	line:92	language:Haskell
shouldPassNow	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldPassNow :: IO [FilePath]$/;"	ft	signature:(IO [FilePath])	line:86	language:Haskell
shouldPassPath	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^shouldPassPath, shouldFailPath :: String$/;"	ft	signature:(String)	line:82	language:Haskell
shouldPerformAbilityCheck	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^shouldPerformAbilityCheck :: (Ord loc, Var v) => Type v loc -> M v loc Bool$/;"	ft	signature:((Ord loc, Var v) => Type v loc -> M v loc Bool)	line:627	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  show = show . unRawHash$/;"	fi	instance:Show (RawHash a)	line:50	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  show = \\case$/;"	fi	instance:Show e => Show (Causal m h e)	line:53	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  show (Path' (Left abs)) = show abs$/;"	fi	instance:Show Path'	line:53	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  show s = "." ++ show (unabsolute s)$/;"	fi	instance:Show Absolute	line:57	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  show = show . unrelative$/;"	fi	instance:Show Relative	line:60	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/Path.hs	/^  show = Text.unpack . toText$/;"	fi	instance:Show Path	line:321	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^  show (ShortBranchHash h) = '#' : Text.unpack h$/;"	fi	instance:Show ShortBranchHash	line:32	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^  show (UcmCommand path txt) = show path <> ">" <> Text.unpack txt$/;"	fi	instance:Show UcmCommand	line:65	language:Haskell
show	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^  show s = case s of$/;"	fi	instance:Show Stanza	line:68	language:Haskell
show	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  show at = "ArgumentType " <> typeName at$/;"	fi	instance:Show ArgumentType	line:46	language:Haskell
show	./parser-typechecker/src/Unison/Lexer.hs	/^  show (L a) = show a$/;"	fi	instance:Show a => Show (T a)	line:179	language:Haskell
show	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  show _ = "PrettyPrintEnv"$/;"	fi	instance:Show PrettyPrintEnv	line:34	language:Haskell
show	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  show (SymbolC lazy s) = (if lazy then "'" else "") <> show s$/;"	fi	instance:Show SymbolC	line:67	language:Haskell
show	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  show (LazySlot i) = "'#" ++ show i$/;"	fi	instance:(Show e, Show cont) => Show (Z e cont)	line:822	language:Haskell
show	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  show (I n) = show n$/;"	fi	instance:(Show e, Show cont) => Show (Value e cont)	line:963	language:Haskell
show	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  show _c = "<continuation>"$/;"	fi	instance:Show Continuation	line:66	language:Haskell
show	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^  show _ = "ExternalFunction"$/;"	fi	instance:Show ExternalFunction	line:800	language:Haskell
show	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  show (Var v) = case v of$/;"	fi	instance:(Var v) => Show (Element v loc)	line:1775	language:Haskell
show	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  show ctx@(Context es) = "Î\\n  " ++ (intercalate "\\n  " . map (showElem ctx . fst)) (reverse es)$/;"	fi	instance:(Ord loc, Var v) => Show (Context v loc)	line:1784	language:Haskell
show	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  show (Universal v) = show v$/;"	fi	instance:Show v => Show (TypeVar b v)	line:32	language:Haskell
show	./parser-typechecker/src/Unison/Util/Bytes.hs	/^  show bs = show (toWord8s bs)$/;"	fi	instance:Show Bytes	line:87	language:Haskell
show	./parser-typechecker/src/Unison/Util/Pretty.hs	/^  show p = render 80 (metaPretty p)$/;"	fi	instance:Show s => Show (Pretty s)	line:780	language:Haskell
show	./unison-core/src/Unison/Codebase/NameSegment.hs	/^  show = Text.unpack . toText$/;"	fi	instance:Show NameSegment	line:40	language:Haskell
show	./unison-core/src/Unison/Hash.hs	/^  show h = take 999 $ Text.unpack (base32Hex h)$/;"	fi	instance:Show Hash	line:25	language:Haskell
show	./unison-core/src/Unison/HashQualified'.hs	/^  show = Text.unpack . toText$/;"	fi	instance:Show n => Show (HashQualified' n)	line:119	language:Haskell
show	./unison-core/src/Unison/Name.hs	/^  show = toString$/;"	fi	instance:Show Name	line:132	language:Haskell
show	./unison-core/src/Unison/Names2.hs	/^  show (Names terms types) = "Terms:\\n" ++$/;"	fi	instance:Show n => Show (Names' n)	line:331	language:Haskell
show	./unison-core/src/Unison/Pattern.hs	/^  show (UnboundP _  ) = "Unbound"$/;"	fi	instance:Show (PatternP loc)	line:64	language:Haskell
show	./unison-core/src/Unison/Reference.hs	/^instance Show Id where show = SH.toString . SH.take 5 . toShortHash . DerivedId$/;"	fi	instance:Show Id	line:169	language:Haskell
show	./unison-core/src/Unison/Reference.hs	/^instance Show Reference where show = SH.toString . SH.take 5 . toShortHash$/;"	fi	instance:Show Reference	line:170	language:Haskell
show	./unison-core/src/Unison/Symbol.hs	/^  show (Symbol 0 n) = show n$/;"	fi	instance:Show Symbol	line:31	language:Haskell
show	./unison-core/src/Unison/Type.hs	/^  show = show . getPolytype$/;"	fi	instance:(Show v) => Show (Monotype v a)	line:87	language:Haskell
show	./unison-core/src/Unison/Util/Relation.hs	/^  show = show . toList$/;"	fi	instance:(Show a, Show b) => Show (Relation a b)	line:39	language:Haskell
show	./unison-core/src/Unison/Util/Relation3.hs	/^  show = show . toList$/;"	fi	instance:(Show a, Show b, Show c) => Show (Relation3 a b c)	line:22	language:Haskell
show	./unison-core/src/Unison/Util/Relation4.hs	/^  show = show . toList$/;"	fi	instance:(Show a, Show b, Show c, Show d) => Show (Relation4 a b c d)	line:27	language:Haskell
show	./yaks/haskeline/System/Console/Haskeline/History.hs	/^    show = show . histLines$/;"	fi	instance:Show History	line:47	language:Haskell
show	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^    show m = show $ catMaybes [maybeUse hasControl "ctrl"$/;"	fi	instance:Show Modifier	line:26	language:Haskell
show	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    show g = show (gBaseChar g : combiningChars g)$/;"	fi	instance:Show Grapheme	line:81	language:Haskell
showBase32Hex	./unison-core/src/Unison/Hash.hs	/^showBase32Hex :: H.Hashable t => t -> String$/;"	ft	signature:(H.Hashable t => t -> String)	line:108	language:Haskell
showConstructor	./parser-typechecker/src/Unison/PrintError.hs	/^showConstructor :: IsString s => Env -> R.Reference -> Int -> s$/;"	ft	signature:(IsString s => Env -> R.Reference -> Int -> s)	line:785	language:Haskell
showDiffNamespace	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^showDiffNamespace :: forall v . Var v$/;"	ft	signature:(forall v . Var v => ShowNumbers -> PPE.PrettyPrintEnv -> Path.Absolute -> Path.Absolute -> OBD.BranchDiffOutput v Ann -> (Pretty, NumberedArgs))	line:1303	language:Haskell
showEscapeChar	./parser-typechecker/src/Unison/Lexer.hs	/^showEscapeChar :: Char -> Maybe Char$/;"	ft	signature:(Char -> Maybe Char)	line:593	language:Haskell
showLexerOutput	./parser-typechecker/src/Unison/PrintError.hs	/^showLexerOutput :: Bool$/;"	ft	signature:(Bool)	line:844	language:Haskell
showNotes	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^showNotes :: Foldable f => String -> PrintError.Env -> f Note -> String$/;"	ft	signature:(Foldable f => String -> PrintError.Env -> f Note -> String)	line:103	language:Haskell
showParseError	./parser-typechecker/tests/Unison/Test/Common.hs	/^showParseError :: Var v$/;"	ft	signature:(Var v => String -> MPE.ParseError (L.Token L.Lexeme) (Parser.Error v) -> String)	line:53	language:Haskell
showPatternHelp	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^showPatternHelp :: InputPattern -> P.Pretty CT.ColorText$/;"	ft	signature:(InputPattern -> P.Pretty CT.ColorText)	line:45	language:Haskell
showShort	./unison-core/src/Unison/Reference.hs	/^showShort :: Int -> Reference -> Text$/;"	ft	signature:(Int -> Reference -> Text)	line:107	language:Haskell
showShort	./unison-core/src/Unison/Referent.hs	/^showShort :: Int -> Referent -> Text$/;"	ft	signature:(Int -> Referent -> Text)	line:48	language:Haskell
showSource	./parser-typechecker/src/Unison/PrintError.hs	/^showSource :: Ord a => String -> [(Range, a)] -> Pretty (AnnotatedText a)$/;"	ft	signature:(Ord a => String -> [(Range, a)] -> Pretty (AnnotatedText a))	line:1159	language:Haskell
showSource1	./parser-typechecker/src/Unison/PrintError.hs	/^showSource1 :: Ord a => String -> (Range, a) -> Pretty (AnnotatedText a)$/;"	ft	signature:(Ord a => String -> (Range, a) -> Pretty (AnnotatedText a))	line:1164	language:Haskell
showSourceMaybes	./parser-typechecker/src/Unison/PrintError.hs	/^showSourceMaybes src annotations = showSource src $ catMaybes annotations$/;"	fi	line:1157	language:Haskell
showSuffix	./unison-core/src/Unison/Reference.hs	/^showSuffix :: Pos -> Size -> Text$/;"	ft	signature:(Pos -> Size -> Text)	line:91	language:Haskell
showTermRef	./parser-typechecker/src/Unison/PrintError.hs	/^showTermRef :: IsString s => Env -> Referent -> s$/;"	ft	signature:(IsString s => Env -> Referent -> s)	line:778	language:Haskell
showTodoOutput	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^showTodoOutput getPpe patch names0 = do$/;"	fi	line:1677	language:Haskell
showTokens	./parser-typechecker/src/Unison/Lexer.hs	/^  showTokens xs =$/;"	fi	instance:ShowToken (Token Lexeme)	line:85	language:Haskell
showTypeRef	./parser-typechecker/src/Unison/PrintError.hs	/^showTypeRef :: IsString s => Env -> R.Reference -> s$/;"	ft	signature:(IsString s => Env -> R.Reference -> s)	line:781	language:Haskell
showTypeWithProvenance	./parser-typechecker/src/Unison/PrintError.hs	/^showTypeWithProvenance env src color typ =$/;"	fi	line:99	language:Haskell
shown	./parser-typechecker/src/Unison/Util/Pretty.hs	/^shown :: (Show a, IsString s) => a -> Pretty s$/;"	ft	signature:((Show a, IsString s) => a -> Pretty s)	line:574	language:Haskell
showsPrec	./unison-core/src/Unison/ABT.hs	/^  showsPrec p (Term _ _ out) = case out of$/;"	fi	instance:(Show1 f, Show v) => Show (Term f v a)	line:700	language:Haskell
showsPrec	./unison-core/src/Unison/Term.hs	/^  showsPrec = go$/;"	fi	instance:(Show v, Show a) => Show (F v a0 p a)	line:1066	language:Haskell
showsPrec	./unison-core/src/Unison/Type.hs	/^  showsPrec = go where$/;"	fi	instance:Show a => Show (F a)	line:609	language:Haskell
showsPrec1	./unison-core/src/Unison/Term.hs	/^instance (Show v) => Show1 (F v a p) where showsPrec1 = showsPrec$/;"	fi	instance:(Show v) => Show1 (F v a p)	line:1035	language:Haskell
showsPrec1	./unison-core/src/Unison/Type.hs	/^instance Show1 F where showsPrec1 = showsPrec$/;"	fi	instance:Show1 F	line:56	language:Haskell
signatureNeedsAccompanyingBodyTest	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  signatureNeedsAccompanyingBodyTest :: Test ()$/;"	ft	signature:(Test ())	line:85	language:Haskell
simpleActions	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^simpleActions, controlActions :: InputKeyCmd InsertMode InsertMode$/;"	ft	signature:(InputKeyCmd InsertMode InsertMode)	line:35	language:Haskell
simpleChar	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^simpleChar, metaChar, ctrlChar :: Char -> Key$/;"	ft	signature:(Char -> Key)	line:53	language:Haskell
simpleCmdActions	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^simpleCmdActions :: InputKeyCmd CommandMode CommandMode$/;"	ft	signature:(InputKeyCmd CommandMode CommandMode)	line:110	language:Haskell
simpleCommand	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^simpleCommand :: (LineState s, Monad m) => (s -> m (Either Effect s))$/;"	ft	signature:((LineState s, Monad m) => (s -> m (Either Effect s)) -> Command m s s)	line:144	language:Haskell
simpleCompletion	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^simpleCompletion :: String -> Completion$/;"	ft	signature:(String -> Completion)	line:88	language:Haskell
simpleFuzzyFinder	./parser-typechecker/src/Unison/Util/Find.hs	/^simpleFuzzyFinder :: forall a.$/;"	ft	signature:(forall a. String -> [a] -> (a -> String) -> [(a, P.Pretty P.ColorText)])	line:41	language:Haskell
simpleFuzzyScore	./parser-typechecker/src/Unison/Util/Find.hs	/^simpleFuzzyScore :: String -> String -> Maybe Int$/;"	ft	signature:(String -> String -> Maybe Int)	line:64	language:Haskell
simpleInsertions	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^simpleInsertions :: InputKeyCmd InsertMode InsertMode$/;"	ft	signature:(InputKeyCmd InsertMode InsertMode)	line:48	language:Haskell
simpleKey	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^simpleKey :: BaseKey -> Key$/;"	ft	signature:(BaseKey -> Key)	line:44	language:Haskell
simpleSymbolyId	./parser-typechecker/src/Unison/Lexer.hs	/^simpleSymbolyId :: String -> Lexeme$/;"	ft	signature:(String -> Lexeme)	line:68	language:Haskell
simpleWordyId	./parser-typechecker/src/Unison/Lexer.hs	/^simpleWordyId :: String -> Lexeme$/;"	ft	signature:(String -> Lexeme)	line:65	language:Haskell
singleton	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^singleton :: Type -> Value -> Metadata$/;"	ft	signature:(Type -> Value -> Metadata)	line:59	language:Haskell
singleton	./parser-typechecker/src/Unison/Codebase/Path.hs	/^singleton :: NameSegment -> Path$/;"	ft	signature:(NameSegment -> Path)	line:252	language:Haskell
singleton	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  singleton ch = fromString [ch]$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:45	language:Haskell
singleton	./unison-core/src/Unison/Util/Relation.hs	/^singleton :: a -> b -> Relation a b$/;"	ft	signature:(a -> b -> Relation a b)	line:81	language:Haskell
size	./parser-typechecker/src/Unison/Util/Bytes.hs	/^size :: Bytes -> Int$/;"	ft	signature:(Bytes -> Int)	line:33	language:Haskell
size	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^size :: CycleTable k v -> IO Int$/;"	ft	signature:(CycleTable k v -> IO Int)	line:32	language:Haskell
size	./parser-typechecker/src/Unison/Util/TQueue.hs	/^size :: TQueue a -> STM Int$/;"	ft	signature:(TQueue a -> STM Int)	line:17	language:Haskell
size	./unison-core/src/Unison/Util/Relation.hs	/^size    ::  Relation a b -> Int$/;"	ft	signature:(Relation a b -> Int)	line:51	language:Haskell
size	./unison-core/src/Unison/Util/Relation3.hs	/^size :: (Ord a, Ord b, Ord c) => Relation3 a b c -> Int$/;"	ft	signature:((Ord a, Ord b, Ord c) => Relation3 a b c -> Int)	line:49	language:Haskell
size	./unison-core/src/Unison/Util/Relation4.hs	/^size :: (Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d -> Int$/;"	ft	signature:((Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d -> Int)	line:29	language:Haskell
sizeOf	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^    sizeOf _ = (#size COORD)$/;"	fi	instance:Storable Coord	line:170	language:Haskell
sizeRef	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^    sizeRef  :: M.IOPRef Int$/;"	c_a	cons:CycleTable.CycleTable	line:15	language:Haskell
skip	./yaks/easytest/src/EasyTest.hs	/^skip :: Test ()$/;"	ft	signature:(Test ())	line:345	language:Haskell
skipAbilityCheck	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  skipAbilityCheck :: [Type v loc]$/;"	c_a	cons:MEnv.MEnv	line:323	language:Haskell
skipLeft	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^skipLeft, skipRight :: (Char -> Bool) -> InsertMode -> InsertMode$/;"	ft	signature:((Char -> Bool) -> InsertMode -> InsertMode)	line:236	language:Haskell
skipRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^skipLeft, skipRight :: (Char -> Bool) -> InsertMode -> InsertMode$/;"	ft	signature:((Char -> Bool) -> InsertMode -> InsertMode)	line:236	language:Haskell
skipRight	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^skipRight f (IMode xs ys) = let (ws,zs) = span (f . baseChar) ys $/;"	fi	line:239	language:Haskell
slurpResultNames0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^basicParseNames0, basicPrettyPrintNames0, slurpResultNames0 :: Functor m => Action' m v Names0$/;"	ft	signature:(Functor m => Action' m v Names0)	line:2489	language:Haskell
slurpResultNames0	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^slurpResultNames0 = currentPathNames0$/;"	fi	line:2493	language:Haskell
smkx	./yaks/haskeline/tests/Unit.hs	/^smkx,rmkx :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:261	language:Haskell
snipWithContext	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^snipWithContext :: Int -> AnnotatedExcerpt a -> [AnnotatedExcerpt a]$/;"	ft	signature:(Int -> AnnotatedExcerpt a -> [AnnotatedExcerpt a])	line:157	language:Haskell
snoc	./parser-typechecker/src/Unison/Codebase/Path.hs	/^snoc :: Path -> NameSegment -> Path$/;"	ft	signature:(Path -> NameSegment -> Path)	line:258	language:Haskell
snoc	./parser-typechecker/src/Unison/Util/Bytes.hs	/^snoc :: Bytes -> B.ByteString -> Bytes$/;"	ft	signature:(Bytes -> B.ByteString -> Bytes)	line:43	language:Haskell
snoc'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^snoc' :: Path' -> NameSegment -> Path'$/;"	ft	signature:(Path' -> NameSegment -> Path')	line:261	language:Haskell
socketId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
socketId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^socketId = constructorNamed socketReference "io.Socket.Socket"$/;"	fi	line:99	language:Haskell
socketReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^socketReference = typeNamed "io.Socket"$/;"	fi	line:79	language:Haskell
softbreak	./parser-typechecker/src/Unison/Util/Pretty.hs	/^softbreak :: IsString s => Pretty s$/;"	ft	signature:(IsString s => Pretty s)	line:295	language:Haskell
solve	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^solve :: (Var v, Ord loc) => Context v loc -> v -> Monotype v loc -> M v loc (Maybe (Context v loc))$/;"	ft	signature:((Var v, Ord loc) => Context v loc -> v -> Monotype v loc -> M v loc (Maybe (Context v loc)))	line:1560	language:Haskell
solveBlank	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^solveBlank :: B.Recorded loc -> v -> Type v loc -> M v loc ()$/;"	ft	signature:(B.Recorded loc -> v -> Type v loc -> M v loc ())	line:304	language:Haskell
solvedBlank	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^solvedBlank :: InfoExtractor v loc (B.Recorded loc, v, C.Type v loc)$/;"	ft	signature:(InfoExtractor v loc (B.Recorded loc, v, C.Type v loc))	line:277	language:Haskell
solvedExistentials	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^       , solvedExistentials :: Map v (Monotype v loc) -- `v` is solved to some monotype$/;"	c_a	cons:Info.Info	line:330	language:Haskell
solvedVars	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                        , solvedVars   :: [(v, C.Type v loc)]$/;"	c_a	cons:TypeError.FunctionApplication	line:52	language:Haskell
some	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^some :: forall n a . SubseqExtractor' n a -> SubseqExtractor' n [a]$/;"	ft	signature:(forall n a . SubseqExtractor' n a -> SubseqExtractor' n [a])	line:119	language:Haskell
someId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
someId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^someId = constructorNamed optionReference "Optional.Some"$/;"	fi	line:95	language:Haskell
sortByLength	./unison-core/src/Unison/HashQualified.hs	/^sortByLength :: [HashQualified' Name] -> [HashQualified' Name]$/;"	ft	signature:([HashQualified' Name] -> [HashQualified' Name])	line:52	language:Haskell
sortNamed	./unison-core/src/Unison/Name.hs	/^sortNamed :: (a -> Name) -> [a] -> [a]$/;"	ft	signature:((a -> Name) -> [a] -> [a])	line:42	language:Haskell
sortNamed'	./unison-core/src/Unison/Name.hs	/^sortNamed' :: (a -> Name) -> (a -> a -> Ordering) -> [a] -> [a]$/;"	ft	signature:((a -> Name) -> (a -> a -> Ordering) -> [a] -> [a])	line:50	language:Haskell
sortNames	./unison-core/src/Unison/Name.hs	/^sortNames :: [Name] -> [Name]$/;"	ft	signature:([Name] -> [Name])	line:39	language:Haskell
source	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^source :: Text$/;"	ft	signature:(Text)	line:150	language:Haskell
spaceIfBreak	./parser-typechecker/src/Unison/Util/Pretty.hs	/^spaceIfBreak :: IsString s => Pretty s$/;"	ft	signature:(IsString s => Pretty s)	line:289	language:Haskell
spaced	./parser-typechecker/src/Unison/Util/Pretty.hs	/^spaced :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => f (Pretty s) -> Pretty s)	line:298	language:Haskell
spacedMap	./parser-typechecker/src/Unison/Util/Pretty.hs	/^spacedMap :: (Foldable f, IsString s) => (a -> Pretty s) -> f a -> Pretty s$/;"	ft	signature:((Foldable f, IsString s) => (a -> Pretty s) -> f a -> Pretty s)	line:301	language:Haskell
spaces	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^spaces :: P ()$/;"	ft	signature:(P ())	line:391	language:Haskell
spaces	./parser-typechecker/src/Unison/PrintError.hs	/^spaces :: (IsString a, Monoid a) => (b -> a) -> [b] -> a$/;"	ft	signature:((IsString a, Monoid a) => (b -> a) -> [b] -> a)	line:754	language:Haskell
spaces	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^backs,spaces :: Int -> String$/;"	ft	signature:(Int -> String)	line:59	language:Haskell
spaces	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^spaces n = replicate n ' '$/;"	fi	line:61	language:Haskell
spaces	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^spaces :: Int -> TermAction$/;"	ft	signature:(Int -> TermAction)	line:220	language:Haskell
spacesIfBreak	./parser-typechecker/src/Unison/Util/Pretty.hs	/^spacesIfBreak :: IsString s => Int -> Pretty s$/;"	ft	signature:(IsString s => Int -> Pretty s)	line:292	language:Haskell
span'	./parser-typechecker/src/Unison/Lexer.hs	/^span' :: (a -> Bool) -> [a] -> (([a],[a]) -> r) -> r$/;"	ft	signature:((a -> Bool) -> [a] -> (([a], [a]) -> r) -> r)	line:773	language:Haskell
spanThru'	./parser-typechecker/src/Unison/Lexer.hs	/^spanThru' :: (a -> Bool) -> [a] -> (([a],[a]) -> r) -> r$/;"	ft	signature:((a -> Bool) -> [a] -> (([a], [a]) -> r) -> r)	line:776	language:Haskell
specialEncode	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^specialEncode :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:24	language:Haskell
specialEncodeChar	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^specialEncodeChar :: Char -> Test ()$/;"	ft	signature:(Char -> Test ())	line:28	language:Haskell
specialKeys	./yaks/haskeline/System/Console/Haskeline/Key.hs	/^specialKeys :: [(String,BaseKey)]$/;"	ft	signature:([(String, BaseKey)])	line:63	language:Haskell
specializeIR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^specializeIR :: Map Int (Value e cont) -> IR' a (Z e cont) -> IR' a (Z e cont)$/;"	ft	signature:(Map Int (Value e cont) -> IR' a (Z e cont) -> IR' a (Z e cont))	line:417	language:Haskell
splitAtQuote	./yaks/haskeline/System/Console/Haskeline/Completion.hs	/^splitAtQuote :: Maybe Char -> String -> String -> Maybe (String,String)$/;"	ft	signature:(Maybe Char -> String -> String -> Maybe (String, String))	line:138	language:Haskell
splitAtWidth	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^splitAtWidth :: Int -> [Grapheme] -> ([Grapheme],[Grapheme],Int)$/;"	ft	signature:(Int -> [Grapheme] -> ([Grapheme], [Grapheme], Int))	line:32	language:Haskell
splitAtWidth'	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^splitAtWidth' :: Int -> [Grapheme] -> ([Grapheme],[Grapheme],Int)$/;"	ft	signature:(Int -> [Grapheme] -> ([Grapheme], [Grapheme], Int))	line:37	language:Haskell
splitFromName	./parser-typechecker/src/Unison/Codebase/Path.hs	/^splitFromName :: Name -> Maybe Split$/;"	ft	signature:(Name -> Maybe Split)	line:243	language:Haskell
splitIntoGroups	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^splitIntoGroups :: Int -> [a] -> [[a]]$/;"	ft	signature:(Int -> [a] -> [[a]])	line:152	language:Haskell
splitName	./parser-typechecker/src/Unison/TermPrinter.hs	/^splitName :: Name -> [(Prefix, Suffix)]$/;"	ft	signature:(Name -> [(Prefix, Suffix)])	line:823	language:Haskell
splitStringLit	./parser-typechecker/src/Unison/Lexer.hs	/^splitStringLit :: String -> Either Err (Pos, String, String)$/;"	ft	signature:(String -> Either Err (Pos, String, String))	line:559	language:Haskell
stanza	./parser-typechecker/src/Unison/FileParser.hs	/^stanza :: Var v => P v (Stanza v (Term v Ann))$/;"	ft	signature:(Var v => P v (Stanza v (Term v Ann)))	line:110	language:Haskell
stanzas	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^stanzas :: P [Stanza]$/;"	ft	signature:(P [Stanza])	line:291	language:Haskell
stanzas	./parser-typechecker/src/Unison/Lexer.hs	/^stanzas :: [T (Token Lexeme)] -> [[T (Token Lexeme)]]$/;"	ft	signature:([T (Token Lexeme)] -> [[T (Token Lexeme) ]])	line:206	language:Haskell
starToR4	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^starToR4 :: (Ord r, Ord n) => Star r n -> Relation4 r n Type Value$/;"	ft	signature:((Ord r, Ord n) => Star r n -> Relation4 r n Type Value)	line:28	language:Haskell
start	./parser-typechecker/src/Unison/Lexer.hs	/^  start :: Pos,$/;"	c_a	cons:Token.Token	line:73	language:Haskell
start	./parser-typechecker/src/Unison/Parser.hs	/^  | Ann { start :: L.Pos, end :: L.Pos }$/;"	c_a	cons:Ann.Ann	line:112	language:Haskell
start	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  | Ranged { get :: a, start :: Int, end :: Int }$/;"	c_a	cons:Ranged.Ranged	line:66	language:Haskell
start	./parser-typechecker/src/Unison/Util/Range.hs	/^data Range = Range { start :: Pos, end :: Pos } deriving (Eq, Ord, Show)$/;"	c_a	cons:Range.Range	line:18	language:Haskell
startArg	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^startArg :: Int -> s -> ArgMode s$/;"	ft	signature:(Int -> s -> ArgMode s)	line:358	language:Haskell
startSearchMode	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^startSearchMode :: Direction -> InsertMode -> SearchMode$/;"	ft	signature:(Direction -> InsertMode -> SearchMode)	line:103	language:Haskell
startingLine	./parser-typechecker/src/Unison/Parser.hs	/^startingLine :: Ann -> Maybe L.Line$/;"	ft	signature:(Ann -> Maybe L.Line)	line:115	language:Haskell
startingLine	./parser-typechecker/src/Unison/Util/Range.hs	/^startingLine :: Range -> Range$/;"	ft	signature:(Range -> Range)	line:20	language:Haskell
stdinTTY	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^stdinTTY :: MaybeT IO RunTerm$/;"	ft	signature:(MaybeT IO RunTerm)	line:27	language:Haskell
stdinTTYHandles	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^stdinTTYHandles, ttyHandles :: MaybeT IO Handles$/;"	ft	signature:(MaybeT IO Handles)	line:250	language:Haskell
step	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^step :: Applicative m => (Branch0 m -> Branch0 m) -> Branch m -> Branch m$/;"	ft	signature:(Applicative m => (Branch0 m -> Branch0 m) -> Branch m -> Branch m)	line:601	language:Haskell
step	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^step :: (Applicative m, Hashable e) => (e -> e) -> Causal m h e -> Causal m h e$/;"	ft	signature:((Applicative m, Hashable e) => (e -> e) -> Causal m h e -> Causal m h e)	line:290	language:Haskell
stepAt	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepAt :: forall m. Applicative m$/;"	ft	signature:(forall m. Applicative m => Path -> (Branch0 m -> Branch0 m) -> Branch m -> Branch m)	line:620	language:Haskell
stepAt	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^stepAt :: forall m i v. Monad m$/;"	ft	signature:(forall m i v. Monad m => InputDescription -> (Path, Branch0 m -> Branch0 m) -> Action m i v ())	line:1974	language:Haskell
stepAtM	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepAtM :: forall n m. (Functor n, Applicative m)$/;"	ft	signature:(forall n m. (Functor n, Applicative m) => Path -> (Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m))	line:634	language:Haskell
stepAtM	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^stepAtM :: forall m i v. Monad m$/;"	ft	signature:(forall m i v. Monad m => InputDescription -> (Path, Branch0 m -> m (Branch0 m)) -> Action m i v ())	line:1980	language:Haskell
stepAtM'	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^stepAtM' :: forall m i v. Monad m$/;"	ft	signature:(forall m i v. Monad m => InputDescription -> (Path, Branch0 m -> Action m i v (Branch0 m)) -> Action m i v Bool)	line:1986	language:Haskell
stepDistinct	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^stepDistinct :: (Applicative m, Eq e, Hashable e) => (e -> e) -> Causal m h e -> Causal m h e$/;"	ft	signature:((Applicative m, Eq e, Hashable e) => (e -> e) -> Causal m h e -> Causal m h e)	line:293	language:Haskell
stepDistinctM	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^stepDistinctM f c = (`consDistinct` c) <$> f (head c)$/;"	fi	line:311	language:Haskell
stepEverywhere	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepEverywhere f Branch0 {..} = f (branch0 _terms _types children _edits)$/;"	fi	line:649	language:Haskell
stepIf	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^stepIf cond f c = if cond (head c) then step f c else c$/;"	fi	line:302	language:Haskell
stepM	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepM :: (Monad m, Monad n) => (Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m)$/;"	ft	signature:((Monad m, Monad n) => (Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m))	line:604	language:Haskell
stepM	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^stepM f c = (`cons` c) <$> f (head c)$/;"	fi	line:306	language:Haskell
stepManyAt	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepManyAt :: (Monad m, Foldable f)$/;"	ft	signature:((Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch m -> Branch m)	line:628	language:Haskell
stepManyAt	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^stepManyAt :: (Monad m, Foldable f)$/;"	ft	signature:((Monad m, Foldable f) => InputDescription -> f (Path, Branch0 m -> Branch0 m) -> Action m i v ())	line:1992	language:Haskell
stepManyAt0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepManyAt0 :: forall f m . (Monad m, Foldable f)$/;"	ft	signature:(forall f m . (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m)	line:723	language:Haskell
stepManyAt0M	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepManyAt0M :: forall m n f . (Monad m, Monad n, Foldable f)$/;"	ft	signature:(forall m n f . (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch0 m -> n (Branch0 m))	line:729	language:Haskell
stepManyAtM	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^stepManyAtM :: (Monad m, Monad n, Foldable f)$/;"	ft	signature:((Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m))	line:642	language:Haskell
stepManyAtM	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^stepManyAtM :: (Monad m, Foldable f)$/;"	ft	signature:((Monad m, Foldable f) => InputDescription -> f (Path, Branch0 m -> m (Branch0 m)) -> Action m i v ())	line:2001	language:Haskell
stepManyAtM'	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^stepManyAtM' :: (Monad m, Foldable f)$/;"	ft	signature:((Monad m, Foldable f) => InputDescription -> f (Path, Branch0 m -> Action m i v (Branch0 m)) -> Action m i v Bool)	line:2010	language:Haskell
stifleAmount	./yaks/haskeline/System/Console/Haskeline/History.hs	/^stifleAmount :: History -> Maybe Int$/;"	ft	signature:(History -> Maybe Int)	line:43	language:Haskell
stifleAmt	./yaks/haskeline/System/Console/Haskeline/History.hs	/^                        stifleAmt :: Maybe Int}$/;"	c_a	cons:History.History	line:39	language:Haskell
stifleHistory	./yaks/haskeline/System/Console/Haskeline/History.hs	/^stifleHistory :: Maybe Int -> History -> History$/;"	ft	signature:(Maybe Int -> History -> History)	line:76	language:Haskell
storeLastCmd	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^storeLastCmd :: Monad m => SavedCommand m -> Command (ViT m) s s$/;"	ft	signature:(Monad m => SavedCommand m -> Command (ViT m) s s)	line:369	language:Haskell
storedAction	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^storedAction :: Monad m => SavedCommand m -> SavedCommand m$/;"	ft	signature:(Monad m => SavedCommand m -> SavedCommand m)	line:374	language:Haskell
storedCmdAction	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^storedCmdAction :: Monad m => Command (ViT m) (ArgMode CommandMode) CommandMode$/;"	ft	signature:(Monad m => Command (ViT m) (ArgMode CommandMode) CommandMode -> Command (ViT m) (ArgMode CommandMode) CommandMode)	line:377	language:Haskell
storedIAction	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^storedIAction :: Monad m => Command (ViT m) (ArgMode CommandMode) InsertMode$/;"	ft	signature:(Monad m => Command (ViT m) (ArgMode CommandMode) InsertMode -> Command (ViT m) (ArgMode CommandMode) InsertMode)	line:381	language:Haskell
string	./parser-typechecker/src/Unison/Parser.hs	/^string :: Ord v => P v (L.Token Text)$/;"	ft	signature:(Ord v => P v (L.Token Text))	line:395	language:Haskell
string	./parser-typechecker/src/Unison/Util/Pretty.hs	/^string :: IsString s => String -> Pretty s$/;"	ft	signature:(IsString s => String -> Pretty s)	line:571	language:Haskell
stringToGraphemes	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^stringToGraphemes :: String -> [Grapheme]$/;"	ft	signature:(String -> [Grapheme])	line:109	language:Haskell
stripEffect	./unison-core/src/Unison/Type.hs	/^stripEffect :: Ord v => Type v a -> ([Type v a], Type v a)$/;"	ft	signature:(Ord v => Type v a -> ([Type v a], Type v a))	line:359	language:Haskell
stripIntroOuters	./unison-core/src/Unison/Type.hs	/^stripIntroOuters :: Type v a -> Type v a$/;"	ft	signature:(Type v a -> Type v a)	line:167	language:Haskell
stripNamePrefix	./unison-core/src/Unison/Name.hs	/^stripNamePrefix :: Name -> Name -> Maybe Name$/;"	ft	signature:(Name -> Name -> Maybe Name)	line:88	language:Haskell
stripNamespace	./unison-core/src/Unison/HashQualified.hs	/^stripNamespace :: Text -> HashQualified -> HashQualified$/;"	ft	signature:(Text -> HashQualified -> HashQualified)	line:29	language:Haskell
stripPrefixes	./unison-core/src/Unison/Name.hs	/^stripPrefixes :: Name -> Name$/;"	ft	signature:(Name -> Name)	line:95	language:Haskell
stripSurroundingBlanks	./parser-typechecker/src/Unison/PrettyTerminal.hs	/^stripSurroundingBlanks :: String -> String$/;"	ft	signature:(String -> String)	line:10	language:Haskell
sttyKeys	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^sttyKeys :: Handle -> IO [(String, Key)]$/;"	ft	signature:(Handle -> IO [(String, Key)])	line:147	language:Haskell
style	./parser-typechecker/src/Unison/PrintError.hs	/^style :: s -> String -> Pretty (AnnotatedText s)$/;"	ft	signature:(s -> String -> Pretty (AnnotatedText s))	line:107	language:Haskell
style	./parser-typechecker/src/Unison/Util/ColorText.hs	/^style :: Color -> ColorText -> ColorText$/;"	ft	signature:(Color -> ColorText -> ColorText)	line:44	language:Haskell
styleAnnotated	./parser-typechecker/src/Unison/PrintError.hs	/^styleAnnotated :: Annotated a => sty -> a -> Maybe (Range, sty)$/;"	ft	signature:(Annotated a => sty -> a -> Maybe (Range, sty))	line:104	language:Haskell
styleHashQualified	./parser-typechecker/src/Unison/NamePrinter.hs	/^styleHashQualified ::$/;"	ft	signature:(IsString s => (Pretty s -> Pretty s) -> HQ.HashQualified -> Pretty s)	line:55	language:Haskell
styleHashQualified'	./parser-typechecker/src/Unison/NamePrinter.hs	/^styleHashQualified' ::$/;"	ft	signature:(IsString s => (Pretty s -> Pretty s) -> (Pretty s -> Pretty s) -> HQ.HashQualified -> Pretty s)	line:59	language:Haskell
styleHashQualified''	./parser-typechecker/src/Unison/NamePrinter.hs	/^styleHashQualified'' :: (Pretty SyntaxText -> Pretty SyntaxText)$/;"	ft	signature:((Pretty SyntaxText -> Pretty SyntaxText) -> HQ.HashQualified -> Pretty SyntaxText)	line:70	language:Haskell
styleInOverallType	./parser-typechecker/src/Unison/PrintError.hs	/^styleInOverallType e overallType leafType c = renderType e f overallType$/;"	fi	line:796	language:Haskell
stylePretty	./parser-typechecker/src/Unison/PrintError.hs	/^stylePretty :: Color -> Pretty ColorText -> Pretty ColorText$/;"	ft	signature:(Color -> Pretty ColorText -> Pretty ColorText)	line:110	language:Haskell
subseqExtractor	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^subseqExtractor :: (C.ErrorNote v loc -> [Ranged a]) -> SubseqExtractor v loc a$/;"	ft	signature:((C.ErrorNote v loc -> [Ranged a]) -> SubseqExtractor v loc a)	line:41	language:Haskell
subst	./unison-core/src/Unison/ABT.hs	/^subst v r = subst' (const r) v (freeVars r)$/;"	fi	line:310	language:Haskell
subst'	./unison-core/src/Unison/ABT.hs	/^subst' :: (Foldable f, Functor f, Var v) => (a -> Term f v a) -> v -> Set v -> Term f v a -> Term f v a$/;"	ft	signature:((Foldable f, Functor f, Var v) => (a -> Term f v a) -> v -> Set v -> Term f v a -> Term f v a)	line:316	language:Haskell
substImports	./parser-typechecker/src/Unison/TermParser.hs	/^substImports :: Var v => Names -> [(v,v)] -> Term v Ann -> Term v Ann$/;"	ft	signature:(Var v => Names -> [(v, v)] -> Term v Ann -> Term v Ann)	line:802	language:Haskell
substInheritAnnotation	./unison-core/src/Unison/ABT.hs	/^substInheritAnnotation :: (Foldable f, Functor f, Var v)$/;"	ft	signature:((Foldable f, Functor f, Var v) => v -> Term f v b -> Term f v a -> Term f v a)	line:333	language:Haskell
substTypeVar	./unison-core/src/Unison/Term.hs	/^substTypeVar vt ty = go Set.empty where$/;"	fi	line:329	language:Haskell
substTypeVars	./unison-core/src/Unison/Term.hs	/^substTypeVars :: (Ord v, Var vt)$/;"	ft	signature:((Ord v, Var vt) => [(vt, Type vt b)] -> Term' vt v a -> Term' vt v a)	line:313	language:Haskell
substs	./unison-core/src/Unison/ABT.hs	/^substs replacements body = foldr (uncurry subst) body (reverse replacements)$/;"	fi	line:353	language:Haskell
substsInheritAnnotation	./unison-core/src/Unison/ABT.hs	/^substsInheritAnnotation replacements body =$/;"	fi	line:343	language:Haskell
subterms	./unison-core/src/Unison/ABT.hs	/^subterms :: (Ord v, Traversable f) => Term f v a -> [Term f v a]$/;"	ft	signature:((Ord v, Traversable f) => Term f v a -> [Term f v a])	line:410	language:Haskell
subthreadFinished	./yaks/haskeline/System/Console/Haskeline/IO.hs	/^                        subthreadFinished :: MVar ()$/;"	c_a	cons:InputState.HD	line:55	language:Haskell
subtract	./unison-core/src/Unison/ABT.hs	/^subtract :: forall f v h a proxy . (Functor f, Hashable1 f, Eq v, Show v, Var v, Ord h, Accumulate h)$/;"	ft	signature:(forall f v h a proxy . (Functor f, Hashable1 f, Eq v, Show v, Var v, Ord h, Accumulate h) => proxy h -> [Term f v a] -> [Term f v a] -> [Term f v a])	line:691	language:Haskell
subtractComponent	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^subtractComponent :: forall v. Var v => SlurpComponent v -> SlurpResult v -> SlurpResult v$/;"	ft	signature:(forall v. Var v => SlurpComponent v -> SlurpResult v -> SlurpResult v)	line:84	language:Haskell
subtractDom	./unison-core/src/Unison/Util/Relation.hs	/^(<||), subtractDom :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Set a -> Relation a b -> Relation a b)	line:375	language:Haskell
subtractDom	./unison-core/src/Unison/Util/Relation.hs	/^subtractDom = (<||)$/;"	fi	line:377	language:Haskell
subtractRan	./unison-core/src/Unison/Util/Relation.hs	/^subtractRan :: (Ord a, Ord b) => Set b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Set b -> Relation a b -> Relation a b)	line:371	language:Haskell
subtype	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^subtype :: forall v loc . (Var v, Ord loc) => Type v loc -> Type v loc -> M v loc ()$/;"	ft	signature:(forall v loc . (Var v, Ord loc) => Type v loc -> Type v loc -> M v loc ())	line:1356	language:Haskell
succeeds	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^succeeds :: M v loc a -> TotalM v loc Bool$/;"	ft	signature:(M v loc a -> TotalM v loc Bool)	line:1718	language:Haskell
suffixCounterTerm	./parser-typechecker/src/Unison/TermPrinter.hs	/^suffixCounterTerm :: Var v => PrettyPrintEnv -> Term2 v at ap v a -> PrintAnnotation$/;"	ft	signature:(Var v => PrettyPrintEnv -> Term2 v at ap v a -> PrintAnnotation)	line:768	language:Haskell
suffixCounterType	./parser-typechecker/src/Unison/TermPrinter.hs	/^suffixCounterType :: Var v => PrettyPrintEnv -> Type v a -> PrintAnnotation$/;"	ft	signature:(Var v => PrettyPrintEnv -> Type v a -> PrintAnnotation)	line:781	language:Haskell
suffixes	./unison-core/src/Unison/Name.hs	/^suffixes :: Name -> [Name]$/;"	ft	signature:(Name -> [Name])	line:117	language:Haskell
suffixifiedPPE	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  suffixifiedPPE :: PrettyPrintEnv$/;"	c_a	cons:PrettyPrintEnvDecl.PrettyPrintEnvDecl	line:59	language:Haskell
suffixify	./unison-core/src/Unison/Names3.hs	/^suffixify :: Names -> Names$/;"	ft	signature:(Names -> Names)	line:53	language:Haskell
suffixify0	./unison-core/src/Unison/Names3.hs	/^suffixify0 :: Names0 -> Names0$/;"	ft	signature:(Names0 -> Names0)	line:44	language:Haskell
suggestionMatch	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^             , suggestionMatch :: SuggestionMatch$/;"	c_a	cons:Suggestion.Suggestion	line:256	language:Haskell
suggestionName	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^  Suggestion { suggestionName :: Text$/;"	c_a	cons:Suggestion.Suggestion	line:253	language:Haskell
suggestionReplacement	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^             , suggestionReplacement :: Either v Referent$/;"	c_a	cons:Suggestion.Suggestion	line:255	language:Haskell
suggestionType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^             , suggestionType :: Type v loc$/;"	c_a	cons:Suggestion.Suggestion	line:254	language:Haskell
suggestions	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  , suggestions :: forall m v a . Monad m$/;"	c_a	cons:ArgumentType.ArgumentType	line:38	language:Haskell
suggestions	./parser-typechecker/src/Unison/Typechecker.hs	/^             , suggestions  :: [Context.Suggestion v loc]$/;"	c_a	cons:Resolution.Resolution	line:171	language:Haskell
suggestions	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                , suggestions  :: [C.Suggestion v loc]$/;"	c_a	cons:TypeError.UnknownTerm	line:73	language:Haskell
suite1	./yaks/easytest/tests/Suite.hs	/^suite1 :: Test ()$/;"	ft	signature:(Test ())	line:7	language:Haskell
sum'	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^sum' :: [Int] -> Int$/;"	ft	signature:([Int] -> Int)	line:267	language:Haskell
surroundCommas	./parser-typechecker/src/Unison/Util/Pretty.hs	/^surroundCommas start stop fs =$/;"	fi	line:335	language:Haskell
swap	./unison-core/src/Unison/Util/Relation.hs	/^swap :: Relation a b -> Relation b a$/;"	ft	signature:(Relation a b -> Relation b a)	line:465	language:Haskell
symbol	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^symbol :: Text -> P Text$/;"	ft	signature:(Text -> P Text)	line:48	language:Haskell
symbol	./unison-core/src/Unison/Symbol.hs	/^symbol :: Text -> Symbol$/;"	ft	signature:(Text -> Symbol)	line:34	language:Haskell
symbolyDefinitionName	./parser-typechecker/src/Unison/Parser.hs	/^symbolyDefinitionName :: Var v => P v (L.Token v)$/;"	ft	signature:(Var v => P v (L.Token v))	line:330	language:Haskell
symbolyId	./parser-typechecker/src/Unison/Lexer.hs	/^symbolyId :: String -> Either Err (String, String)$/;"	ft	signature:(String -> Either Err (String, String))	line:653	language:Haskell
symbolyId'	./parser-typechecker/src/Unison/Lexer.hs	/^symbolyId' :: String -> Either Err (String, String)$/;"	ft	signature:(String -> Either Err (String, String))	line:662	language:Haskell
symbolyId0	./parser-typechecker/src/Unison/Lexer.hs	/^symbolyId0 :: String -> Either Err (String, String)$/;"	ft	signature:(String -> Either Err (String, String))	line:691	language:Haskell
symbolyIdChar	./parser-typechecker/src/Unison/Lexer.hs	/^symbolyIdChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:696	language:Haskell
symbolyIdChars	./parser-typechecker/src/Unison/Lexer.hs	/^symbolyIdChars :: Set Char$/;"	ft	signature:(Set Char)	line:699	language:Haskell
symbolyIdString	./parser-typechecker/src/Unison/Parser.hs	/^symbolyIdString :: Ord v => P v (L.Token String)$/;"	ft	signature:(Ord v => P v (L.Token String))	line:316	language:Haskell
symmetricDifference	./unison-core/src/Unison/Util/Set.hs	/^symmetricDifference :: Ord a => Set a -> Set a -> Set a$/;"	ft	signature:(Ord a => Set a -> Set a -> Set a)	line:5	language:Haskell
sync	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^sync exists serializeRaw serializeEdits b =$/;"	fi	line:477	language:Haskell
sync	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^sync exists serialize c = do$/;"	fi	line:134	language:Haskell
sync'	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^sync' exists serializeRaw serializeEdits b = Causal.sync exists$/;"	fi	line:489	language:Haskell
syncFromDirectory	./parser-typechecker/src/Unison/Codebase.hs	/^           , syncFromDirectory  :: FilePath -> m ()$/;"	c_a	cons:Codebase.Codebase	line:63	language:Haskell
syncRemoteRootBranch	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^syncRemoteRootBranch input repo b = do$/;"	fi	line:1953	language:Haskell
syncToDirectory	./parser-typechecker/src/Unison/Codebase.hs	/^           , syncToDirectory    :: FilePath -> Branch m -> m (Branch m)$/;"	c_a	cons:Codebase.Codebase	line:67	language:Haskell
syncToDirectory	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^syncToDirectory fmtV fmtA codebase localPath branch = do$/;"	fi	line:450	language:Haskell
syntax	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^syntax :: Element -> SyntaxText -> SyntaxText$/;"	ft	signature:(Element -> SyntaxText -> SyntaxText)	line:51	language:Haskell
syntaxToColor	./parser-typechecker/src/Unison/Util/Pretty.hs	/^syntaxToColor :: Pretty ST.SyntaxText -> Pretty ColorText$/;"	ft	signature:(Pretty ST.SyntaxText -> Pretty ColorText)	line:245	language:Haskell
synthesize	./parser-typechecker/src/Unison/Typechecker.hs	/^synthesize env t = let$/;"	fi	line:147	language:Haskell
synthesize	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^synthesize :: forall v loc . (Var v, Ord loc) => Term v loc -> M v loc (Type v loc)$/;"	ft	signature:(forall v loc . (Var v, Ord loc) => Term v loc -> M v loc (Type v loc))	line:823	language:Haskell
synthesizeAndResolve	./parser-typechecker/src/Unison/Typechecker.hs	/^synthesizeAndResolve env = do$/;"	fi	line:178	language:Haskell
synthesizeApp	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^synthesizeApp :: (Var v, Ord loc) => Type v loc -> (Term v loc, Int) -> M v loc (Type v loc)$/;"	ft	signature:((Var v, Ord loc) => Type v loc -> (Term v loc, Int) -> M v loc (Type v loc))	line:750	language:Haskell
synthesizeApps	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^synthesizeApps :: (Foldable f, Var v, Ord loc) => Type v loc -> f (Term v loc) -> M v loc (Type v loc)$/;"	ft	signature:((Foldable f, Var v, Ord loc) => Type v loc -> f (Term v loc) -> M v loc (Type v loc))	line:739	language:Haskell
synthesizeClosed	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^synthesizeClosed abilities lookupType term0 = let$/;"	fi	line:1650	language:Haskell
synthesizeClosed'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^synthesizeClosed' :: (Var v, Ord loc)$/;"	ft	signature:((Var v, Ord loc) => [Type v loc] -> Term v loc -> M v loc (Type v loc))	line:1702	language:Haskell
synthesizeFile	./parser-typechecker/src/Unison/FileParsers.hs	/^synthesizeFile ambient tl fqnsByShortName uf term = do$/;"	fi	line:128	language:Haskell
synthesizeFile'	./parser-typechecker/src/Unison/FileParsers.hs	/^synthesizeFile' ambient tl uf =$/;"	fi	line:116	language:Haskell
t	./parser-typechecker/tests/Unison/Test/Common.hs	/^t :: String -> Type Symbol$/;"	ft	signature:(String -> Type Symbol)	line:39	language:Haskell
t	./parser-typechecker/tests/Unison/Test/Lexer.hs	/^t :: String -> [Lexeme] -> Test ()$/;"	ft	signature:(String -> [Lexeme] -> Test ())	line:191	language:Haskell
t	./unison-core/src/Unison/Pattern.hs	/^pattern Text t = TextP () t$/;"	fi	line:104	language:Haskell
t1	./unison-core/src/Unison/ABT.hs	/^  t1 == t2 = go (out t1) (out t2) where$/;"	fi	instance:(Foldable f, Functor f, Eq1 f, Var v) => Eq (Term f v a)	line:532	language:Haskell
tabCompletion	./yaks/haskeline/tests/Unit.hs	/^tabCompletion i = "tab completion" ~:$/;"	fi	line:108	language:Haskell
table	./parser-typechecker/src/Unison/Util/CycleTable.hs	/^    table :: BasicHashTable k v,$/;"	c_a	cons:CycleTable.CycleTable	line:14	language:Haskell
taddedMetadata	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  taddedMetadata :: Relation3 r Name Metadata.Value,$/;"	c_a	cons:DiffSlice.DiffSlice	line:37	language:Haskell
tail	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^         , tail :: (RawHash h, m (Causal m h e))$/;"	c_a	cons:Causal.Cons	line:66	language:Haskell
tails	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^          , tails :: Map (RawHash h) (m (Causal m h e))$/;"	c_a	cons:Causal.Merge	line:71	language:Haskell
take	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  take n (AnnotatedText at) = case at of$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:64	language:Haskell
take	./parser-typechecker/src/Unison/Util/Bytes.hs	/^take :: Int -> Bytes -> Bytes$/;"	ft	signature:(Int -> Bytes -> Bytes)	line:50	language:Haskell
take	./unison-core/src/Unison/HashQualified'.hs	/^take :: Int -> HashQualified' n -> HashQualified' n$/;"	ft	signature:(Int -> HashQualified' n -> HashQualified' n)	line:47	language:Haskell
take	./unison-core/src/Unison/HashQualified.hs	/^take :: Int -> HashQualified' n -> HashQualified' n$/;"	ft	signature:(Int -> HashQualified' n -> HashQualified' n)	line:79	language:Haskell
take	./unison-core/src/Unison/ShortHash.hs	/^take :: Int -> ShortHash -> ShortHash$/;"	ft	signature:(Int -> ShortHash -> ShortHash)	line:73	language:Haskell
take1_	./parser-typechecker/src/Unison/Parser.hs	/^  take1_ (P.chunkToTokens proxy -> [])   = Nothing$/;"	fi	instance:P-Stream Input	line:160	language:Haskell
takeN_	./parser-typechecker/src/Unison/Parser.hs	/^  takeN_ n (P.chunkToTokens proxy -> []) | n > 0 = Nothing$/;"	fi	instance:P-Stream Input	line:164	language:Haskell
takeWhile	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  takeWhile f (AnnotatedText at) = case at of$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:52	language:Haskell
takeWhile	./parser-typechecker/src/Unison/Util/TQueue.hs	/^takeWhile :: (a -> Bool) -> TQueue a -> STM [a]$/;"	ft	signature:((a -> Bool) -> TQueue a -> STM [a])	line:79	language:Haskell
takeWhile_	./parser-typechecker/src/Unison/Parser.hs	/^  takeWhile_ p = join bimap (P.tokensToChunk proxy) . span p . inputStream$/;"	fi	instance:P-Stream Input	line:170	language:Haskell
takeWidth	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^takeWidth :: Int -> [Grapheme] -> ([Grapheme],Int)$/;"	ft	signature:(Int -> [Grapheme] -> ([Grapheme], Int))	line:48	language:Haskell
talladds	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  talladds :: Relation r Name,$/;"	c_a	cons:DiffSlice.DiffSlice	line:34	language:Haskell
tallnamespaceUpdates	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  tallnamespaceUpdates :: Map Name (Set r, Set r),$/;"	c_a	cons:DiffSlice.DiffSlice	line:33	language:Haskell
tallremoves	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  tallremoves :: Relation r Name,$/;"	c_a	cons:DiffSlice.DiffSlice	line:35	language:Haskell
tc	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^tc :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:65	language:Haskell
tc	./parser-typechecker/tests/Unison/Test/TypePrinter.hs	/^tc :: String -> Test ()$/;"	ft	signature:(String -> Test ())	line:51	language:Haskell
tcBinding	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^tcBinding :: Int -> String -> Maybe String -> String -> String -> Test ()$/;"	ft	signature:(Int -> String -> Maybe String -> String -> String -> Test ())	line:75	language:Haskell
tcBreaks	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^tcBreaks :: Int -> String -> Test ()$/;"	ft	signature:(Int -> String -> Test ())	line:72	language:Haskell
tcBreaksDiff	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^tcBreaksDiff :: Int -> String -> String -> Test ()$/;"	ft	signature:(Int -> String -> String -> Test ())	line:69	language:Haskell
tcDiff	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^tcDiff :: String -> String -> Test ()$/;"	ft	signature:(String -> String -> Test ())	line:60	language:Haskell
tcDiffRtt	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^tcDiffRtt :: Bool -> String -> String -> Int -> Test ()$/;"	ft	signature:(Bool -> String -> String -> Int -> Test ())	line:30	language:Haskell
tc_breaks	./parser-typechecker/tests/Unison/Test/TypePrinter.hs	/^tc_breaks :: String -> Int -> String -> Test ()$/;"	ft	signature:(String -> Int -> String -> Test ())	line:55	language:Haskell
tc_diff	./parser-typechecker/tests/Unison/Test/TypePrinter.hs	/^tc_diff :: String -> String -> Test ()$/;"	ft	signature:(String -> String -> Test ())	line:46	language:Haskell
tc_diff_rtt	./parser-typechecker/tests/Unison/Test/TypePrinter.hs	/^tc_diff_rtt :: Bool -> String -> String -> Int -> Test ()$/;"	ft	signature:(Bool -> String -> String -> Int -> Test ())	line:18	language:Haskell
tell1	./parser-typechecker/src/Unison/Result.hs	/^tell1 :: Monad f => note -> ResultT (Seq note) f ()$/;"	ft	signature:(Monad f => note -> ResultT (Seq note) f ())	line:73	language:Haskell
tellAndFail	./parser-typechecker/src/Unison/Result.hs	/^tellAndFail :: Monad f => note -> ResultT (Seq note) f a$/;"	ft	signature:(Monad f => note -> ResultT (Seq note) f a)	line:83	language:Haskell
tempGitDir	./parser-typechecker/src/Unison/Codebase/Editor/HandleCommand.hs	/^tempGitDir :: Text -> Maybe Text -> IO FilePath$/;"	ft	signature:(Text -> Maybe Text -> IO FilePath)	line:84	language:Haskell
term	./parser-typechecker/src/Unison/Runtime/ANF.hs	/^newtype ANF v a = ANF_ { term :: Term v a }$/;"	c_a	cons:ANF.ANF_	line:29	language:Haskell
term	./parser-typechecker/src/Unison/TermParser.hs	/^term :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:65	language:Haskell
term2	./parser-typechecker/src/Unison/TermParser.hs	/^term2 :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:68	language:Haskell
term3	./parser-typechecker/src/Unison/TermParser.hs	/^term3 :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:71	language:Haskell
term4	./parser-typechecker/src/Unison/TermParser.hs	/^term4 :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:630	language:Haskell
termAlias	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , termAlias :: Map v Aliases$/;"	c_a	cons:SlurpResult.SlurpResult	line:66	language:Haskell
termAliases	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^  , termAliases :: Set HashQualified$/;"	c_a	cons:TermResult.TermResult	line:24	language:Haskell
termAliases	./unison-core/src/Unison/Names2.hs	/^termAliases :: Ord n => Names' n -> n -> Referent -> Set n$/;"	ft	signature:(Ord n => Names' n -> n -> Referent -> Set n)	line:198	language:Haskell
termCol	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data TermPos = TermPos {termRow,termCol :: !Int}$/;"	c_a	cons:TermPos.TermPos	line:78	language:Haskell
termCollisions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  RefCollisions { termCollisions :: Relation Name Name$/;"	c_a	cons:RefCollisions.RefCollisions	line:831	language:Haskell
termCompletor	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^termCompletor :: Applicative m$/;"	ft	signature:(Applicative m => (String -> [String] -> [Completion]) -> String -> Codebase m v a -> Branch.Branch m -> Path.Absolute -> m [Completion])	line:1254	language:Haskell
termDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termDir, declDir :: CodebasePath -> Reference.Id -> FilePath$/;"	ft	signature:(CodebasePath -> Reference.Id -> FilePath)	line:193	language:Haskell
termEdits	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  { termEdits :: Map Reference TermEdit$/;"	c_a	cons:Edits.Edits	line:54	language:Haskell
termExistingConstructorCollisions	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , termExistingConstructorCollisions :: Set v$/;"	c_a	cons:SlurpResult.SlurpResult	line:63	language:Haskell
termLeaf	./parser-typechecker/src/Unison/TermParser.hs	/^termLeaf :: forall v . Var v => TermP v$/;"	ft	signature:(forall v . Var v => TermP v)	line:302	language:Haskell
termLink	./unison-core/src/Unison/Term.hs	/^termLink :: Ord v => a -> Referent -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Referent -> Term2 vt at ap v a)	line:473	language:Haskell
termLink	./unison-core/src/Unison/Type.hs	/^termLink :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:200	language:Haskell
termLink'	./parser-typechecker/src/Unison/TermParser.hs	/^termLink' :: Var v => P v (L.Token Referent)$/;"	ft	signature:(Var v => P v (L.Token Referent))	line:90	language:Haskell
termLinkRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
termLinkRef	./unison-core/src/Unison/Type.hs	/^termLinkRef = Reference.Builtin "Link.Term"$/;"	fi	line:222	language:Haskell
termName	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^  { termName    :: HashQualified$/;"	c_a	cons:TermResult.TermResult	line:22	language:Haskell
termName	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^termName :: PPE.PrettyPrintEnv -> Referent -> Pretty$/;"	ft	signature:(PPE.PrettyPrintEnv -> Referent -> Pretty)	line:88	language:Haskell
termName	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^termName :: PrettyPrintEnv -> Referent -> HashQualified$/;"	ft	signature:(PrettyPrintEnv -> Referent -> HashQualified)	line:101	language:Haskell
termName	./unison-core/src/Unison/Names3.hs	/^termName :: Int -> Referent -> Names -> Set HQ'.HashQualified$/;"	ft	signature:(Int -> Referent -> Names -> Set HQ'.HashQualified)	line:174	language:Haskell
termNameRefs	./parser-typechecker/src/Unison/Builtin.hs	/^termNameRefs :: Map Name R.Reference$/;"	ft	signature:(Map Name R.Reference)	line:197	language:Haskell
termNamed	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^termNamed :: String -> R.Reference$/;"	ft	signature:(String -> R.Reference)	line:44	language:Haskell
termOps	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            termOps :: Either TermOps FileOps,$/;"	c_a	cons:RunTerm.RunTerm	line:36	language:Haskell
termPath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termPath, typePath, declPath :: CodebasePath -> Reference.Id -> FilePath$/;"	ft	signature:(CodebasePath -> Reference.Id -> FilePath)	line:260	language:Haskell
termRef	./unison-core/src/Unison/LabeledDependency.hs	/^typeRef, termRef :: Reference -> LabeledDependency$/;"	ft	signature:(Reference -> LabeledDependency)	line:16	language:Haskell
termRef	./unison-core/src/Unison/LabeledDependency.hs	/^termRef = X . Right . Ref$/;"	fi	line:24	language:Haskell
termRefTypes	./parser-typechecker/src/Unison/Builtin.hs	/^termRefTypes :: Var v => Map R.Reference (Type v)$/;"	ft	signature:(Var v => Map R.Reference (Type v))	line:219	language:Haskell
termReferences	./unison-core/src/Unison/Names2.hs	/^termReferences, typeReferences, allReferences :: Names' n -> Set Reference$/;"	ft	signature:(Names' n -> Set Reference)	line:91	language:Haskell
termReferencesByPrefix	./parser-typechecker/src/Unison/Codebase.hs	/^           , termReferencesByPrefix :: ShortHash -> m (Set Reference.Id)$/;"	c_a	cons:Codebase.Codebase	line:85	language:Haskell
termReferencesByPrefix	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termReferencesByPrefix root = loadReferencesByPrefix (termsDir root)$/;"	fi	line:585	language:Haskell
termReferents	./unison-core/src/Unison/Names2.hs	/^termReferents :: Names' n -> Set Referent$/;"	ft	signature:(Names' n -> Set Referent)	line:96	language:Haskell
termReferentsByPrefix	./parser-typechecker/src/Unison/Codebase.hs	/^           , termReferentsByPrefix :: ShortHash -> m (Set (Referent' Reference.Id))$/;"	c_a	cons:Codebase.Codebase	line:87	language:Haskell
termReferentsByPrefix	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termReferentsByPrefix :: MonadIO m$/;"	ft	signature:(MonadIO m => (CodebasePath -> Reference.Id -> m (Maybe (DD.Decl v a))) -> CodebasePath -> ShortHash -> m (Set (Referent' Reference.Id)))	line:589	language:Haskell
termReplacements	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  , termReplacements :: Map Reference Reference$/;"	c_a	cons:Edits.Edits	line:56	language:Haskell
termResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^termResult :: HashQualified -> Referent -> Set HashQualified -> SearchResult$/;"	ft	signature:(HashQualified -> Referent -> Set HashQualified -> SearchResult)	line:36	language:Haskell
termSearchResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^termSearchResult :: Names0 -> Name -> Referent -> SearchResult$/;"	ft	signature:(Names0 -> Name -> Referent -> SearchResult)	line:39	language:Haskell
termSignatureExternalLabeledDependencies	./parser-typechecker/src/Unison/UnisonFile.hs	/^termSignatureExternalLabeledDependencies TypecheckedUnisonFile{..} =$/;"	fi	line:132	language:Haskell
termSite	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                , termSite     :: loc$/;"	c_a	cons:TypeError.UnknownTerm	line:72	language:Haskell
termVarAnnotations	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^       , termVarAnnotations :: Map v (Type v loc)$/;"	c_a	cons:Info.Info	line:332	language:Haskell
terminalRunTerm	./yaks/haskeline/System/Console/Haskeline/Backend.hs	/^terminalRunTerm :: IO RunTerm$/;"	ft	signature:(IO RunTerm)	line:24	language:Haskell
terminate	./parser-typechecker/src/Unison/Codebase/Runtime.hs	/^  { terminate :: IO ()$/;"	c_a	cons:Runtime.Runtime	line:29	language:Haskell
terminfoKeys	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^terminfoKeys :: Terminal -> [(String,Key)]$/;"	ft	signature:(Terminal -> [(String, Key)])	line:153	language:Haskell
terms	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^terms :: Lens' (Branch0 m) (Star Referent NameSegment)$/;"	ft	signature:(Lens' (Branch0 m) (Star Referent NameSegment))	line:276	language:Haskell
terms	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^  SlurpComponent { types :: Set v, terms :: Set v }$/;"	c_a	cons:SlurpComponent.SlurpComponent	line:17	language:Haskell
terms	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  terms :: Referent -> Maybe HashQualified,$/;"	c_a	cons:PrettyPrintEnv.PrettyPrintEnv	line:25	language:Haskell
terms	./parser-typechecker/src/Unison/UnisonFile.hs	/^  terms :: [(v, Term v a)],$/;"	c_a	cons:UnisonFile.UnisonFile	line:44	language:Haskell
terms	./unison-core/src/Unison/Names2.hs	/^  { terms :: Relation n Referent$/;"	c_a	cons:Names'.Names	line:70	language:Haskell
terms	./unison-core/src/Unison/Names3.hs	/^pattern Names0 terms types = Unison.Names2.Names terms types$/;"	fi	line:31	language:Haskell
terms0	./unison-core/src/Unison/Names3.hs	/^terms0 :: Names0 -> Relation Name Referent$/;"	ft	signature:(Names0 -> Relation Name Referent)	line:114	language:Haskell
termsDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  { termsDiff :: DiffSlice Referent$/;"	c_a	cons:BranchDiff.BranchDiff	line:42	language:Haskell
termsDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termsDir root = root <\/> "terms"$/;"	fi	line:187	language:Haskell
termsMentioningType	./parser-typechecker/src/Unison/Codebase.hs	/^termsMentioningType :: (Var v, Functor m) => Codebase m v a -> Type v a -> m (Set Referent.Referent)$/;"	ft	signature:((Var v, Functor m) => Codebase m v a -> Type v a -> m (Set Referent.Referent))	line:265	language:Haskell
termsMentioningTypeImpl	./parser-typechecker/src/Unison/Codebase.hs	/^           , termsMentioningTypeImpl :: Reference -> m (Set Referent)$/;"	c_a	cons:Codebase.Codebase	line:82	language:Haskell
termsNamed	./unison-core/src/Unison/Names2.hs	/^termsNamed :: Ord n => Names' n -> n -> Set Referent$/;"	ft	signature:(Ord n => Names' n -> n -> Set Referent)	line:182	language:Haskell
termsOfType	./parser-typechecker/src/Unison/Codebase.hs	/^termsOfType :: (Var v, Functor m) => Codebase m v a -> Type v a -> m (Set Referent.Referent)$/;"	ft	signature:((Var v, Functor m) => Codebase m v a -> Type v a -> m (Set Referent.Referent))	line:259	language:Haskell
termsOfTypeImpl	./parser-typechecker/src/Unison/Codebase.hs	/^           , termsOfTypeImpl    :: Reference -> m (Set Referent)$/;"	c_a	cons:Codebase.Codebase	line:80	language:Haskell
test	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^test :: InputPattern$/;"	ft	signature:(InputPattern)	line:1120	language:Haskell
test	./parser-typechecker/tests/Suite.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:33	language:Haskell
test	./parser-typechecker/tests/Unison/Test/ABT.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:11	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Codebase.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:20	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:86	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:9	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Codebase/Path.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:14	language:Haskell
test	./parser-typechecker/tests/Unison/Test/ColorText.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:16	language:Haskell
test	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:21	language:Haskell
test	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  test :: Test ()$/;"	ft	signature:(Test ())	line:53	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Git.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:19	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Lexer.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:6	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Range.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:8	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Referent.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:12	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Term.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:16	language:Haskell
test	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:193	language:Haskell
test	./parser-typechecker/tests/Unison/Test/TermPrinter.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:103	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Transcripts.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:20	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Type.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:16	language:Haskell
test	./parser-typechecker/tests/Unison/Test/TypePrinter.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:58	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Typechecker.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:11	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Typechecker/Components.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:10	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Typechecker/Context.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:15	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Typechecker/TypeError.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:20	language:Haskell
test	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:71	language:Haskell
test	./parser-typechecker/tests/Unison/Test/UriParser.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:17	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Util/Bytes.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:9	language:Haskell
test	./parser-typechecker/tests/Unison/Test/Var.hs	/^test :: Test ()$/;"	ft	signature:(Test ())	line:9	language:Haskell
test1	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  test1 :: Test ()$/;"	ft	signature:(Test ())	line:17	language:Haskell
test1	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^test1 :: Test ()$/;"	ft	signature:(Test ())	line:19	language:Haskell
test2	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  test2 :: Test ()$/;"	ft	signature:(Test ())	line:49	language:Haskell
test2	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^test2 :: Test ()$/;"	ft	signature:(Test ())	line:190	language:Haskell
testAugmented	./parser-typechecker/tests/Unison/Test/UriParser.hs	/^testAugmented:: Test ()$/;"	ft	signature:(Test ())	line:20	language:Haskell
testBareRepo	./parser-typechecker/tests/Unison/Test/Git.hs	/^testBareRepo :: Test ()$/;"	ft	signature:(Test ())	line:22	language:Haskell
testCommutative	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^testCommutative :: Set Int64 -> Causal Identity Hash (Set Int64) -> Bool$/;"	ft	signature:(Set Int64 -> Causal Identity Hash (Set Int64) -> Bool)	line:223	language:Haskell
testI	./yaks/haskeline/tests/RunTTY.hs	/^testI :: Invocation -> [B.ByteString] -> [B.ByteString] -> Test$/;"	ft	signature:(Invocation -> [B.ByteString] -> [B.ByteString] -> Test)	line:135	language:Haskell
testIdempotent	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^testIdempotent :: Causal Identity Hash (Set Int64) -> Bool -- Causal Identity Hash (Set Int64)$/;"	ft	signature:(Causal Identity Hash (Set Int64) -> Bool)	line:181	language:Haskell
testIdentity	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^testIdentity :: Causal Identity Hash (Set Int64) -> Causal Identity Hash (Set Int64) -> Bool$/;"	ft	signature:(Causal Identity Hash (Set Int64) -> Causal Identity Hash (Set Int64) -> Bool)	line:214	language:Haskell
testResultRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef :: Reference$/;"	ft	signature:(Reference)	line:409	language:Haskell
testResultType	./unison-core/src/Unison/DataDeclaration.hs	/^testResultType a = Type.app a (Type.vector a) (Type.ref a testResultRef)$/;"	fi	line:557	language:Haskell
testThreeWay	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^testThreeWay :: Causal Identity Hash (Set Int64)$/;"	ft	signature:(Causal Identity Hash (Set Int64))	line:167	language:Haskell
tests	./yaks/easytest/src/EasyTest.hs	/^tests :: [Test ()] -> Test ()$/;"	ft	signature:([Test ()] -> Test ())	line:85	language:Haskell
text	./parser-typechecker/src/Unison/TermParser.hs	/^text :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:270	language:Haskell
text	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  , text        :: String$/;"	c_a	cons:AnnotatedExcerpt.AnnotatedExcerpt	line:80	language:Haskell
text	./parser-typechecker/src/Unison/Util/Pretty.hs	/^text :: IsString s => Text -> Pretty s$/;"	ft	signature:(IsString s => Text -> Pretty s)	line:565	language:Haskell
text	./unison-core/src/Unison/Term.hs	/^text :: Ord v => a -> Text -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Text -> Term2 vt at ap v a)	line:494	language:Haskell
text	./unison-core/src/Unison/Type.hs	/^text :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:240	language:Haskell
textEmpty	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^textEmpty :: AnnotatedText a -> Bool$/;"	ft	signature:(AnnotatedText a -> Bool)	line:117	language:Haskell
textLength	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^textLength :: AnnotatedText a -> Int$/;"	ft	signature:(AnnotatedText a -> Int)	line:113	language:Haskell
textRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
textRef	./unison-core/src/Unison/Type.hs	/^textRef = Reference.Builtin "Text"$/;"	fi	line:217	language:Haskell
third	./unison-core/src/Unison/DataDeclaration.hs	/^third :: (a -> b) -> (x,y,a) -> (x,y,b)$/;"	ft	signature:((a -> b) -> (x, y, a) -> (x, y, b))	line:212	language:Haskell
threadIdId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^eitherLeftId, eitherRightId, someId, noneId, ioErrorId, handleId, socketId, threadIdId, epochTimeId, bufferModeLineId, bufferModeBlockId, filePathId :: DD.ConstructorId$/;"	ft	signature:(DD.ConstructorId)	line:92	language:Haskell
threadIdId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^threadIdId = constructorNamed threadIdReference "io.ThreadId.ThreadId"$/;"	fi	line:100	language:Haskell
threadIdReference	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^threadIdReference = typeNamed "io.ThreadId"$/;"	fi	line:78	language:Haskell
threeWayMerge	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^threeWayMerge combine = mergeInternal merge0$/;"	fi	line:213	language:Haskell
threeWayMerge'	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^threeWayMerge' = Causal.threeWayMerge (easyCombine setCombine setDiff setPatch)$/;"	fi	line:211	language:Haskell
throwHandleClosed	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^throwHandleClosed :: UIO a$/;"	ft	signature:(UIO a)	line:276	language:Haskell
throwIO	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^throwIO :: (MonadIO m, Exception e) => e -> m a$/;"	ft	signature:((MonadIO m, Exception e) => e -> m a)	line:127	language:Haskell
throwSocketClosed	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^throwSocketClosed :: UIO a$/;"	ft	signature:(UIO a)	line:279	language:Haskell
throwTo	./yaks/haskeline/System/Console/Haskeline/MonadException.hs	/^throwTo :: (MonadIO m, Exception e) => ThreadId -> e -> m ()$/;"	ft	signature:((MonadIO m, Exception e) => ThreadId -> e -> m ())	line:130	language:Haskell
tinfoLayout	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^tinfoLayout :: Terminal -> IO (Maybe Layout)$/;"	ft	signature:(Terminal -> IO (Maybe Layout))	line:147	language:Haskell
tip	./parser-typechecker/src/Unison/CommandLine.hs	/^tip :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s)	line:82	language:Haskell
tm	./parser-typechecker/tests/Unison/Test/Common.hs	/^tm :: String -> Term Symbol$/;"	ft	signature:(String -> Term Symbol)	line:47	language:Haskell
tm	./unison-core/src/Unison/ABT.hs	/^tm :: (Foldable f, Ord v) => f (Term f v ()) -> Term f v ()$/;"	ft	signature:((Foldable f, Ord v) => f (Term f v ()) -> Term f v ())	line:216	language:Haskell
tm'	./unison-core/src/Unison/ABT.hs	/^tm' :: (Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a$/;"	ft	signature:((Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a)	line:219	language:Haskell
tmReferent	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^tmReferent :: SearchResult' v a -> Maybe Referent$/;"	ft	signature:(SearchResult' v a -> Maybe Referent)	line:34	language:Haskell
to	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^    , to :: Hash$/;"	c_a	cons:Entry.Entry	line:14	language:Haskell
toABT	./unison-core/src/Unison/DataDeclaration.hs	/^toABT :: Var v => DataDeclaration v -> ABT.Term F v ()$/;"	ft	signature:(Var v => DataDeclaration v -> ABT.Term F v ())	line:330	language:Haskell
toANSI	./parser-typechecker/src/Unison/Util/ColorText.hs	/^toANSI :: ColorText -> String$/;"	ft	signature:(ColorText -> String)	line:63	language:Haskell
toANSI	./parser-typechecker/src/Unison/Util/Pretty.hs	/^toANSI :: Width -> Pretty CT.ColorText -> String$/;"	ft	signature:(Width -> Pretty CT.ColorText -> String)	line:230	language:Haskell
toAbsoluteSplit	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toAbsoluteSplit :: Absolute -> (Path', a) -> (Absolute, a)$/;"	ft	signature:(Absolute -> (Path', a) -> (Absolute, a))	line:213	language:Haskell
toAnsiUnbroken	./parser-typechecker/src/Unison/Util/Pretty.hs	/^toAnsiUnbroken :: Pretty ColorText -> String$/;"	ft	signature:(Pretty ColorText -> String)	line:233	language:Haskell
toBindings	./parser-typechecker/src/Unison/TermParser.hs	/^toBindings :: forall v . Var v => [BlockElement v] -> [((Ann,v), Term v Ann)]$/;"	ft	signature:(forall v . Var v => [BlockElement v] -> [((Ann, v), Term v Ann)])	line:766	language:Haskell
toByteString	./parser-typechecker/src/Unison/Util/Bytes.hs	/^toByteString :: Bytes -> B.ByteString$/;"	ft	signature:(Bytes -> B.ByteString)	line:30	language:Haskell
toBytes	./unison-core/src/Unison/Hash.hs	/^newtype Hash = Hash { toBytes :: ByteString } deriving (Eq,Ord,Generic)$/;"	c_a	cons:Hash.Hash	line:22	language:Haskell
toBytes	./unison-core/src/Unison/Hash.hs	/^  toBytes = toBytesImpl$/;"	fi	instance:H-Accumulate Hash	line:52	language:Haskell
toBytes	./unison-core/src/Unison/Hashable.hs	/^  toBytes :: h -> ByteString$/;"	ft	signature:(h -> ByteString)	class:Accumulate	line:22	language:Haskell
toBytesImpl	./unison-core/src/Unison/Hash.hs	/^toBytesImpl :: Hash -> ByteString$/;"	ft	signature:(Hash -> ByteString)	line:33	language:Haskell
toCodeLookup	./parser-typechecker/src/Unison/Codebase.hs	/^toCodeLookup :: Codebase m v a -> CL.CodeLookup v m a$/;"	ft	signature:(Codebase m v a -> CL.CodeLookup v m a)	line:189	language:Haskell
toDataDecl	./unison-core/src/Unison/DataDeclaration.hs	/^  toDataDecl :: DataDeclaration' v a$/;"	c_a	cons:EffectDeclaration'.EffectDeclaration	line:241	language:Haskell
toEither	./parser-typechecker/src/Unison/Result.hs	/^toEither :: Functor f => ResultT notes f a -> ExceptT notes f a$/;"	ft	signature:(Functor f => ResultT notes f a -> ExceptT notes f a)	line:69	language:Haskell
toGraph	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^toGraph seen c = case c of$/;"	fi	line:80	language:Haskell
toHQ	./unison-core/src/Unison/HashQualified'.hs	/^toHQ :: HashQualified' n -> HQ.HashQualified' n$/;"	ft	signature:(HashQualified' n -> HQ.HashQualified' n)	line:25	language:Haskell
toHTML	./parser-typechecker/src/Unison/Util/ColorText.hs	/^toHTML :: String -> ColorText -> String$/;"	ft	signature:(String -> ColorText -> String)	line:47	language:Haskell
toHTML	./parser-typechecker/src/Unison/Util/Pretty.hs	/^toHTML :: String -> Width -> Pretty CT.ColorText -> String$/;"	ft	signature:(String -> Width -> Pretty CT.ColorText -> String)	line:239	language:Haskell
toHandle	./parser-typechecker/src/Unison/Util/Logger.hs	/^toHandle :: Handle -> Logger$/;"	ft	signature:(Handle -> Logger)	line:41	language:Haskell
toHash	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^toHash :: ShortBranchHash -> Maybe Branch.Hash$/;"	ft	signature:(ShortBranchHash -> Maybe Branch.Hash)	line:17	language:Haskell
toHash	./unison-core/src/Unison/HashQualified'.hs	/^toHash :: HashQualified' n -> Maybe ShortHash$/;"	ft	signature:(HashQualified' n -> Maybe ShortHash)	line:55	language:Haskell
toHash	./unison-core/src/Unison/HashQualified.hs	/^toHash :: HashQualified' n -> Maybe ShortHash$/;"	ft	signature:(HashQualified' n -> Maybe ShortHash)	line:63	language:Haskell
toIR	./parser-typechecker/src/Unison/Runtime/IR.hs	/^toIR :: CompilationEnv e cont -> R.Reference -> Maybe (IR e cont)$/;"	ft	signature:(CompilationEnv e cont -> R.Reference -> Maybe (IR e cont))	line:55	language:Haskell
toIR'	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  = CompilationEnv { toIR' :: Map R.Reference (IR e cont)$/;"	c_a	cons:CompilationEnv.CompilationEnv	line:52	language:Haskell
toLetRec	./unison-core/src/Unison/DataDeclaration.hs	/^toLetRec :: Ord v => [(v, ABT.Term F v ())] -> [ABT.Term F v ()]$/;"	ft	signature:(Ord v => [(v, ABT.Term F v ())] -> [ABT.Term F v ()])	line:317	language:Haskell
toList	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toList :: Path -> [NameSegment]$/;"	ft	signature:(Path -> [NameSegment])	line:237	language:Haskell
toList	./parser-typechecker/src/Unison/Runtime/Vector.hs	/^toList :: Vec a -> [a]$/;"	ft	signature:(Vec a -> [a])	line:50	language:Haskell
toList	./parser-typechecker/src/Unison/Util/Star3.hs	/^toList :: (Ord fact, Ord d1, Ord d2, Ord d3)$/;"	ft	signature:((Ord fact, Ord d1, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d1, d2, d3)])	line:21	language:Haskell
toList	./unison-core/src/Unison/Util/Relation.hs	/^toList :: Relation a b -> [(a, b)]$/;"	ft	signature:(Relation a b -> [(a, b)])	line:71	language:Haskell
toList	./unison-core/src/Unison/Util/Relation3.hs	/^toList :: Relation3 a b c -> [(a,b,c)]$/;"	ft	signature:(Relation3 a b c -> [(a, b, c)])	line:52	language:Haskell
toList	./unison-core/src/Unison/Util/Relation4.hs	/^toList :: Relation4 a b c d -> [(a,b,c,d)]$/;"	ft	signature:(Relation4 a b c d -> [(a, b, c, d)])	line:38	language:Haskell
toList0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^toList0 :: Branch0 m -> [(Path, Branch0 m)]$/;"	ft	signature:(Branch0 m -> [(Path, Branch0 m)])	line:416	language:Haskell
toMap	./unison-core/src/Unison/Util/Relation.hs	/^toMap :: Ord a => Relation a b -> Maybe (Map a b)$/;"	ft	signature:(Ord a => Relation a b -> Maybe (Map a b))	line:455	language:Haskell
toMaybe	./parser-typechecker/src/Unison/Codebase/Editor/DisplayThing.hs	/^toMaybe :: DisplayThing a -> Maybe a$/;"	ft	signature:(DisplayThing a -> Maybe a)	line:8	language:Haskell
toMaybe	./parser-typechecker/src/Unison/Result.hs	/^toMaybe :: Functor f => ResultT note f a -> f (Maybe a)$/;"	ft	signature:(Functor f => ResultT note f a -> f (Maybe a))	line:59	language:Haskell
toMultimap	./unison-core/src/Unison/Util/Relation.hs	/^toMultimap :: Relation a b -> Map a (Set b)$/;"	ft	signature:(Relation a b -> Map a (Set b))	line:451	language:Haskell
toName	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toName :: Path -> Name$/;"	ft	signature:(Path -> Name)	line:297	language:Haskell
toName	./unison-core/src/Unison/Codebase/NameSegment.hs	/^toName :: NameSegment -> Name.Name$/;"	ft	signature:(NameSegment -> Name.Name)	line:33	language:Haskell
toName	./unison-core/src/Unison/HashQualified'.hs	/^toName :: HashQualified' n -> n$/;"	ft	signature:(HashQualified' n -> n)	line:39	language:Haskell
toName	./unison-core/src/Unison/HashQualified.hs	/^toName :: HashQualified' n -> Maybe n$/;"	ft	signature:(HashQualified' n -> Maybe n)	line:38	language:Haskell
toName'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toName' :: Path' -> Name$/;"	ft	signature:(Path' -> Name)	line:301	language:Haskell
toNameOnly	./unison-core/src/Unison/HashQualified'.hs	/^toNameOnly :: HashQualified' n -> HashQualified' n$/;"	ft	signature:(HashQualified' n -> HashQualified' n)	line:52	language:Haskell
toNames	./parser-typechecker/src/Unison/UnisonFile.hs	/^toNames :: Var v => UnisonFile v a -> Names0$/;"	ft	signature:(Var v => UnisonFile v a -> Names0)	line:187	language:Haskell
toNames0	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^toNames0 :: Branch0 m -> Names0$/;"	ft	signature:(Branch0 m -> Names0)	line:213	language:Haskell
toNames0	./unison-core/src/Unison/DataDeclaration.hs	/^toNames0 :: Var v => CT.ConstructorType -> v -> Reference -> DataDeclaration' v a -> Names0$/;"	ft	signature:(Var v => CT.ConstructorType -> v -> Reference -> DataDeclaration' v a -> Names0)	line:216	language:Haskell
toNestedList	./unison-core/src/Unison/Util/Relation3.hs	/^toNestedList :: Relation3 a b c -> [(a,(b,c))]$/;"	ft	signature:(Relation3 a b c -> [(a, (b, c))])	line:55	language:Haskell
toNestedList	./unison-core/src/Unison/Util/Relation4.hs	/^toNestedList :: Relation4 a b c d -> [(a,(b,(c,d)))]$/;"	ft	signature:(Relation4 a b c d -> [(a, (b, (c, d)))])	line:32	language:Haskell
toOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^toOutput :: forall m v a$/;"	ft	signature:(forall m v a . Monad m => (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (DeclOrBuiltin v a))) -> Int -> Names0 -> Names0 -> PPE.PrettyPrintEnv -> BranchDiff.BranchDiff -> m (BranchDiffOutput v a))	line:99	language:Haskell
toOutput	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^toOutput typeOf declOrBuiltin hqLen names1 names2 ppe$/;"	fi	line:109	language:Haskell
toPath'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toPath' :: Path -> Path'$/;"	ft	signature:(Path -> Path')	line:232	language:Haskell
toPlain	./parser-typechecker/src/Unison/Util/ColorText.hs	/^toPlain :: ColorText -> String$/;"	ft	signature:(ColorText -> String)	line:59	language:Haskell
toPlain	./parser-typechecker/src/Unison/Util/Pretty.hs	/^toPlain :: Width -> Pretty CT.ColorText -> String$/;"	ft	signature:(Width -> Pretty CT.ColorText -> String)	line:236	language:Haskell
toPlain	./parser-typechecker/src/Unison/Util/SyntaxText.hs	/^toPlain :: SyntaxText -> String$/;"	ft	signature:(SyntaxText -> String)	line:55	language:Haskell
toPlainUnbroken	./parser-typechecker/src/Unison/Util/Pretty.hs	/^toPlainUnbroken :: Pretty ColorText -> String$/;"	ft	signature:(Pretty ColorText -> String)	line:242	language:Haskell
toReference	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^toReference :: TermEdit -> Maybe Reference$/;"	ft	signature:(TermEdit -> Maybe Reference)	line:32	language:Haskell
toReference	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^toReference :: TypeEdit -> Maybe Reference$/;"	ft	signature:(TypeEdit -> Maybe Reference)	line:18	language:Haskell
toReference	./unison-core/src/Unison/Referent.hs	/^toReference :: Referent -> Reference$/;"	ft	signature:(Referent -> Reference)	line:75	language:Haskell
toReference	./unison-core/src/Unison/Type.hs	/^toReference :: (ABT.Var v, Show v) => Type v a -> Reference$/;"	ft	signature:((ABT.Var v, Show v) => Type v a -> Reference)	line:570	language:Haskell
toReferenceMentions	./unison-core/src/Unison/Type.hs	/^toReferenceMentions :: (ABT.Var v, Show v) => Type v a -> Set Reference$/;"	ft	signature:((ABT.Var v, Show v) => Type v a -> Set Reference)	line:576	language:Haskell
toReferent	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^toReferent :: SearchResult -> Referent$/;"	ft	signature:(SearchResult -> Referent)	line:61	language:Haskell
toRelation	./parser-typechecker/src/Unison/Codebase/Metadata.hs	/^toRelation :: Star3 a n x y -> Relation a n$/;"	ft	signature:(Star3 a n x y -> Relation a n)	line:62	language:Haskell
toResult	./yaks/haskeline/System/Console/Haskeline/Command/History.hs	/^    toResult = toResult . foundHistory$/;"	fi	instance:Result SearchMode	line:98	language:Haskell
toResult	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    toResult :: s -> String$/;"	ft	signature:(s -> String)	class:Result	line:171	language:Haskell
toResult	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    toResult (IMode xs ys) = graphemesToString $ reverse xs ++ ys$/;"	fi	instance:Result InsertMode	line:196	language:Haskell
toResult	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    toResult CEmpty = ""$/;"	fi	instance:Result CommandMode	line:275	language:Haskell
toResult	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    toResult = toResult . argState$/;"	fi	instance:Result s => Result (ArgMode s)	line:352	language:Haskell
toResult	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^    toResult = reverse . passwordState$/;"	fi	instance:Result Password	line:398	language:Haskell
toSeq	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Path = Path { toSeq :: Seq NameSegment } deriving (Eq, Ord)$/;"	c_a	cons:Path.Path	line:30	language:Haskell
toSet	./unison-core/src/Unison/Util/Relation.hs	/^toSet :: (Ord a, Ord b) => Relation a b -> S.Set (a, b)$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> S.Set (a, b))	line:76	language:Haskell
toShortHash	./unison-core/src/Unison/Reference.hs	/^toShortHash :: Reference -> ShortHash$/;"	ft	signature:(Reference -> ShortHash)	line:63	language:Haskell
toShortHash	./unison-core/src/Unison/Referent.hs	/^toShortHash :: Referent -> ShortHash$/;"	ft	signature:(Referent -> ShortHash)	line:39	language:Haskell
toSlurpResult	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^toSlurpResult currentPath uf existingNames =$/;"	fi	line:2092	language:Haskell
toStandardError	./parser-typechecker/src/Unison/Util/Logger.hs	/^toStandardError :: Logger$/;"	ft	signature:(Logger)	line:44	language:Haskell
toStandardOut	./parser-typechecker/src/Unison/Util/Logger.hs	/^toStandardOut :: Logger$/;"	ft	signature:(Logger)	line:47	language:Haskell
toString	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^toString :: ShortBranchHash -> String$/;"	ft	signature:(ShortBranchHash -> String)	line:14	language:Haskell
toString	./unison-core/src/Unison/Codebase/NameSegment.hs	/^toString :: NameSegment -> String$/;"	ft	signature:(NameSegment -> String)	line:30	language:Haskell
toString	./unison-core/src/Unison/HashQualified'.hs	/^toString :: Show n => HashQualified' n -> String$/;"	ft	signature:(Show n => HashQualified' n -> String)	line:60	language:Haskell
toString	./unison-core/src/Unison/HashQualified.hs	/^toString :: Show n => HashQualified' n -> String$/;"	ft	signature:(Show n => HashQualified' n -> String)	line:85	language:Haskell
toString	./unison-core/src/Unison/Name.hs	/^toString :: Name -> String$/;"	ft	signature:(Name -> String)	line:69	language:Haskell
toString	./unison-core/src/Unison/Referent.hs	/^toString :: Referent -> String$/;"	ft	signature:(Referent -> String)	line:63	language:Haskell
toString	./unison-core/src/Unison/ShortHash.hs	/^toString :: ShortHash -> String$/;"	ft	signature:(ShortHash -> String)	line:67	language:Haskell
toSymbolC	./parser-typechecker/src/Unison/Runtime/IR.hs	/^toSymbolC :: Symbol -> SymbolC$/;"	ft	signature:(Symbol -> SymbolC)	line:72	language:Haskell
toTermOrError	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^toTermOrError :: PPE.PrettyPrintEnv -> Either SomeException RT.Result$/;"	ft	signature:(PPE.PrettyPrintEnv -> Either SomeException RT.Result -> IO (Either (P.Pretty P.ColorText) (IR.Term Symbol)))	line:483	language:Haskell
toTermReference	./unison-core/src/Unison/Referent.hs	/^toTermReference :: Referent -> Maybe Reference$/;"	ft	signature:(Referent -> Maybe Reference)	line:70	language:Haskell
toText	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toText :: Path -> Text$/;"	ft	signature:(Path -> Text)	line:323	language:Haskell
toText	./parser-typechecker/src/Unison/Codebase/Reflog.hs	/^toText :: Entry -> Text$/;"	ft	signature:(Entry -> Text)	line:26	language:Haskell
toText	./parser-typechecker/src/Unison/Codebase/ShortBranchHash.hs	/^  ShortBranchHash { toText :: Text } -- base32hex characters$/;"	c_a	cons:ShortBranchHash.ShortBranchHash	line:11	language:Haskell
toText	./unison-core/src/Unison/Codebase/NameSegment.hs	/^newtype NameSegment = NameSegment { toText :: Text } deriving (Eq, Ord)$/;"	c_a	cons:NameSegment.NameSegment	line:18	language:Haskell
toText	./unison-core/src/Unison/HashQualified'.hs	/^toText :: Show n => HashQualified' n -> Text$/;"	ft	signature:(Show n => HashQualified' n -> Text)	line:77	language:Haskell
toText	./unison-core/src/Unison/HashQualified.hs	/^toText :: Show n => HashQualified' n -> Text$/;"	ft	signature:(Show n => HashQualified' n -> Text)	line:107	language:Haskell
toText	./unison-core/src/Unison/Name.hs	/^newtype Name = Name { toText :: Text } deriving (Eq, Ord)$/;"	c_a	cons:Name.Name	line:37	language:Haskell
toText	./unison-core/src/Unison/Reference.hs	/^toText :: Reference -> Text$/;"	ft	signature:(Reference -> Text)	line:104	language:Haskell
toText	./unison-core/src/Unison/Referent.hs	/^toText :: Referent -> Text$/;"	ft	signature:(Referent -> Text)	line:51	language:Haskell
toText	./unison-core/src/Unison/ShortHash.hs	/^toText :: ShortHash -> Text$/;"	ft	signature:(ShortHash -> Text)	line:60	language:Haskell
toText'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^toText' :: Path' -> Text$/;"	ft	signature:(Path' -> Text)	line:326	language:Haskell
toTypeReference	./unison-core/src/Unison/Referent.hs	/^toTypeReference :: Referent -> Maybe Reference$/;"	ft	signature:(Referent -> Maybe Reference)	line:80	language:Haskell
toUnzippedMultimap	./unison-core/src/Unison/Util/Relation.hs	/^toUnzippedMultimap ::$/;"	ft	signature:(Ord a => Ord b => Ord c => Relation a (b, c) -> Map a (Set b, Set c))	line:482	language:Haskell
toVar	./unison-core/src/Unison/HashQualified.hs	/^toVar :: Var v => HashQualified -> v$/;"	ft	signature:(Var v => HashQualified -> v)	line:139	language:Haskell
toVar	./unison-core/src/Unison/Name.hs	/^toVar :: Var v => Name -> v$/;"	ft	signature:(Var v => Name -> v)	line:63	language:Haskell
toWord8s	./parser-typechecker/src/Unison/Util/Bytes.hs	/^toWord8s :: Bytes -> [Word8]$/;"	ft	signature:(Bytes -> [Word8])	line:71	language:Haskell
todo	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^todo :: InputPattern$/;"	ft	signature:(InputPattern)	line:89	language:Haskell
todoFrontier	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^  , todoFrontier ::$/;"	c_a	cons:TodoOutput.TodoOutput	line:25	language:Haskell
todoFrontierDependents	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^  , todoFrontierDependents ::$/;"	c_a	cons:TodoOutput.TodoOutput	line:28	language:Haskell
todoHashLength	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^todoHashLength :: Int$/;"	ft	signature:(Int)	line:99	language:Haskell
todoOutput	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^todoOutput :: Var v => PPE.PrettyPrintEnvDecl -> TO.TodoOutput v a -> Pretty$/;"	ft	signature:(Var v => PPE.PrettyPrintEnvDecl -> TO.TodoOutput v a -> Pretty)	line:1207	language:Haskell
todoScore	./parser-typechecker/src/Unison/Codebase/Editor/TodoOutput.hs	/^  { todoScore :: Score$/;"	c_a	cons:TodoOutput.TodoOutput	line:24	language:Haskell
tok	./parser-typechecker/src/Unison/Parser.hs	/^tok :: (Ann -> a -> b) -> L.Token a -> b$/;"	ft	signature:((Ann -> a -> b) -> L.Token a -> b)	line:209	language:Haskell
tokenAsErrorSite	./parser-typechecker/src/Unison/PrintError.hs	/^tokenAsErrorSite :: String -> L.Token a -> Pretty ColorText$/;"	ft	signature:(String -> L.Token a -> Pretty ColorText)	line:1148	language:Haskell
tokenToChunk	./parser-typechecker/src/Unison/Parser.hs	/^  tokenToChunk pxy = P.tokensToChunk pxy . pure$/;"	fi	instance:P-Stream Input	line:141	language:Haskell
tokenToPair	./parser-typechecker/src/Unison/Parser.hs	/^tokenToPair :: L.Token a -> (Ann, a)$/;"	ft	signature:(L.Token a -> (Ann, a))	line:131	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^  tokens b =$/;"	fi	instance:Hashable (Branch0 m)	line:758	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^  tokens (RawHash h) = Hashable.tokens h$/;"	fi	instance:Hashable (RawHash h)	line:163	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/NameEdit.hs	/^  tokens (NameEdit added removed) = tokens (toList added, toList removed)$/;"	fi	instance:Hashable NameEdit	line:15	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^  tokens e = [ H.Hashed (H.accumulate (H.tokens (_termEdits e))),$/;"	fi	instance:Hashable Patch	line:124	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^  tokens Same = [H.Tag 0]$/;"	fi	instance:Hashable Typing	line:24	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^  tokens (Replace r t) = [H.Tag 0] ++ H.tokens r ++ H.tokens t$/;"	fi	instance:Hashable TermEdit	line:29	language:Haskell
tokens	./parser-typechecker/src/Unison/Codebase/TypeEdit.hs	/^  tokens (Replace r) = H.Tag 0 : H.tokens r$/;"	fi	instance:Hashable TypeEdit	line:15	language:Haskell
tokens	./parser-typechecker/src/Unison/Util/Star3.hs	/^  tokens s =$/;"	fi	instance:(H-Hashable fact, H-Hashable d1, H-Hashable d2, H-Hashable d3) => H-Hashable (Star3 fact d1 d2 d3)	line:200	language:Haskell
tokens	./unison-core/src/Unison/Codebase/NameSegment.hs	/^  tokens s = [H.Text (toText s)]$/;"	fi	instance:H-Hashable NameSegment	line:22	language:Haskell
tokens	./unison-core/src/Unison/ConstructorType.hs	/^  tokens b = [Tag . fromIntegral $ fromEnum b]$/;"	fi	instance:Hashable ConstructorType	line:8	language:Haskell
tokens	./unison-core/src/Unison/DataDeclaration.hs	/^  tokens Structural = [Hashable.Tag 0]$/;"	fi	instance:Hashable-Hashable Modifier	line:297	language:Haskell
tokens	./unison-core/src/Unison/Hash.hs	/^  tokens h = [H.Bytes (toBytes h)]$/;"	fi	instance:H-Hashable Hash	line:28	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens :: Accumulate h => t -> [Token h]$/;"	ft	signature:(Accumulate h => t -> [Token h])	class:Hashable	line:31	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens = map accumulateToken$/;"	fi	instance:Hashable a => Hashable [a]	line:34	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens (a,b) = [accumulateToken a, accumulateToken b]$/;"	fi	instance:(Hashable a, Hashable b) => Hashable (a, b)	line:37	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens = tokens . Set.toList$/;"	fi	instance:(Hashable a) => Hashable (Set-Set a)	line:40	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens = tokens . Map.toList$/;"	fi	instance:(Hashable k, Hashable v) => Hashable (Map-Map k v)	line:43	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens _ = []$/;"	fi	instance:Hashable ()	line:75	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens d = [Double d]$/;"	fi	instance:Hashable Double	line:78	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens s = [Text s]$/;"	fi	instance:Hashable Text	line:81	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens c = [Nat $ fromIntegral $ fromEnum c]$/;"	fi	instance:Hashable Char	line:84	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens bs = [Bytes bs]$/;"	fi	instance:Hashable ByteString	line:87	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens w = [Nat w]$/;"	fi	instance:Hashable Word64	line:90	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens w = [Int w]$/;"	fi	instance:Hashable Int64	line:93	language:Haskell
tokens	./unison-core/src/Unison/Hashable.hs	/^  tokens b = [Tag . fromIntegral $ fromEnum b]$/;"	fi	instance:Hashable Bool	line:96	language:Haskell
tokens	./unison-core/src/Unison/Kind.hs	/^  tokens k = case k of$/;"	fi	instance:Hashable Kind	line:13	language:Haskell
tokens	./unison-core/src/Unison/Name.hs	/^  tokens s = [H.Text (toText s)]$/;"	fi	instance:H-Hashable Name	line:138	language:Haskell
tokens	./unison-core/src/Unison/Pattern.hs	/^  tokens Cons = [H.Tag 0]$/;"	fi	instance:H-Hashable SeqOp	line:59	language:Haskell
tokens	./unison-core/src/Unison/Pattern.hs	/^  tokens (UnboundP _) = [H.Tag 0]$/;"	fi	instance:H-Hashable (PatternP p)	line:114	language:Haskell
tokens	./unison-core/src/Unison/Reference.hs	/^  tokens (Builtin txt) = [Hashable.Tag 0, Hashable.Text txt]$/;"	fi	instance:Hashable-Hashable Reference	line:173	language:Haskell
tokens	./unison-core/src/Unison/Referent.hs	/^  tokens (Ref r) = [H.Tag 0] ++ H.tokens r$/;"	fi	instance:Hashable Referent	line:116	language:Haskell
tokens	./unison-core/src/Unison/Util/Relation.hs	/^  tokens = H.tokens . toList$/;"	fi	instance:(H-Hashable a, H-Hashable b) => H-Hashable (Relation a b)	line:480	language:Haskell
tokens	./unison-core/src/Unison/Util/Relation3.hs	/^  tokens s = [ H.accumulateToken $ toNestedList s ]$/;"	fi	instance:(H-Hashable d1, H-Hashable d2, H-Hashable d3) => H-Hashable (Relation3 d1 d2 d3)	line:120	language:Haskell
tokens	./unison-core/src/Unison/Util/Relation4.hs	/^  tokens s = [ H.accumulateToken $ toNestedList s ]$/;"	fi	instance:(H-Hashable d1, H-Hashable d2, H-Hashable d3, H-Hashable d4) => H-Hashable (Relation4 d1 d2 d3 d4)	line:122	language:Haskell
tokensAsErrorSite	./parser-typechecker/src/Unison/PrintError.hs	/^tokensAsErrorSite :: String -> [L.Token a] -> Pretty ColorText$/;"	ft	signature:(String -> [L.Token a] -> Pretty ColorText)	line:1151	language:Haskell
tokensToChunk	./parser-typechecker/src/Unison/Parser.hs	/^  tokensToChunk _ = Input$/;"	fi	instance:P-Stream Input	line:143	language:Haskell
top	./parser-typechecker/src/Unison/Lexer.hs	/^top :: Layout -> Column$/;"	ft	signature:(Layout -> Column)	line:147	language:Haskell
topBlockName	./parser-typechecker/src/Unison/Lexer.hs	/^topBlockName :: Layout -> Maybe BlockName$/;"	ft	signature:(Layout -> Maybe BlockName)	line:152	language:Haskell
topHasClosePair	./parser-typechecker/src/Unison/Lexer.hs	/^topHasClosePair :: Layout -> Bool$/;"	ft	signature:(Layout -> Bool)	line:156	language:Haskell
topLeftCorner	./parser-typechecker/src/Unison/Lexer.hs	/^topLeftCorner :: Pos$/;"	ft	signature:(Pos)	line:169	language:Haskell
topLevelComponent	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^topLevelComponent = extractor go$/;"	fi	line:303	language:Haskell
topLevelComponent	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^topLevelComponent :: Ex.InfoExtractor v a (TypeInfo v a)$/;"	ft	signature:(Ex.InfoExtractor v a (TypeInfo v a))	line:124	language:Haskell
topLevelComponents	./parser-typechecker/src/Unison/UnisonFile.hs	/^topLevelComponents :: TypecheckedUnisonFile v a$/;"	ft	signature:(TypecheckedUnisonFile v a -> [[ (v, Term v a, Type v a) ]])	line:119	language:Haskell
topLevelComponents'	./parser-typechecker/src/Unison/UnisonFile.hs	/^    topLevelComponents' :: [[(v, Term v a, Type v a)]],$/;"	c_a	cons:TypecheckedUnisonFile.TypecheckedUnisonFile	line:84	language:Haskell
topicNameArg	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^topicNameArg :: ArgumentType$/;"	ft	signature:(ArgumentType)	line:881	language:Haskell
touchIdFile	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^touchIdFile :: Reference.Id -> FilePath -> IO ()$/;"	ft	signature:(Reference.Id -> FilePath -> IO ())	line:274	language:Haskell
touchReferentFile	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^touchReferentFile :: Referent -> FilePath -> IO ()$/;"	ft	signature:(Referent -> FilePath -> IO ())	line:283	language:Haskell
touches	./parser-typechecker/src/Unison/Lexer.hs	/^touches :: Token a -> Token b -> Bool$/;"	ft	signature:(Token a -> Token b -> Bool)	line:140	language:Haskell
tpReference	./parser-typechecker/src/Unison/Codebase/Editor/SearchResult'.hs	/^tpReference :: SearchResult' v a -> Maybe Reference$/;"	ft	signature:(SearchResult' v a -> Maybe Reference)	line:36	language:Haskell
trace	./parser-typechecker/src/Unison/Util/Logger.hs	/^error, warn, info, debug, trace :: Logger -> String -> IO ()$/;"	ft	signature:(Logger -> String -> IO ())	line:81	language:Haskell
trace	./parser-typechecker/src/Unison/Util/Logger.hs	/^trace l = logAt l traceLevel$/;"	fi	line:86	language:Haskell
trace'	./parser-typechecker/src/Unison/Util/Logger.hs	/^error', warn', info', debug', trace' :: Logger -> IO String -> IO ()$/;"	ft	signature:(Logger -> IO String -> IO ())	line:88	language:Haskell
trace'	./parser-typechecker/src/Unison/Util/Logger.hs	/^trace' l = logAt' l traceLevel$/;"	fi	line:93	language:Haskell
traceLevel	./parser-typechecker/src/Unison/Util/Logger.hs	/^errorLevel, warnLevel, infoLevel, debugLevel, traceLevel :: Level$/;"	ft	signature:(Level)	line:95	language:Haskell
traceNote	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^traceNote s ex = extractor $ \\n ->$/;"	fi	line:51	language:Haskell
traceRemainingTokens	./parser-typechecker/src/Unison/Parser.hs	/^traceRemainingTokens :: Ord v => String -> P v ()$/;"	ft	signature:(Ord v => String -> P v ())	line:198	language:Haskell
traceSubseq	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^traceSubseq :: Show a => String -> SubseqExtractor' n a -> SubseqExtractor' n a$/;"	ft	signature:(Show a => String -> SubseqExtractor' n a -> SubseqExtractor' n a)	line:44	language:Haskell
trailingNewLine	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^trailingNewLine :: AnnotatedText a -> Bool$/;"	ft	signature:(AnnotatedText a -> Bool)	line:98	language:Haskell
transcriptFailure	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^transcriptFailure :: IORef (Seq String) -> Text -> IO b$/;"	ft	signature:(IORef (Seq String) -> Text -> IO b)	line:280	language:Haskell
transform	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^transform :: Functor m => (forall a . m a -> n a) -> Causal m h e -> Causal n h e$/;"	ft	signature:(Functor m => (forall a . m a -> n a) -> Causal m h e -> Causal n h e)	line:330	language:Haskell
transform	./unison-core/src/Unison/ABT.hs	/^transform :: (Ord v, Foldable g, Functor f)$/;"	ft	signature:((Ord v, Foldable g, Functor f) => (forall a. f a -> g a) -> Term f v a -> Term g v a)	line:477	language:Haskell
transitiveClosure	./parser-typechecker/src/Unison/Util/TransitiveClosure.hs	/^transitiveClosure :: forall m a. (Monad m, Ord a)$/;"	ft	signature:(forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> Set a -> m (Set a))	line:10	language:Haskell
transitiveClosure1	./parser-typechecker/src/Unison/Util/TransitiveClosure.hs	/^transitiveClosure1 :: forall m a. (Monad m, Ord a)$/;"	ft	signature:(forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> a -> m (Set a))	line:25	language:Haskell
transitiveClosure1'	./parser-typechecker/src/Unison/Util/TransitiveClosure.hs	/^transitiveClosure1' :: Ord a => (a -> Set a) -> a -> Set a$/;"	ft	signature:(Ord a => (a -> Set a) -> a -> Set a)	line:29	language:Haskell
transitiveDependencies	./parser-typechecker/src/Unison/Codebase.hs	/^transitiveDependencies code seen0 r = if Set.member r seen0$/;"	fi	line:166	language:Haskell
transliterateFailure	./yaks/haskeline/System/Console/Haskeline/Recover.hs	/^transliterateFailure :: TextEncoding -> TextEncoding$/;"	ft	signature:(TextEncoding -> TextEncoding)	line:6	language:Haskell
transposeChars	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^transposeChars :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:242	language:Haskell
tree	./parser-typechecker/src/Unison/Lexer.hs	/^tree :: [Token Lexeme] -> T (Token Lexeme)$/;"	ft	signature:([Token Lexeme] -> T (Token Lexeme))	line:193	language:Haskell
treeishSuffix	./parser-typechecker/src/Unison/Codebase/Editor/UriParser.hs	/^treeishSuffix :: P Text$/;"	ft	signature:(P Text)	line:157	language:Haskell
tremovedMetadata	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  tremovedMetadata :: Relation3 r Name Metadata.Value$/;"	c_a	cons:DiffSlice.DiffSlice	line:38	language:Haskell
trenames	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  trenames :: Map r (Set Name, Set Name), -- ref (old, new)$/;"	c_a	cons:DiffSlice.DiffSlice	line:36	language:Haskell
truncate0	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^truncate0 :: (Num a, Ord a) => a -> a$/;"	ft	signature:((Num a, Ord a) => a -> a)	line:850	language:Haskell
truncateAliases	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^truncateAliases :: Int -> SearchResult -> SearchResult$/;"	ft	signature:(Int -> SearchResult -> SearchResult)	line:65	language:Haskell
try	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^try :: Monad m => KeyCommand m s s -> Command m s s$/;"	ft	signature:(Monad m => KeyCommand m s s -> Command m s s)	line:125	language:Haskell
tryAny	./parser-typechecker/src/Unison/Util/Exception.hs	/^tryAny :: IO a -> IO (Either SomeException a)$/;"	ft	signature:(IO a -> IO (Either SomeException a))	line:11	language:Haskell
tryDequeue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^tryDequeue :: TQueue a -> STM (Maybe a)$/;"	ft	signature:(TQueue a -> STM (Maybe a))	line:42	language:Haskell
tryGetLayouts	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^tryGetLayouts :: [IO (Maybe Layout)] -> IO Layout$/;"	ft	signature:([IO (Maybe Layout)] -> IO Layout)	line:93	language:Haskell
tryPeekWhile	./parser-typechecker/src/Unison/Util/TQueue.hs	/^tryPeekWhile :: (a -> Bool) -> TQueue a -> STM [a]$/;"	ft	signature:((a -> Bool) -> TQueue a -> STM [a])	line:74	language:Haskell
ttyHandles	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^stdinTTYHandles, ttyHandles :: MaybeT IO Handles$/;"	ft	signature:(MaybeT IO Handles)	line:250	language:Haskell
ttyHandles	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^ttyHandles = do$/;"	fi	line:262	language:Haskell
tuple	./parser-typechecker/src/Unison/Runtime/IR.hs	/^tuple :: [Value e cont] -> Value e cont$/;"	ft	signature:([Value e cont] -> Value e cont)	line:127	language:Haskell
tupleConsTerm	./unison-core/src/Unison/DataDeclaration.hs	/^tupleConsTerm :: (Ord v, Semigroup a)$/;"	ft	signature:((Ord v, Semigroup a) => Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a)	line:563	language:Haskell
tupleOrParenthesized	./parser-typechecker/src/Unison/Parser.hs	/^tupleOrParenthesized :: Ord v => P v a -> (Ann -> a) -> (a -> a -> a) -> P v a$/;"	ft	signature:(Ord v => P v a -> (Ann -> a) -> (a -> a -> a) -> P v a)	line:400	language:Haskell
tupleOrParenthesizedTerm	./parser-typechecker/src/Unison/TermParser.hs	/^tupleOrParenthesizedTerm :: Var v => TermP v$/;"	ft	signature:(Var v => TermP v)	line:874	language:Haskell
tupleOrParenthesizedType	./parser-typechecker/src/Unison/TypeParser.hs	/^tupleOrParenthesizedType :: Var v => TypeP v -> TypeP v$/;"	ft	signature:(Var v => TypeP v -> TypeP v)	line:92	language:Haskell
tupleTerm	./unison-core/src/Unison/DataDeclaration.hs	/^tupleTerm :: (Var v, Monoid a) => [Term v a] -> Term v a$/;"	ft	signature:((Var v, Monoid a) => [Term v a] -> Term v a)	line:570	language:Haskell
twoRemoved	./parser-typechecker/tests/Unison/Test/Codebase/Causal.hs	/^twoRemoved :: Causal Identity Hash (Set Int64)$/;"	ft	signature:(Causal Identity Hash (Set Int64))	line:162	language:Haskell
type1	./parser-typechecker/src/Unison/TypeParser.hs	/^type1 :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:50	language:Haskell
type2	./parser-typechecker/src/Unison/TypeParser.hs	/^type2 :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:64	language:Haskell
type2a	./parser-typechecker/src/Unison/TypeParser.hs	/^type2a :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:53	language:Haskell
typeAlias	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , typeAlias :: Map v Aliases$/;"	c_a	cons:SlurpResult.SlurpResult	line:67	language:Haskell
typeAliases	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^  , typeAliases :: Set HashQualified$/;"	c_a	cons:TypeResult.TypeResult	line:30	language:Haskell
typeAliases	./unison-core/src/Unison/Names2.hs	/^typeAliases :: Ord n => Names' n -> n -> Reference -> Set n$/;"	ft	signature:(Ord n => Names' n -> n -> Reference -> Set n)	line:201	language:Haskell
typeAtom	./parser-typechecker/src/Unison/TypeParser.hs	/^typeAtom :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:40	language:Haskell
typeCollisions	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^                , typeCollisions :: Relation Name Name$/;"	c_a	cons:RefCollisions.RefCollisions	line:832	language:Haskell
typeCompletor	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^typeCompletor :: Applicative m$/;"	ft	signature:(Applicative m => (String -> [String] -> [Completion]) -> String -> Codebase m v a -> Branch.Branch m -> Path.Absolute -> m [Completion])	line:1244	language:Haskell
typeDependencies	./unison-core/src/Unison/Term.hs	/^typeDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference$/;"	ft	signature:((Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference)	line:819	language:Haskell
typeDirectedNameResolution	./parser-typechecker/src/Unison/Typechecker.hs	/^typeDirectedNameResolution oldNotes oldType env = do$/;"	fi	line:216	language:Haskell
typeEdits	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  , typeEdits :: Map Reference TypeEdit$/;"	c_a	cons:Edits.Edits	line:58	language:Haskell
typeError	./parser-typechecker/src/Unison/Typechecker.hs	/^typeError :: Context.ErrorNote v loc -> Result (Notes v loc) ()$/;"	ft	signature:(Context.ErrorNote v loc -> Result (Notes v loc) ())	line:188	language:Haskell
typeError	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^typeError :: Cause v loc -> Result v loc a$/;"	ft	signature:(Cause v loc -> Result v loc a)	line:151	language:Haskell
typeErrorFromNote	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^typeErrorFromNote n = case Ex.extract allErrors n of$/;"	fi	line:94	language:Haskell
typeErrors	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^typeErrors :: Result v loc a -> Seq (ErrorNote v loc)$/;"	ft	signature:(Result v loc a -> Seq (ErrorNote v loc))	line:157	language:Haskell
typeIndexDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^typeIndexDir :: CodebasePath -> Reference -> FilePath$/;"	ft	signature:(CodebasePath -> Reference -> FilePath)	line:209	language:Haskell
typeInfoFromNote	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^typeInfoFromNote n = case n of$/;"	fi	line:100	language:Haskell
typeLink	./unison-core/src/Unison/Term.hs	/^typeLink :: Ord v => a -> Reference -> Term2 vt at ap v a$/;"	ft	signature:(Ord v => a -> Reference -> Term2 vt at ap v a)	line:476	language:Haskell
typeLink	./unison-core/src/Unison/Type.hs	/^typeLink :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:203	language:Haskell
typeLink'	./parser-typechecker/src/Unison/TermParser.hs	/^typeLink' :: Var v => P v (L.Token Reference)$/;"	ft	signature:(Var v => P v (L.Token Reference))	line:82	language:Haskell
typeLinkRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
typeLinkRef	./unison-core/src/Unison/Type.hs	/^typeLinkRef = Reference.Builtin "Link.Type"$/;"	fi	line:223	language:Haskell
typeLookup	./parser-typechecker/src/Unison/Builtin.hs	/^typeLookup :: Var v => TL.TypeLookup v Ann$/;"	ft	signature:(Var v => TL.TypeLookup v Ann)	line:74	language:Haskell
typeLookupForDependencies	./parser-typechecker/src/Unison/Codebase.hs	/^typeLookupForDependencies codebase = foldM go mempty$/;"	fi	line:145	language:Haskell
typeMap	./unison-core/src/Unison/Term.hs	/^typeMap f = go$/;"	fi	line:210	language:Haskell
typeMentionsIndexDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^typeMentionsIndexDir :: CodebasePath -> Reference -> FilePath$/;"	ft	signature:(CodebasePath -> Reference -> FilePath)	line:212	language:Haskell
typeMismatch	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^typeMismatch :: ErrorExtractor v loc (C.Context v loc)$/;"	ft	signature:(ErrorExtractor v loc (C.Context v loc))	line:232	language:Haskell
typeName	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^  { typeName    :: HashQualified$/;"	c_a	cons:TypeResult.TypeResult	line:28	language:Haskell
typeName	./parser-typechecker/src/Unison/CommandLine/DisplayValues.hs	/^typeName :: PPE.PrettyPrintEnv -> Reference -> Pretty$/;"	ft	signature:(PPE.PrettyPrintEnv -> Reference -> Pretty)	line:93	language:Haskell
typeName	./parser-typechecker/src/Unison/CommandLine/InputPattern.hs	/^  { typeName :: String$/;"	c_a	cons:ArgumentType.ArgumentType	line:37	language:Haskell
typeName	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^typeName :: PrettyPrintEnv -> Reference -> HashQualified$/;"	ft	signature:(PrettyPrintEnv -> Reference -> HashQualified)	line:105	language:Haskell
typeName	./unison-core/src/Unison/Names3.hs	/^typeName :: Int -> Reference -> Names -> Set HQ'.HashQualified$/;"	ft	signature:(Int -> Reference -> Names -> Set HQ'.HashQualified)	line:165	language:Haskell
typeNamed	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^typeNamed :: String -> R.Reference$/;"	ft	signature:(String -> R.Reference)	line:51	language:Haskell
typeOf	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  typeOf (SymbolC _ s) = Var.typeOf s$/;"	fi	instance:Var SymbolC	line:958	language:Haskell
typeOf	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  typeOf v = Var.typeOf (underlying v)$/;"	fi	instance:Var v => Var (TypeVar b v)	line:40	language:Haskell
typeOf	./unison-core/src/Unison/Symbol.hs	/^  typeOf (Symbol _ t) = t$/;"	fi	instance:Var Symbol	line:22	language:Haskell
typeOf	./unison-core/src/Unison/Var.hs	/^  typeOf :: v -> Type$/;"	ft	signature:(v -> Type)	class:Var	line:26	language:Haskell
typeOfConstructor	./unison-core/src/Unison/DataDeclaration.hs	/^typeOfConstructor :: DataDeclaration' v a -> ConstructorId -> Maybe (Type v a)$/;"	ft	signature:(DataDeclaration' v a -> ConstructorId -> Maybe (Type v a))	line:175	language:Haskell
typeOfDataConstructor	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^typeOfDataConstructor :: TypeLookup v a -> Reference -> Int -> Maybe (Type v a)$/;"	ft	signature:(TypeLookup v a -> Reference -> Int -> Maybe (Type v a))	line:40	language:Haskell
typeOfEffectConstructor	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^typeOfEffectConstructor :: TypeLookup v a -> Reference -> Int -> Maybe (Type v a)$/;"	ft	signature:(TypeLookup v a -> Reference -> Int -> Maybe (Type v a))	line:44	language:Haskell
typeOfReferent	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^typeOfReferent :: TypeLookup v a -> Referent -> Maybe (Type v a)$/;"	ft	signature:(TypeLookup v a -> Referent -> Maybe (Type v a))	line:23	language:Haskell
typeOfTerm	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^typeOfTerm :: TypeLookup v a -> Reference -> Maybe (Type v a)$/;"	ft	signature:(TypeLookup v a -> Reference -> Maybe (Type v a))	line:48	language:Haskell
typeOfTerm'	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^typeOfTerm' :: TypeLookup v a -> Reference -> Either Reference (Type v a)$/;"	ft	signature:(TypeLookup v a -> Reference -> Either Reference (Type v a))	line:51	language:Haskell
typeOfTerms	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^  TypeLookup { typeOfTerms :: Map Reference (Type v a)$/;"	c_a	cons:TypeLookup.TypeLookup	line:18	language:Haskell
typePath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^termPath, typePath, declPath :: CodebasePath -> Reference.Id -> FilePath$/;"	ft	signature:(CodebasePath -> Reference.Id -> FilePath)	line:260	language:Haskell
typePath	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^typePath path r = termDir path r <\/> "type.ub"$/;"	fi	line:262	language:Haskell
typeRef	./unison-core/src/Unison/LabeledDependency.hs	/^typeRef, termRef :: Reference -> LabeledDependency$/;"	ft	signature:(Reference -> LabeledDependency)	line:16	language:Haskell
typeRef	./unison-core/src/Unison/LabeledDependency.hs	/^typeRef = X . Left$/;"	fi	line:23	language:Haskell
typeReferences	./unison-core/src/Unison/Names2.hs	/^termReferences, typeReferences, allReferences :: Names' n -> Set Reference$/;"	ft	signature:(Names' n -> Set Reference)	line:91	language:Haskell
typeReferences	./unison-core/src/Unison/Names2.hs	/^typeReferences Names{..} = R.ran types$/;"	fi	line:93	language:Haskell
typeReferencesByPrefix	./parser-typechecker/src/Unison/Codebase.hs	/^           , typeReferencesByPrefix :: ShortHash -> m (Set Reference.Id)$/;"	c_a	cons:Codebase.Codebase	line:86	language:Haskell
typeReferencesByPrefix	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^typeReferencesByPrefix root = loadReferencesByPrefix (typesDir root)$/;"	fi	line:586	language:Haskell
typeReplacements	./parser-typechecker/src/Unison/Codebase/Editor/Propagate.hs	/^  , typeReplacements :: Map Reference Reference$/;"	c_a	cons:Edits.Edits	line:59	language:Haskell
typeResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^typeResult :: HashQualified -> Reference -> Set HashQualified -> SearchResult$/;"	ft	signature:(HashQualified -> Reference -> Set HashQualified -> SearchResult)	line:43	language:Haskell
typeSearchResult	./parser-typechecker/src/Unison/Codebase/SearchResult.hs	/^typeSearchResult :: Names0 -> Name -> Reference -> SearchResult$/;"	ft	signature:(Names0 -> Name -> Reference -> SearchResult)	line:46	language:Haskell
typeSite	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^                , typeSite     :: loc$/;"	c_a	cons:TypeError.UnknownType	line:68	language:Haskell
typecheck	./parser-typechecker/src/Unison/Codebase/Editor/HandleCommand.hs	/^typecheck ambient codebase parsingEnv sourceName src =$/;"	fi	line:65	language:Haskell
typecheck'	./parser-typechecker/src/Unison/Codebase/Editor/HandleCommand.hs	/^typecheck' ambient codebase file = do$/;"	fi	line:79	language:Haskell
typecheckedFile	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^typecheckedFile :: UF.TypecheckedUnisonFile Symbol Ann$/;"	ft	signature:(UF.TypecheckedUnisonFile Symbol Ann)	line:30	language:Haskell
typecheckedFileTerms	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^typecheckedFileTerms :: Map.Map Symbol R.Reference$/;"	ft	signature:(Map.Map Symbol R.Reference)	line:41	language:Haskell
typecheckedToNames0	./parser-typechecker/src/Unison/UnisonFile.hs	/^typecheckedToNames0 :: Var v => TypecheckedUnisonFile v a -> Names0$/;"	ft	signature:(Var v => TypecheckedUnisonFile v a -> Names0)	line:193	language:Haskell
typecheckedUnisonFile	./parser-typechecker/src/Unison/UnisonFile.hs	/^typecheckedUnisonFile :: Var v$/;"	ft	signature:(Var v => Map v (Reference, DataDeclaration' v a) -> Map v (Reference, EffectDeclaration' v a) -> [[ (v, Term v a, Type v a) ]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> TypecheckedUnisonFile v a)	line:89	language:Haskell
typecheckedUnisonFile0	./parser-typechecker/src/Unison/UnisonFile.hs	/^typecheckedUnisonFile0 :: Ord v => TypecheckedUnisonFile v a$/;"	ft	signature:(Ord v => TypecheckedUnisonFile v a)	line:204	language:Haskell
typecheckingTerm	./parser-typechecker/src/Unison/UnisonFile.hs	/^typecheckingTerm :: (Var v, Monoid a) => UnisonFile v a -> Term v a$/;"	ft	signature:((Var v, Monoid a) => UnisonFile v a -> Term v a)	line:64	language:Haskell
typecheckingTest	./parser-typechecker/tests/Unison/Test/UnisonSources.hs	/^typecheckingTest :: (EitherResult -> Test TFile) -> FilePath -> Test TFile$/;"	ft	signature:((EitherResult -> Test TFile) -> FilePath -> Test TFile)	line:129	language:Haskell
typed	./parser-typechecker/src/Unison/Runtime/IR.hs	/^  typed s = SymbolC False (Var.typed s)$/;"	fi	instance:Var SymbolC	line:957	language:Haskell
typed	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^  typed t = Universal (Var.typed t)$/;"	fi	instance:Var v => Var (TypeVar b v)	line:39	language:Haskell
typed	./unison-core/src/Unison/Symbol.hs	/^  typed t = Symbol 0 t$/;"	fi	instance:Var Symbol	line:21	language:Haskell
typed	./unison-core/src/Unison/Var.hs	/^  typed :: Type -> v$/;"	ft	signature:(Type -> v)	class:Var	line:25	language:Haskell
typedecl	./parser-typechecker/src/Unison/TermParser.hs	/^typedecl :: Var v => P v (L.Token v, Type v Ann)$/;"	ft	signature:(Var v => P v (L.Token v, Type v Ann))	line:647	language:Haskell
types	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^types :: Lens' (Branch0 m) (Star Reference NameSegment)$/;"	ft	signature:(Lens' (Branch0 m) (Star Reference NameSegment))	line:279	language:Haskell
types	./parser-typechecker/src/Unison/Codebase/Editor/SlurpComponent.hs	/^  SlurpComponent { types :: Set v, terms :: Set v }$/;"	c_a	cons:SlurpComponent.SlurpComponent	line:17	language:Haskell
types	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  types :: Reference -> Maybe HashQualified }$/;"	c_a	cons:PrettyPrintEnv.PrettyPrintEnv	line:27	language:Haskell
types	./unison-core/src/Unison/Names2.hs	/^  , types :: Relation n Reference$/;"	c_a	cons:Names'.Names	line:71	language:Haskell
types0	./unison-core/src/Unison/Names3.hs	/^types0 :: Names0 -> Relation Name Reference$/;"	ft	signature:(Names0 -> Relation Name Reference)	line:111	language:Haskell
typesDiff	./parser-typechecker/src/Unison/Codebase/BranchDiff.hs	/^  , typesDiff :: DiffSlice Reference$/;"	c_a	cons:BranchDiff.BranchDiff	line:43	language:Haskell
typesDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^typesDir root = root <\/> "types"$/;"	fi	line:188	language:Haskell
typesNamed	./unison-core/src/Unison/Names2.hs	/^typesNamed :: Ord n => Names' n -> n -> Set Reference$/;"	ft	signature:(Ord n => Names' n -> n -> Set Reference)	line:189	language:Haskell
typing	./parser-typechecker/src/Unison/Codebase/TermEdit.hs	/^typing :: Var v => Type v loc -> Type v loc -> Typing$/;"	ft	signature:(Var v => Type v loc -> Type v loc -> Typing)	line:47	language:Haskell
uberTerm'	./parser-typechecker/src/Unison/UnisonFile.hs	/^uberTerm' :: (Var v, Monoid a) => UnisonFile v a -> Term v a -> Term v a$/;"	ft	signature:((Var v, Monoid a) => UnisonFile v a -> Term v a -> Term v a)	line:74	language:Haskell
ucmCommand	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^ucmCommand :: P UcmCommand$/;"	ft	signature:(P UcmCommand)	line:294	language:Haskell
unApps	./unison-core/src/Unison/Term.hs	/^unApps t = unAppsPred (t, const True)$/;"	fi	line:724	language:Haskell
unApps	./unison-core/src/Unison/Type.hs	/^unApps :: Type v a -> Maybe (Type v a, [Type v a])$/;"	ft	signature:(Type v a -> Maybe (Type v a, [Type v a]))	line:149	language:Haskell
unAppsPred	./unison-core/src/Unison/Term.hs	/^unAppsPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) ->$/;"	ft	signature:((Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe (Term2 vt at ap v a, [Term2 vt at ap v a]))	line:727	language:Haskell
unArrows	./unison-core/src/Unison/Type.hs	/^unArrows :: Type v a -> Maybe [Type v a]$/;"	ft	signature:(Type v a -> Maybe [Type v a])	line:131	language:Haskell
unBinaryApp	./unison-core/src/Unison/Term.hs	/^unBinaryApp :: Term2 vt at ap v a$/;"	ft	signature:(Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a, Term2 vt at ap v a))	line:735	language:Haskell
unBinaryApps	./unison-core/src/Unison/Term.hs	/^unBinaryApps t = unBinaryAppsPred (t, const True)$/;"	fi	line:750	language:Haskell
unBinaryAppsPred	./unison-core/src/Unison/Term.hs	/^unBinaryAppsPred :: (Term2 vt at ap v a$/;"	ft	signature:((Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe ([(Term2 vt at ap v a, Term2 vt at ap v a)], Term2 vt at ap v a))	line:753	language:Haskell
unDraw	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^newtype Draw m a = Draw {unDraw :: (ReaderT Actions$/;"	c_a	cons:Draw.Draw	line:104	language:Haskell
unDumbTerm	./yaks/haskeline/System/Console/Haskeline/Backend/DumbTerm.hs	/^newtype DumbTerm m a = DumbTerm {unDumbTerm :: StateT Window (PosixT m) a}$/;"	c_a	cons:DumbTerm.DumbTerm	line:23	language:Haskell
unEffect0	./unison-core/src/Unison/Type.hs	/^unEffect0 :: Ord v => Type v a -> ([Type v a], Type v a)$/;"	ft	signature:(Ord v => Type v a -> ([Type v a], Type v a))	line:178	language:Haskell
unEffectfulArrows	./unison-core/src/Unison/Type.hs	/^unEffectfulArrows t = case t of$/;"	fi	line:139	language:Haskell
unEffects1	./unison-core/src/Unison/Type.hs	/^unEffects1 :: Ord v => Type v a -> Maybe ([Type v a], Type v a)$/;"	ft	signature:(Ord v => Type v a -> Maybe ([Type v a], Type v a))	line:182	language:Haskell
unForalls	./unison-core/src/Unison/Type.hs	/^unForalls :: Type v a -> Maybe ([v], Type v a)$/;"	ft	signature:(Type v a -> Maybe ([v], Type v a))	line:172	language:Haskell
unInputT	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^newtype InputT m a = InputT {unInputT :: $/;"	c_a	cons:InputT.InputT	line:41	language:Haskell
unIntroOuters	./unison-core/src/Unison/Type.hs	/^unIntroOuters :: Type v a -> Maybe ([v], Type v a)$/;"	ft	signature:(Type v a -> Maybe ([v], Type v a))	line:158	language:Haskell
unLams'	./unison-core/src/Unison/Term.hs	/^unLams' t = unLamsPred' (t, const True)$/;"	fi	line:766	language:Haskell
unLamsMatch'	./unison-core/src/Unison/Term.hs	/^unLamsMatch' t = case unLamsUntilDelay' t of$/;"	fi	line:791	language:Haskell
unLamsOpt'	./unison-core/src/Unison/Term.hs	/^unLamsOpt' :: Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)$/;"	ft	signature:(Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a))	line:770	language:Haskell
unLamsPred'	./unison-core/src/Unison/Term.hs	/^unLamsPred' :: (Term2 vt at ap v a, v -> Bool) ->$/;"	ft	signature:((Term2 vt at ap v a, v -> Bool) -> Maybe ([v], Term2 vt at ap v a))	line:803	language:Haskell
unLamsUntilDelay'	./unison-core/src/Unison/Term.hs	/^unLamsUntilDelay' t = case unLamsPred' (t, (\/=) $ Var.named "()") of$/;"	fi	line:781	language:Haskell
unLet	./unison-core/src/Unison/Term.hs	/^unLet t = fixup (go t)$/;"	fi	line:681	language:Haskell
unLet1	./unison-core/src/Unison/Term.hs	/^unLet1 (ABT.Tm' (Let isTop b (ABT.Abs' subst))) = Just (isTop, b, subst)$/;"	fi	line:674	language:Haskell
unLetBlock	./parser-typechecker/src/Unison/TermPrinter.hs	/^unLetBlock t = rec t where$/;"	fi	line:1012	language:Haskell
unLetRec	./unison-core/src/Unison/Term.hs	/^unLetRec (unLetRecNamed -> Just (isTop, bs, e)) = Just$/;"	fi	line:712	language:Haskell
unLetRecNamed	./unison-core/src/Unison/Term.hs	/^unLetRecNamed (ABT.Cycle' vs (ABT.Tm' (LetRec isTop bs e)))$/;"	fi	line:697	language:Haskell
unLetRecNamedAnnotated	./unison-core/src/Unison/Term.hs	/^unLetRecNamedAnnotated (ABT.CycleA' ann avs (ABT.Tm' (LetRec isTop bs e))) =$/;"	fi	line:597	language:Haskell
unOptionalRef	./unison-core/src/Unison/DataDeclaration.hs	/^unUnitRef,unPairRef,unOptionalRef:: Reference -> Bool$/;"	ft	signature:(Reference -> Bool)	line:602	language:Haskell
unOptionalRef	./unison-core/src/Unison/DataDeclaration.hs	/^unOptionalRef = (== optionalRef)$/;"	fi	line:605	language:Haskell
unPairRef	./unison-core/src/Unison/DataDeclaration.hs	/^unUnitRef,unPairRef,unOptionalRef:: Reference -> Bool$/;"	ft	signature:(Reference -> Bool)	line:602	language:Haskell
unPairRef	./unison-core/src/Unison/DataDeclaration.hs	/^unPairRef = (== pairRef)$/;"	fi	line:604	language:Haskell
unPath'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Path' = Path' { unPath' :: Either Absolute Relative }$/;"	c_a	cons:Path'.Path'	line:34	language:Haskell
unPure	./unison-core/src/Unison/Type.hs	/^unPure :: Ord v => Type v a -> Maybe (Type v a)$/;"	ft	signature:(Ord v => Type v a -> Maybe (Type v a))	line:126	language:Haskell
unPutT	./parser-typechecker/src/Unison/Codebase/Serialization/PutT.hs	/^newtype PutT m a = PutT { unPutT :: m (PutM a) }$/;"	c_a	cons:PutT.PutT	line:10	language:Haskell
unRawHash	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^newtype RawHash a = RawHash { unRawHash :: Hash }$/;"	c_a	cons:RawHash.RawHash	line:46	language:Haskell
unReqOrCtor	./unison-core/src/Unison/Term.hs	/^unReqOrCtor :: Term2 vt at ap v a -> Maybe (Reference, Int)$/;"	ft	signature:(Term2 vt at ap v a -> Maybe (Reference, Int))	line:810	language:Haskell
unTuplePattern	./unison-core/src/Unison/DataDeclaration.hs	/^unTuplePattern :: Pattern.PatternP loc -> Maybe [Pattern.PatternP loc]$/;"	ft	signature:(Pattern.PatternP loc -> Maybe [Pattern.PatternP loc])	line:596	language:Haskell
unTupleTerm	./unison-core/src/Unison/DataDeclaration.hs	/^unTupleTerm t = case t of$/;"	fi	line:584	language:Haskell
unTupleType	./unison-core/src/Unison/DataDeclaration.hs	/^unTupleType :: Var v => Type v a -> Maybe [Type v a]$/;"	ft	signature:(Var v => Type v a -> Maybe [Type v a])	line:590	language:Haskell
unUnitRef	./unison-core/src/Unison/DataDeclaration.hs	/^unUnitRef,unPairRef,unOptionalRef:: Reference -> Bool$/;"	ft	signature:(Reference -> Bool)	line:602	language:Haskell
unabs	./unison-core/src/Unison/ABT.hs	/^unabs :: Term f v a -> ([v], Term f v a)$/;"	ft	signature:(Term f v a -> ([v], Term f v a))	line:469	language:Haskell
unabs1	./unison-core/src/Unison/ABT.hs	/^unabs1 :: (Foldable f, Functor f, Var v) => Term f v a -> Maybe (Subst f v a)$/;"	ft	signature:((Foldable f, Functor f, Var v) => Term f v a -> Maybe (Subst f v a))	line:462	language:Haskell
unabs1A	./unison-core/src/Unison/ABT.hs	/^unabs1A :: Term f v a -> Maybe ([(a,v)], Term f v a)$/;"	ft	signature:(Term f v a -> Maybe ([(a, v)], Term f v a))	line:183	language:Haskell
unabsA	./unison-core/src/Unison/ABT.hs	/^unabsA :: Term f v a -> ([(a,v)], Term f v a)$/;"	ft	signature:(Term f v a -> ([(a, v)], Term f v a))	line:178	language:Haskell
unabsolute	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Absolute = Absolute { unabsolute :: Path } deriving (Eq,Ord)$/;"	c_a	cons:Absolute.Absolute	line:32	language:Haskell
unannotate	./unison-core/src/Unison/Term.hs	/^unannotate = go$/;"	fi	line:267	language:Haskell
uncapitalize	./unison-core/src/Unison/Var.hs	/^uncapitalize :: Var v => v -> v$/;"	ft	signature:(Var v => v -> v)	line:60	language:Haskell
uncons	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^uncons :: Applicative m => Branch m -> m (Maybe (Branch0 m, Branch m))$/;"	ft	signature:(Applicative m => Branch m -> m (Maybe (Branch0 m, Branch m)))	line:614	language:Haskell
uncons	./parser-typechecker/src/Unison/Codebase/Causal.hs	/^uncons :: Applicative m => Causal m h e -> m (Maybe (e, Causal m h e))$/;"	ft	signature:(Applicative m => Causal m h e -> m (Maybe (e, Causal m h e)))	line:325	language:Haskell
uncons	./parser-typechecker/src/Unison/Codebase/Path.hs	/^uncons :: Path -> Maybe (NameSegment, Path)$/;"	ft	signature:(Path -> Maybe (NameSegment, Path))	line:267	language:Haskell
uncons	./parser-typechecker/src/Unison/Util/AnnotatedText.hs	/^  uncons (AnnotatedText at) = case at of$/;"	fi	instance:LL-ListLike (AnnotatedText a) Char	line:46	language:Haskell
undequeue	./parser-typechecker/src/Unison/Util/TQueue.hs	/^undequeue :: TQueue a -> a -> STM ()$/;"	ft	signature:(TQueue a -> a -> STM ())	line:38	language:Haskell
underline	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
underline	./parser-typechecker/src/Unison/Util/ColorText.hs	/^underline = style Underline $/;"	fi	line:42	language:Haskell
underline	./parser-typechecker/src/Unison/Util/Pretty.hs	/^underline = map CT.underline$/;"	fi	line:685	language:Haskell
underlying	./parser-typechecker/src/Unison/Typechecker/TypeVar.hs	/^underlying :: TypeVar b v -> v$/;"	ft	signature:(TypeVar b v -> v)	line:27	language:Haskell
underlyingSymbol	./parser-typechecker/src/Unison/Runtime/IR.hs	/^          , underlyingSymbol :: Symbol$/;"	c_a	cons:SymbolC.SymbolC	line:64	language:Haskell
undo	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^undo :: InputPattern$/;"	ft	signature:(InputPattern)	line:287	language:Haskell
undoPast	./yaks/haskeline/System/Console/Haskeline/Command/Undo.hs	/^undoPast, redoFuture :: Save s => s -> Undo -> (s,Undo)$/;"	ft	signature:(Save s => s -> Undo -> (s, Undo))	line:30	language:Haskell
unfenced	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^unfenced :: P Stanza$/;"	ft	signature:(P Stanza)	line:337	language:Haskell
unfold	./parser-typechecker/src/Unison/Util/Free.hs	/^unfold :: (v -> Either a (f v)) -> v -> Free f a$/;"	ft	signature:((v -> Either a (f v)) -> v -> Free f a)	line:25	language:Haskell
unfold'	./parser-typechecker/src/Unison/Util/Free.hs	/^unfold' :: (v -> Free f (Either a v)) -> v -> Free f a$/;"	ft	signature:((v -> Free f (Either a v)) -> v -> Free f a)	line:30	language:Haskell
unfoldM	./parser-typechecker/src/Unison/Util/Free.hs	/^unfoldM :: (Traversable f, Applicative m, Monad m)$/;"	ft	signature:((Traversable f, Applicative m, Monad m) => (b -> m (Either a (f b))) -> b -> m (Free f a))	line:33	language:Haskell
unforall	./unison-core/src/Unison/Type.hs	/^unforall :: Type v a -> Type v a$/;"	ft	signature:(Type v a -> Type v a)	line:380	language:Haskell
unforall'	./unison-core/src/Unison/Type.hs	/^unforall' :: Type v a -> ([v], Type v a)$/;"	ft	signature:(Type v a -> ([v], Type v a))	line:384	language:Haskell
ungeneralize	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^ungeneralize :: (Var v, Ord loc) => Type v loc -> M v loc (Type v loc)$/;"	ft	signature:((Var v, Ord loc) => Type v loc -> M v loc (Type v loc))	line:1262	language:Haskell
ungeneralize'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^ungeneralize' :: (Var v, Ord loc) => Type v loc -> M v loc ([v], Type v loc)$/;"	ft	signature:((Var v, Ord loc) => Type v loc -> M v loc ([v], Type v loc))	line:1265	language:Haskell
unguardedCycle	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^unguardedCycle :: Ex.ErrorExtractor v loc (TypeError v loc)$/;"	ft	signature:(Ex.ErrorExtractor v loc (TypeError v loc))	line:185	language:Haskell
unhashComponent	./unison-core/src/Unison/DataDeclaration.hs	/^unhashComponent m$/;"	fi	line:352	language:Haskell
unhashComponent	./unison-core/src/Unison/Term.hs	/^unhashComponent :: forall v a. Var v$/;"	ft	signature:(forall v a. Var v => Map Reference (Term v a) -> Map Reference (v, Term v a))	line:913	language:Haskell
unhashComponentTest	./parser-typechecker/tests/Unison/Test/DataDeclaration.hs	/^unhashComponentTest :: Test ()$/;"	ft	signature:(Test ())	line:77	language:Haskell
unicodeChar	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^                          unicodeChar :: Char,$/;"	c_a	cons:InputEvent.KeyEvent	line:123	language:Haskell
unicodeEncoding	./yaks/haskeline/tests/Unit.hs	/^unicodeEncoding i = "Unicode encoding (valid)" ~:$/;"	fi	line:60	language:Haskell
unicodeMovement	./yaks/haskeline/tests/Unit.hs	/^unicodeMovement i = "Unicode movement" ~:$/;"	fi	line:84	language:Haskell
unicodeToCodePage	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^unicodeToCodePage :: CodePage -> String -> IO B.ByteString$/;"	ft	signature:(CodePage -> String -> IO B.ByteString)	line:466	language:Haskell
union	./unison-core/src/Unison/Util/Relation.hs	/^union :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b)	line:88	language:Haskell
unionLeft	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^unionLeft :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv$/;"	ft	signature:(PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv)	line:80	language:Haskell
unionLeft	./unison-core/src/Unison/Names2.hs	/^unionLeft :: Ord n => Names' n -> Names' n -> Names' n$/;"	ft	signature:(Ord n => Names' n -> Names' n -> Names' n)	line:155	language:Haskell
unionLeft'	./unison-core/src/Unison/Names2.hs	/^unionLeft' p a b = Names terms' types'$/;"	fi	line:166	language:Haskell
unionLeft0	./unison-core/src/Unison/Names3.hs	/^unionLeft0 :: Names0 -> Names0 -> Names0$/;"	ft	signature:(Names0 -> Names0 -> Names0)	line:97	language:Haskell
unionLeftName	./unison-core/src/Unison/Names2.hs	/^unionLeftName :: Ord n => Names' n -> Names' n -> Names' n$/;"	ft	signature:(Ord n => Names' n -> Names' n -> Names' n)	line:141	language:Haskell
unionLeftName0	./unison-core/src/Unison/Names3.hs	/^unionLeftName0 :: Names0 -> Names0 -> Names0$/;"	ft	signature:(Names0 -> Names0 -> Names0)	line:100	language:Haskell
unionWithM	./parser-typechecker/src/Unison/Util/Map.hs	/^unionWithM :: forall m k a.$/;"	ft	signature:(forall m k a. (Monad m, Ord k) => (a -> a -> m a) -> Map k a -> Map k a -> m (Map k a))	line:10	language:Haskell
unions	./unison-core/src/Unison/Util/Relation.hs	/^unions :: (Ord a, Ord b) => [Relation a b] -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => [Relation a b] -> Relation a b)	line:163	language:Haskell
unique	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^unique :: SubseqExtractor v loc a -> ErrorExtractor v loc a$/;"	ft	signature:(SubseqExtractor v loc a -> ErrorExtractor v loc a)	line:55	language:Haskell
uniqueBase32Namegen	./parser-typechecker/src/Unison/Parser.hs	/^uniqueBase32Namegen :: forall gen. Random.DRG gen => gen -> UniqueName$/;"	ft	signature:(forall gen. Random.DRG gen => gen -> UniqueName)	line:64	language:Haskell
uniqueBy	./unison-core/src/Unison/Util/List.hs	/^uniqueBy, nubOrdOn :: (Foldable f, Ord b) => (a -> b) -> f a -> [a]$/;"	ft	signature:((Foldable f, Ord b) => (a -> b) -> f a -> [a])	line:22	language:Haskell
uniqueBy'	./unison-core/src/Unison/Util/List.hs	/^uniqueBy' :: (Foldable f, Ord b) => (a -> b) -> f a -> [a]$/;"	ft	signature:((Foldable f, Ord b) => (a -> b) -> f a -> [a])	line:33	language:Haskell
uniqueName	./parser-typechecker/src/Unison/Parser.hs	/^uniqueName :: Var v => Int -> P v Text$/;"	ft	signature:(Var v => Int -> P v Text)	line:82	language:Haskell
uniqueNames	./parser-typechecker/src/Unison/Parser.hs	/^  ParsingEnv { uniqueNames :: UniqueName$/;"	c_a	cons:ParsingEnv.ParsingEnv	line:51	language:Haskell
unique[a38186de35c9fcd29d2b359b2148f9f890732413d91575af39d025fcded67e89]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[a38186de35c9fcd29d2b359b2148f9f890732413d91575af39d025fcded67e89] type$/;"	fi	line:448	language:Haskell
unique[b28d929d0a73d2c18eac86341a3bb9399f8550c11b5f35eabb2751e6803ccc20]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[b28d929d0a73d2c18eac86341a3bb9399f8550c11b5f35eabb2751e6803ccc20] type$/;"	fi	line:157	language:Haskell
unique[b5c578f0a9977ed54a5a12b580dc6b0b2ba37bc3f517f48d1b3285a7f3e8c6bc]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[b5c578f0a9977ed54a5a12b580dc6b0b2ba37bc3f517f48d1b3285a7f3e8c6bc] type$/;"	fi	line:418	language:Haskell
unique[bb57f367a3740d4a1608b9e0eee14fd744ec9e368f1529550cb436ef56c0b268]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[bb57f367a3740d4a1608b9e0eee14fd744ec9e368f1529550cb436ef56c0b268] type$/;"	fi	line:407	language:Haskell
unique[bed6724af0d5f47f80cdea1b6023d35f120137ee0556e57154a9fc8b62fe5fed]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[bed6724af0d5f47f80cdea1b6023d35f120137ee0556e57154a9fc8b62fe5fed] type$/;"	fi	line:174	language:Haskell
unique[c7279b501764751edc66f1f7b532e68354fc4704c9eb1ed201f01c894cdd86f4]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[c7279b501764751edc66f1f7b532e68354fc4704c9eb1ed201f01c894cdd86f4] type$/;"	fi	line:441	language:Haskell
unique[cad7ab802bd143f0b674155c9caf18dde7145d16867a02659534d7bb01a5e287]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[cad7ab802bd143f0b674155c9caf18dde7145d16867a02659534d7bb01a5e287] type$/;"	fi	line:427	language:Haskell
unique[cb8469a1b41a63655062226556eaccf06129a2641af61fe7edef9c485c94a870]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[cb8469a1b41a63655062226556eaccf06129a2641af61fe7edef9c485c94a870] type GUID = GUID Bytes$/;"	fi	line:183	language:Haskell
unique[d4597403ec40fd4fbee57c62b8096f9c3d382dff01f20108546fe3530a927e86]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[d4597403ec40fd4fbee57c62b8096f9c3d382dff01f20108546fe3530a927e86] type$/;"	fi	line:202	language:Haskell
unique[d5d61b0a65f1d448dbdeed8af688f0bdbab6b3f775400da370eb5bfc34e428d5]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[d5d61b0a65f1d448dbdeed8af688f0bdbab6b3f775400da370eb5bfc34e428d5] type$/;"	fi	line:422	language:Haskell
unique[d875fa1ea7ef3adf8e29417c6c8b01a1830c4c6bd10dcca9d4196388462e0b7a]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[d875fa1ea7ef3adf8e29417c6c8b01a1830c4c6bd10dcca9d4196388462e0b7a] type LicenseType = LicenseType Doc$/;"	fi	line:181	language:Haskell
unique[e1d94401fde8b2546d6dfc54e93f11e6a9285a7ea765d3255da19122a42715d3]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[e1d94401fde8b2546d6dfc54e93f11e6a9285a7ea765d3255da19122a42715d3] type$/;"	fi	line:206	language:Haskell
unique[e1f48f31982a720ae895c0bf4e6ea9a950f5c00d3a73101ad31e63461b7beded]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[e1f48f31982a720ae895c0bf4e6ea9a950f5c00d3a73101ad31e63461b7beded] type$/;"	fi	line:435	language:Haskell
unique[e65de145a461a771de93d6c7885acae28552d77f8ae460bc8bf5de6f2a15ff77]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[e65de145a461a771de93d6c7885acae28552d77f8ae460bc8bf5de6f2a15ff77] type$/;"	fi	line:432	language:Haskell
unique[e6ca048b6bf540f93617c0ef9506afcbb490427a9581a01d51ffad39cdf2c554]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[e6ca048b6bf540f93617c0ef9506afcbb490427a9581a01d51ffad39cdf2c554] type$/;"	fi	line:420	language:Haskell
unique[e6dca08b40458b03ca1660cfbdaecaa7279b42d18257898b5fd1c34596aac36f]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[e6dca08b40458b03ca1660cfbdaecaa7279b42d18257898b5fd1c34596aac36f] type$/;"	fi	line:189	language:Haskell
unique[ee1c051034fa0671ea66e7c708ba552003bd3cf657bd28bf0051f1f8cdfcba53]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[ee1c051034fa0671ea66e7c708ba552003bd3cf657bd28bf0051f1f8cdfcba53] type$/;"	fi	line:171	language:Haskell
unique[ee4ff0bda526b0513e4c7b7387b39811ce57938ddb31a77fdb0ff00ee2717c33]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[ee4ff0bda526b0513e4c7b7387b39811ce57938ddb31a77fdb0ff00ee2717c33] type$/;"	fi	line:445	language:Haskell
unique[q1905679b27a97a4098bc965574da880c1074183a2c55ff1d481619c7fb8a1e1]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[q1905679b27a97a4098bc965574da880c1074183a2c55ff1d481619c7fb8a1e1] type$/;"	fi	line:168	language:Haskell
unique[u9ae6694152966cf1b0c1f4ad901a77e1acd7bbe16595fd27b07435ac45dab05]	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^unique[u9ae6694152966cf1b0c1f4ad901a77e1acd7bbe16595fd27b07435ac45dab05] type Year = Year Nat$/;"	fi	line:186	language:Haskell
unisonBufferMode	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^unisonBufferMode :: BufferMode -> RT.Value$/;"	ft	signature:(BufferMode -> RT.Value)	line:227	language:Haskell
unisonFilePath	./parser-typechecker/src/Unison/Runtime/Rt1IO.hs	/^unisonFilePath :: FilePath -> RT.Value$/;"	ft	signature:(FilePath -> RT.Value)	line:240	language:Haskell
unisonFilesInCurrDir	./unison-src/parser-tests/GenerateErrors.hs	/^unisonFilesInCurrDir :: IO [String]$/;"	ft	signature:(IO [String])	line:23	language:Haskell
unisonFilesInDir	./unison-src/parser-tests/GenerateErrors.hs	/^unisonFilesInDir :: FilePath -> IO [String]$/;"	ft	signature:(FilePath -> IO [String])	line:18	language:Haskell
unit	./parser-typechecker/src/Unison/Runtime/IR.hs	/^unit :: Value e cont$/;"	ft	signature:(Value e cont)	line:121	language:Haskell
unitCtorRef	./unison-core/src/Unison/DataDeclaration.hs	/^pairCtorRef, unitCtorRef :: Referent$/;"	ft	signature:(Referent)	line:421	language:Haskell
unitCtorRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitCtorRef = Referent.Con unitRef 0 CT.Data$/;"	fi	line:423	language:Haskell
unitRef	./unison-core/src/Unison/DataDeclaration.hs	/^unitRef, pairRef, optionalRef, testResultRef, linkRef, docRef :: Reference$/;"	ft	signature:(Reference)	line:409	language:Haskell
unitTerm	./unison-core/src/Unison/DataDeclaration.hs	/^unitTerm :: Var v => a -> Term v a$/;"	ft	signature:(Var v => a -> Term v a)	line:560	language:Haskell
unitTests	./parser-typechecker/tests/Unison/Test/TermParser.hs	/^unitTests :: [Test ()]$/;"	ft	signature:([Test ()])	line:196	language:Haskell
unitType	./unison-core/src/Unison/DataDeclaration.hs	/^unitType a = Type.ref a unitRef$/;"	fi	line:555	language:Haskell
universal'	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^universal' :: Ord v => a -> v -> Type.Type (TypeVar v loc) a$/;"	ft	signature:(Ord v => a -> v -> Type.Type (TypeVar v loc) a)	line:106	language:Haskell
universalVars	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^       , universalVars :: Set v -- set of universals seen so far$/;"	c_a	cons:Info.Info	line:331	language:Haskell
universallyQuantifyIfFree	./unison-core/src/Unison/Var.hs	/^universallyQuantifyIfFree :: forall v . Var v => v -> Bool$/;"	ft	signature:(forall v . Var v => v -> Bool)	line:144	language:Haskell
universals	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^universals :: Ord v => Context v loc -> Set v$/;"	ft	signature:(Ord v => Context v loc -> Set v)	line:493	language:Haskell
unknownAbilityConstructorTest	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  unknownAbilityConstructorTest :: Test ()$/;"	ft	signature:(Test ())	line:121	language:Haskell
unknownDataConstructorTest	./parser-typechecker/tests/Unison/Test/FileParser.hs	/^  unknownDataConstructorTest :: Test ()$/;"	ft	signature:(Test ())	line:112	language:Haskell
unknownSymbol	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^unknownSymbol :: ErrorExtractor v loc (loc, v)$/;"	ft	signature:(ErrorExtractor v loc (loc, v))	line:242	language:Haskell
unknownTag	./parser-typechecker/src/Unison/Codebase/Serialization/V1.hs	/^unknownTag :: (MonadGet m, Show a) => String -> a -> m x$/;"	ft	signature:((MonadGet m, Show a) => String -> a -> m x)	line:86	language:Haskell
unknownTerm	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^unknownTerm :: Var v => ErrorExtractor v loc (loc, v, [C.Suggestion v loc], C.Type v loc)$/;"	ft	signature:(Var v => ErrorExtractor v loc (loc, v, [C.Suggestion v loc], C.Type v loc))	line:247	language:Haskell
unknownTerm	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^unknownTerm :: Var v => Ex.ErrorExtractor v loc (TypeError v loc)$/;"	ft	signature:(Var v => Ex.ErrorExtractor v loc (TypeError v loc))	line:148	language:Haskell
unknownTermV	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | UnknownTerm { unknownTermV :: v$/;"	c_a	cons:TypeError.UnknownTerm	line:71	language:Haskell
unknownType	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^unknownType :: Ex.ErrorExtractor v loc (TypeError v loc)$/;"	ft	signature:(Ex.ErrorExtractor v loc (TypeError v loc))	line:142	language:Haskell
unknownTypeV	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^  | UnknownType { unknownTypeV :: v$/;"	c_a	cons:TypeError.UnknownType	line:67	language:Haskell
unlessM	./unison-core/src/Unison/Util/Monoid.hs	/^whenM, unlessM :: Monoid a => Bool -> a -> a$/;"	ft	signature:(Monoid a => Bool -> a -> a)	line:17	language:Haskell
unlessM	./unison-core/src/Unison/Util/Monoid.hs	/^unlessM = whenM . not$/;"	fi	line:20	language:Haskell
unlink	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^unlink :: InputPattern$/;"	ft	signature:(InputPattern)	line:1078	language:Haskell
unnamedTest	./unison-core/src/Unison/Var.hs	/^unnamedTest :: Var v => Text -> v$/;"	ft	signature:(Var v => Text -> v)	line:82	language:Haskell
unordered	./parser-typechecker/src/Unison/Typechecker/Components.hs	/^unordered :: Var v => [(v,Term' vt v a)] -> [[(v,Term' vt v a)]]$/;"	ft	signature:(Var v => [(v, Term' vt v a)] -> [[ (v, Term' vt v a) ]])	line:19	language:Haskell
unprefix	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unprefix :: Absolute -> Path' -> Path$/;"	ft	signature:(Absolute -> Path' -> Path)	line:88	language:Haskell
unprefixName	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unprefixName :: Absolute -> Name -> Name$/;"	ft	signature:(Absolute -> Name -> Name)	line:246	language:Haskell
unqualified	./unison-core/src/Unison/Name.hs	/^unqualified :: Name -> Name$/;"	ft	signature:(Name -> Name)	line:103	language:Haskell
unqualified	./unison-core/src/Unison/Var.hs	/^unqualified :: Var v => v -> v$/;"	ft	signature:(Var v => v -> v)	line:119	language:Haskell
unqualified'	./unison-core/src/Unison/Name.hs	/^unqualified' :: Text -> Text$/;"	ft	signature:(Text -> Text)	line:123	language:Haskell
unqualifiedName	./unison-core/src/Unison/Var.hs	/^unqualifiedName :: Var v => v -> Text$/;"	ft	signature:(Var v => v -> Text)	line:124	language:Haskell
unrelative	./parser-typechecker/src/Unison/Codebase/Path.hs	/^newtype Relative = Relative { unrelative :: Path } deriving (Eq,Ord)$/;"	c_a	cons:Relative.Relative	line:33	language:Haskell
unsafeChars	./parser-typechecker/tests/Unison/Test/Codebase/FileCodebase.hs	/^unsafeChars :: [Char]$/;"	ft	signature:([Char])	line:41	language:Haskell
unsafeConstructorType	./parser-typechecker/src/Unison/Typechecker/TypeLookup.hs	/^unsafeConstructorType :: TypeLookup v a -> Reference -> CT.ConstructorType$/;"	ft	signature:(TypeLookup v a -> Reference -> CT.ConstructorType)	line:30	language:Haskell
unsafeFromBase32Hex	./unison-core/src/Unison/Hash.hs	/^unsafeFromBase32Hex :: Text -> Hash$/;"	ft	signature:(Text -> Hash)	line:101	language:Haskell
unsafeFromHQ	./unison-core/src/Unison/HashQualified'.hs	/^unsafeFromHQ :: HQ.HashQualified' n -> HashQualified' n$/;"	ft	signature:(HQ.HashQualified' n -> HashQualified' n)	line:36	language:Haskell
unsafeFromString	./unison-core/src/Unison/HashQualified.hs	/^unsafeFromString :: String -> HashQualified$/;"	ft	signature:(String -> HashQualified)	line:91	language:Haskell
unsafeFromString	./unison-core/src/Unison/Name.hs	/^unsafeFromString :: String -> Name$/;"	ft	signature:(String -> Name)	line:60	language:Haskell
unsafeFromText	./unison-core/src/Unison/HashQualified'.hs	/^unsafeFromText :: Text -> HashQualified$/;"	ft	signature:(Text -> HashQualified)	line:71	language:Haskell
unsafeFromText	./unison-core/src/Unison/HashQualified.hs	/^unsafeFromText :: Text -> HashQualified$/;"	ft	signature:(Text -> HashQualified)	line:104	language:Haskell
unsafeFromText	./unison-core/src/Unison/Name.hs	/^unsafeFromText :: Text -> Name$/;"	ft	signature:(Text -> Name)	line:56	language:Haskell
unsafeFromText	./unison-core/src/Unison/Reference.hs	/^unsafeFromText :: Text -> Reference$/;"	ft	signature:(Text -> Reference)	line:128	language:Haskell
unsafeFromText	./unison-core/src/Unison/Referent.hs	/^unsafeFromText :: Text -> Referent$/;"	ft	signature:(Text -> Referent)	line:88	language:Haskell
unsafeFromText	./unison-core/src/Unison/ShortHash.hs	/^unsafeFromText :: Text -> ShortHash$/;"	ft	signature:(Text -> ShortHash)	line:55	language:Haskell
unsafeFromVar	./unison-core/src/Unison/HashQualified.hs	/^unsafeFromVar :: Var v => v -> HashQualified$/;"	ft	signature:(Var v => v -> HashQualified)	line:133	language:Haskell
unsafeGetRightFrom	./parser-typechecker/src/Unison/Parsers.hs	/^unsafeGetRightFrom :: (Var v, Show v) => String -> Either (Parser.Err v) a -> a$/;"	ft	signature:((Var v, Show v) => String -> Either (Parser.Err v) a -> a)	line:24	language:Haskell
unsafeHandleToFD	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^unsafeHandleToFD :: Handle -> IO FD$/;"	ft	signature:(Handle -> IO FD)	line:77	language:Haskell
unsafeId	./unison-core/src/Unison/Reference.hs	/^unsafeId :: Reference -> Id$/;"	ft	signature:(Reference -> Id)	line:56	language:Haskell
unsafeParseFile	./parser-typechecker/src/Unison/Parsers.hs	/^unsafeParseFile s pEnv = unsafeGetRightFrom s $ parseFile "" s pEnv$/;"	fi	line:87	language:Haskell
unsafeParseFileBuiltinsOnly	./parser-typechecker/src/Unison/Parsers.hs	/^unsafeParseFileBuiltinsOnly =$/;"	fi	line:80	language:Haskell
unsafeParseTerm	./parser-typechecker/src/Unison/Parsers.hs	/^unsafeParseTerm :: Var v => String -> Parser.ParsingEnv -> Term v Ann$/;"	ft	signature:(Var v => String -> Parser.ParsingEnv -> Term v Ann)	line:68	language:Haskell
unsafePrettyTermResultSig'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^unsafePrettyTermResultSig' :: Var v =>$/;"	ft	signature:(Var v => PPE.PrettyPrintEnv -> SR'.TermResult' v a -> Pretty)	line:1097	language:Haskell
unsafePrettyTermResultSigFull'	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^unsafePrettyTermResultSigFull' :: Var v =>$/;"	ft	signature:(Var v => PPE.PrettyPrintEnv -> SR'.TermResult' v a -> Pretty)	line:1107	language:Haskell
unsafeReadAndParseFile	./parser-typechecker/src/Unison/Parsers.hs	/^unsafeReadAndParseFile penv fileName = do$/;"	fi	line:73	language:Haskell
unsafeUnwrapType	./unison-core/src/Unison/DataDeclaration.hs	/^unsafeUnwrapType :: (Var v) => ABT.Term F v a -> Type v a$/;"	ft	signature:((Var v) => ABT.Term F v a -> Type v a)	line:325	language:Haskell
unsnoc	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unsnoc :: Path -> Maybe (Path, NameSegment)$/;"	ft	signature:(Path -> Maybe (Path, NameSegment))	line:264	language:Haskell
unsplit	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unsplit :: Split -> Path$/;"	ft	signature:(Split -> Path)	line:66	language:Haskell
unsplit'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unsplit' :: Split' -> Path'$/;"	ft	signature:(Split' -> Path')	line:62	language:Haskell
unsplitHQ	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unsplitHQ :: HQSplit -> HQ'.HashQualified' Path$/;"	ft	signature:(HQSplit -> HQ'.HashQualified' Path)	line:69	language:Haskell
unsplitHQ'	./parser-typechecker/src/Unison/Codebase/Path.hs	/^unsplitHQ' :: HQSplit' -> HQ'.HashQualified' Path'$/;"	ft	signature:(HQSplit' -> HQ'.HashQualified' Path')	line:72	language:Haskell
unsuffixifiedPPE	./parser-typechecker/src/Unison/PrettyPrintEnv.hs	/^  unsuffixifiedPPE :: PrettyPrintEnv,$/;"	c_a	cons:PrettyPrintEnvDecl.PrettyPrintEnvDecl	line:58	language:Haskell
untilFence	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^untilFence :: P Text$/;"	ft	signature:(P Text)	line:340	language:Haskell
untilJust	./parser-typechecker/src/Unison/Codebase/Watch.hs	/^untilJust :: Monad m => m (Maybe a) -> m a$/;"	ft	signature:(Monad m => m (Maybe a) -> m a)	line:41	language:Haskell
untilSpace1	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^untilSpace1 :: P Text$/;"	ft	signature:(P Text)	line:385	language:Haskell
unvar	./unison-core/src/Unison/ABT.hs	/^unvar :: V v -> v$/;"	ft	signature:(V v -> v)	line:49	language:Haskell
unzip	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^unzip :: (UV.Unbox a, UV.Unbox b)$/;"	ft	signature:((UV.Unbox a, UV.Unbox b) => SparseVector bits (a, b) -> (SparseVector bits a, SparseVector bits b))	line:78	language:Haskell
up	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^left,right,up :: Int -> TermAction$/;"	ft	signature:(Int -> TermAction)	line:206	language:Haskell
up	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^up = flip upA$/;"	fi	line:209	language:Haskell
upA	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^data Actions = Actions {leftA, rightA, upA :: Int -> TermOutput,$/;"	c_a	cons:Actions.Actions	line:35	language:Haskell
update	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^update :: InputPattern$/;"	ft	signature:(InputPattern)	line:179	language:Haskell
update	./yaks/haskeline/System/Console/Haskeline/Monads.hs	/^update :: MonadState s m => (s -> (a,s)) -> m a$/;"	ft	signature:(MonadState s m => (s -> (a, s)) -> m a)	line:61	language:Haskell
updateAtM	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^updateAtM :: Applicative m$/;"	ft	signature:(Applicative m => InputDescription -> Path.Absolute -> (Branch m -> Action m i v (Branch m)) -> Action m i v Bool)	line:1963	language:Haskell
updateBuiltins	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^updateBuiltins :: InputPattern$/;"	ft	signature:(InputPattern)	line:79	language:Haskell
updateCausalHead	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^updateCausalHead :: MonadIO m => FilePath -> Causal n h e -> m ()$/;"	ft	signature:(MonadIO m => FilePath -> Causal n h e -> m ())	line:377	language:Haskell
updateChildren	./parser-typechecker/src/Unison/Codebase/Branch.hs	/^updateChildren ::NameSegment$/;"	ft	signature:(NameSegment -> Branch m -> Map NameSegment (Branch m) -> Map NameSegment (Branch m))	line:689	language:Haskell
updateDependencies	./unison-core/src/Unison/DataDeclaration.hs	/^updateDependencies :: Ord v => Map Reference Reference -> Decl v a -> Decl v a$/;"	ft	signature:(Ord v => Map Reference Reference -> Decl v a -> Decl v a)	line:338	language:Haskell
updateDependencies	./unison-core/src/Unison/Term.hs	/^updateDependencies termUpdates typeUpdates = ABT.rebuildUp go$/;"	fi	line:886	language:Haskell
updateDependencies	./unison-core/src/Unison/Type.hs	/^updateDependencies :: Ord v => Map Reference Reference -> Type v a -> Type v a$/;"	ft	signature:(Ord v => Map Reference Reference -> Type v a -> Type v a)	line:393	language:Haskell
updateDom	./unison-core/src/Unison/Util/Relation.hs	/^updateDom :: (Ord a, Ord b) => (a -> a) -> b -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => (a -> a) -> b -> Relation a b -> Relation a b)	line:410	language:Haskell
updateRan	./unison-core/src/Unison/Util/Relation.hs	/^updateRan :: (Ord a, Ord b) => (b -> b) -> a -> Relation a b -> Relation a b$/;"	ft	signature:((Ord a, Ord b) => (b -> b) -> a -> Relation a b -> Relation a b)	line:414	language:Haskell
updateRoot	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^updateRoot :: Branch m -> Branch m -> InputDescription -> Action m i v ()$/;"	ft	signature:(Branch m -> Branch m -> InputDescription -> Action m i v ())	line:2020	language:Haskell
updateTerm	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^updateTerm :: (Reference -> Reference -> Typing)$/;"	ft	signature:((Reference -> Reference -> Typing) -> Reference -> TermEdit -> Patch -> Patch)	line:81	language:Haskell
updateType	./parser-typechecker/src/Unison/Codebase/Patch.hs	/^updateType :: Reference -> TypeEdit -> Patch -> Patch$/;"	ft	signature:(Reference -> TypeEdit -> Patch -> Patch)	line:98	language:Haskell
updatedPatches	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  updatedPatches    :: [PatchDisplay],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:55	language:Haskell
updatedTerms	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  updatedTerms      :: [UpdateTermDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:49	language:Haskell
updatedTypes	./parser-typechecker/src/Unison/Codebase/Editor/Output/BranchDiff.hs	/^  updatedTypes      :: [UpdateTypeDisplay v a],$/;"	c_a	cons:BranchDiffOutput.BranchDiffOutput	line:48	language:Haskell
updates	./parser-typechecker/src/Unison/Codebase/Editor/SlurpResult.hs	/^  , updates :: SlurpComponent v$/;"	c_a	cons:SlurpResult.SlurpResult	line:59	language:Haskell
url	./parser-typechecker/src/Unison/Codebase/Editor/RemoteRepo.hs	/^data RemoteRepo = GitRepo { url :: Text, commit :: Maybe Text }$/;"	c_a	cons:RemoteRepo.GitRepo	line:13	language:Haskell
usage	./parser-typechecker/unison/Main.hs	/^usage :: P.Pretty P.ColorText$/;"	ft	signature:(P.Pretty P.ColorText)	line:30	language:Haskell
usages	./parser-typechecker/src/Unison/TermPrinter.hs	/^    usages :: Map Suffix (Map Prefix Int)$/;"	c_a	cons:PrintAnnotation.PrintAnnotation	line:757	language:Haskell
useChar	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^useChar :: (Char -> Command m s t) -> KeyCommand m s t$/;"	ft	signature:((Char -> Command m s t) -> KeyCommand m s t)	line:94	language:Haskell
useCompletion	./yaks/haskeline/System/Console/Haskeline/Command/Completion.hs	/^useCompletion :: InsertMode -> Completion -> InsertMode$/;"	ft	signature:(InsertMode -> Completion -> InsertMode)	line:19	language:Haskell
useExamples	./parser-typechecker/src/Unison/PrintError.hs	/^useExamples :: Pretty ColorText$/;"	ft	signature:(Pretty ColorText)	line:1240	language:Haskell
useFile	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^useFile :: FilePath -> Behavior$/;"	ft	signature:(FilePath -> Behavior)	line:178	language:Haskell
useFileHandle	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^useFileHandle :: Handle -> Behavior$/;"	ft	signature:(Handle -> Behavior)	line:174	language:Haskell
useKey	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^useKey :: Key -> a -> KeyMap a$/;"	ft	signature:(Key -> a -> KeyMap a)	line:90	language:Haskell
useMovementsForKill	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^useMovementsForKill :: Command m s t -> (KillHelper -> Command m s t) -> KeyCommand m s t$/;"	ft	signature:(Command m s t -> (KillHelper -> Command m s t) -> KeyCommand m s t)	line:160	language:Haskell
usedVars	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^usedVars :: Ord v => Context v loc -> Set v$/;"	ft	signature:(Ord v => Context v loc -> Set v)	line:443	language:Haskell
userErrorId	./parser-typechecker/src/Unison/Runtime/IOSource.hs	/^userErrorId = mkErrorType "io.ErrorType.UserError"$/;"	fi	line:118	language:Haskell
usesEffects	./unison-core/src/Unison/Type.hs	/^usesEffects :: Ord v => Type v a -> Bool$/;"	ft	signature:(Ord v => Type v a -> Bool)	line:399	language:Haskell
using	./yaks/easytest/src/EasyTest.hs	/^using :: IO r -> (r -> IO ()) -> (r -> Test a) -> Test a$/;"	ft	signature:(IO r -> (r -> IO ()) -> (r -> Test a) -> Test a)	line:317	language:Haskell
utf8	./yaks/haskeline/tests/Unit.hs	/^utf8 :: T.Text -> B.ByteString$/;"	ft	signature:(T.Text -> B.ByteString)	line:289	language:Haskell
utf8Test	./yaks/haskeline/tests/Unit.hs	/^utf8Test = testI . setUTF8$/;"	fi	line:302	language:Haskell
utf8TestInvalidHist	./yaks/haskeline/tests/Unit.hs	/^utf8TestInvalidHist i input output = test $ do$/;"	fi	line:304	language:Haskell
utf8TestValidHist	./yaks/haskeline/tests/Unit.hs	/^utf8TestValidHist i input output = test $ do$/;"	fi	line:308	language:Haskell
v	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^pattern Universal v = Var (TypeVar.Universal v)$/;"	fi	line:94	language:Haskell
v'	./unison-core/src/Unison/Type.hs	/^v' :: Var v => Text -> Type v ()$/;"	ft	signature:(Var v => Text -> Type v ())	line:313	language:Haskell
validBase32HexChars	./unison-core/src/Unison/Hash.hs	/^validBase32HexChars :: Set Char$/;"	ft	signature:(Set Char)	line:63	language:Haskell
validHist	./yaks/haskeline/tests/Unit.hs	/^validHist = utf8 "abcÎ±"$/;"	fi	line:149	language:Haskell
validInputs	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^validInputs :: [InputPattern]$/;"	ft	signature:([InputPattern])	line:1142	language:Haskell
validate	./unison-core/src/Unison/Util/List.hs	/^validate :: (Semigroup e, Foldable f) => (a -> Either e b) -> f a -> Either e [b]$/;"	ft	signature:((Semigroup e, Foldable f) => (a -> Either e b) -> f a -> Either e [b])	line:39	language:Haskell
valueType	./parser-typechecker/src/Unison/TypeParser.hs	/^valueType :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:27	language:Haskell
valueTypeLeaf	./parser-typechecker/src/Unison/TypeParser.hs	/^valueTypeLeaf :: Var v => TypeP v$/;"	ft	signature:(Var v => TypeP v)	line:35	language:Haskell
var	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^var :: Var v => Name -> v$/;"	ft	signature:(Var v => Name -> v)	line:2082	language:Haskell
var	./parser-typechecker/src/Unison/TermParser.hs	/^var :: Var v => L.Token v -> Term v Ann$/;"	ft	signature:(Var v => L.Token v -> Term v Ann)	line:621	language:Haskell
var	./unison-core/src/Unison/ABT.hs	/^var :: v -> Term f v ()$/;"	ft	signature:(v -> Term f v ())	line:188	language:Haskell
var	./unison-core/src/Unison/Term.hs	/^var :: a -> v -> Term2 vt at ap v a$/;"	ft	signature:(a -> v -> Term2 vt at ap v a)	line:464	language:Haskell
var	./unison-core/src/Unison/Type.hs	/^var :: Ord v => a -> v -> Type v a$/;"	ft	signature:(Ord v => a -> v -> Type v a)	line:310	language:Haskell
var'	./unison-core/src/Unison/Term.hs	/^var' :: Var v => Text -> Term0' vt v$/;"	ft	signature:(Var v => Text -> Term0' vt v)	line:467	language:Haskell
varOf	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^varOf :: Element v loc -> v$/;"	ft	signature:(Element v loc -> v)	line:481	language:Haskell
variable	./unison-core/src/Unison/ABT.hs	/^        , variable :: v }$/;"	c_a	cons:Subst.Subst	line:460	language:Haskell
vector	./unison-core/src/Unison/Type.hs	/^vector :: Ord v => a -> Type v a$/;"	ft	signature:(Ord v => a -> Type v a)	line:246	language:Haskell
vectorBody	./parser-typechecker/src/Unison/Typechecker/TypeError.hs	/^vectorBody = existentialMismatch0 VectorBody (Ex.inSynthesizeApp >> Ex.inVector)$/;"	fi	line:235	language:Haskell
vectorConstructorOfArity	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^vectorConstructorOfArity :: (Var v, Ord loc) => loc -> Int -> M v loc (Type v loc)$/;"	ft	signature:((Var v, Ord loc) => loc -> Int -> M v loc (Type v loc))	line:781	language:Haskell
vectorRef	./unison-core/src/Unison/Type.hs	/^intRef, natRef, floatRef, booleanRef, textRef, charRef, vectorRef, bytesRef, effectRef, termLinkRef, typeLinkRef :: Reference$/;"	ft	signature:(Reference)	line:212	language:Haskell
vectorRef	./unison-core/src/Unison/Type.hs	/^vectorRef = Reference.Builtin "Sequence"$/;"	fi	line:219	language:Haskell
verifyClosed	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^verifyClosed :: (Traversable f, Ord v) => ABT.Term f v a -> (v -> v2) -> Result v2 a Bool$/;"	ft	signature:((Traversable f, Ord v) => ABT.Term f v a -> (v -> v2) -> Result v2 a Bool)	line:1672	language:Haskell
verifyClosedTerm	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^verifyClosedTerm :: forall v loc . Ord v => Term v loc -> Result v loc ()$/;"	ft	signature:(forall v loc . Ord v => Term v loc -> Result v loc ())	line:1663	language:Haskell
verifyClosedTermTest	./parser-typechecker/tests/Unison/Test/Typechecker/Context.hs	/^verifyClosedTermTest :: Test ()$/;"	ft	signature:(Test ())	line:22	language:Haskell
verifyDataDeclarations	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^verifyDataDeclarations :: (Var v, Ord loc) => DataDeclarations v loc -> Result v loc ()$/;"	ft	signature:((Var v, Ord loc) => DataDeclarations v loc -> Result v loc ())	line:1638	language:Haskell
verifyRelativeName	./parser-typechecker/src/Unison/TermParser.hs	/^verifyRelativeName :: Ord v => P v (L.Token Name) -> P v (L.Token Name)$/;"	ft	signature:(Ord v => P v (L.Token Name) -> P v (L.Token Name))	line:659	language:Haskell
verifyRelativeName'	./parser-typechecker/src/Unison/TermParser.hs	/^verifyRelativeName' :: Ord v => L.Token Name -> P v ()$/;"	ft	signature:(Ord v => L.Token Name -> P v ())	line:665	language:Haskell
verifyRelativeVarName	./parser-typechecker/src/Unison/TermParser.hs	/^verifyRelativeVarName :: Var v => P v (L.Token v) -> P v (L.Token v)$/;"	ft	signature:(Var v => P v (L.Token v) -> P v (L.Token v))	line:653	language:Haskell
viCommandActions	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^viCommandActions :: InputCmd CommandMode (Maybe String)$/;"	ft	signature:(InputCmd CommandMode (Maybe String))	line:84	language:Haskell
viCommands	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^viCommands :: InputCmd InsertMode (Maybe String)$/;"	ft	signature:(InputCmd InsertMode (Maybe String))	line:45	language:Haskell
viEnterSearch	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^viEnterSearch :: Monad m => Char -> Direction$/;"	ft	signature:(Monad m => Char -> Direction -> Command (ViT m) CommandMode CommandMode)	line:413	language:Haskell
viKeyCommands	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^viKeyCommands :: InputKeyCmd InsertMode (Maybe String)$/;"	ft	signature:(InputKeyCmd InsertMode (Maybe String))	line:36	language:Haskell
viSearchHist	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^viSearchHist :: forall m . Monad m$/;"	ft	signature:(forall m . Monad m => Direction -> [Grapheme] -> Command (ViT m) CommandMode CommandMode)	line:432	language:Haskell
view	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^view :: InputPattern$/;"	ft	signature:(InputPattern)	line:260	language:Haskell
viewByPrefix	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^viewByPrefix :: InputPattern$/;"	ft	signature:(InputPattern)	line:292	language:Haskell
viewPatch	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^viewPatch :: InputPattern$/;"	ft	signature:(InputPattern)	line:1020	language:Haskell
viewReflog	./parser-typechecker/src/Unison/CommandLine/InputPatterns.hs	/^viewReflog :: InputPattern$/;"	ft	signature:(InputPattern)	line:860	language:Haskell
virtualKeyCode	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^                          virtualKeyCode :: WORD,$/;"	c_a	cons:InputEvent.KeyEvent	line:121	language:Haskell
virtualScanCode	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^                          virtualScanCode :: WORD,$/;"	c_a	cons:InputEvent.KeyEvent	line:122	language:Haskell
visit	./unison-core/src/Unison/ABT.hs	/^visit f t = flip fromMaybe (f t) $ case out t of$/;"	fi	line:424	language:Haskell
visit'	./unison-core/src/Unison/ABT.hs	/^visit' :: (Traversable f, Applicative g, Monad g, Ord v)$/;"	ft	signature:((Traversable f, Applicative g, Monad g, Ord v) => (f (Term f v a) -> g (f (Term f v a))) -> Term f v a -> g (Term f v a))	line:431	language:Haskell
visitPure	./unison-core/src/Unison/ABT.hs	/^visitPure :: (Traversable f, Ord v)$/;"	ft	signature:((Traversable f, Ord v) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Term f v a)	line:442	language:Haskell
vmap	./unison-core/src/Unison/ABT.hs	/^vmap :: (Functor f, Foldable f, Ord v2) => (v -> v2) -> Term f v a -> Term f v2 a$/;"	ft	signature:((Functor f, Foldable f, Ord v2) => (v -> v2) -> Term f v a -> Term f v2 a)	line:138	language:Haskell
vmap	./unison-core/src/Unison/Paths.hs	/^vmap :: Ord v2 => (v -> v2) -> Target v -> Target v2$/;"	ft	signature:(Ord v2 => (v -> v2) -> Target v -> Target v2)	line:26	language:Haskell
vmap	./unison-core/src/Unison/Term.hs	/^vmap :: Ord v2 => (v -> v2) -> Term v a -> Term v2 a$/;"	ft	signature:(Ord v2 => (v -> v2) -> Term v a -> Term v2 a)	line:199	language:Haskell
vtmap	./unison-core/src/Unison/Term.hs	/^vtmap :: Ord vt2 => (vt -> vt2) -> Term' vt v a -> Term' vt2 v a$/;"	ft	signature:(Ord vt2 => (vt -> vt2) -> Term' vt v a -> Term' vt2 v a)	line:202	language:Haskell
warn	./parser-typechecker/src/Unison/CommandLine.hs	/^warn :: (ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s$/;"	ft	signature:((ListLike s Char, IsString s) => P.Pretty s -> P.Pretty s)	line:91	language:Haskell
warn	./parser-typechecker/src/Unison/Util/Logger.hs	/^error, warn, info, debug, trace :: Logger -> String -> IO ()$/;"	ft	signature:(Logger -> String -> IO ())	line:81	language:Haskell
warn	./parser-typechecker/src/Unison/Util/Logger.hs	/^warn l = logAt l warnLevel$/;"	fi	line:83	language:Haskell
warn'	./parser-typechecker/src/Unison/Util/Logger.hs	/^error', warn', info', debug', trace' :: Logger -> IO String -> IO ()$/;"	ft	signature:(Logger -> IO String -> IO ())	line:88	language:Haskell
warn'	./parser-typechecker/src/Unison/Util/Logger.hs	/^warn' l = logAt' l warnLevel$/;"	fi	line:90	language:Haskell
warnCallout	./parser-typechecker/src/Unison/Util/Pretty.hs	/^warnCallout = callout "â ï¸"$/;"	fi	line:771	language:Haskell
warnLevel	./parser-typechecker/src/Unison/Util/Logger.hs	/^errorLevel, warnLevel, infoLevel, debugLevel, traceLevel :: Level$/;"	ft	signature:(Level)	line:95	language:Haskell
warnNote	./parser-typechecker/src/Unison/CommandLine.hs	/^warnNote :: String -> String$/;"	ft	signature:(String -> String)	line:73	language:Haskell
watch	./parser-typechecker/src/Unison/TermParser.hs	/^watch :: Show a => String -> a -> a$/;"	ft	signature:(Show a => String -> a -> a)	line:50	language:Haskell
watch	./unison-core/src/Unison/Term.hs	/^watch :: (Var v, Semigroup a) => a -> String -> Term v a -> Term v a$/;"	ft	signature:((Var v, Semigroup a) => a -> String -> Term v a -> Term v a)	line:500	language:Haskell
watchBranchUpdates	./parser-typechecker/src/Unison/CommandLine.hs	/^watchBranchUpdates :: IO Branch.Hash -> TQueue Event -> Codebase IO v a -> IO (IO ())$/;"	ft	signature:(IO Branch.Hash -> TQueue Event -> Codebase IO v a -> IO (IO ()))	line:59	language:Haskell
watchComponents	./parser-typechecker/src/Unison/UnisonFile.hs	/^    watchComponents     :: [(WatchKind, [(v, Term v a, Type v a)])],$/;"	c_a	cons:TypecheckedUnisonFile.TypecheckedUnisonFile	line:85	language:Haskell
watchConfig	./parser-typechecker/src/Unison/CommandLine.hs	/^watchConfig :: FilePath -> IO (Config, IO ())$/;"	ft	signature:(FilePath -> IO (Config, IO ()))	line:46	language:Haskell
watchDirectory	./parser-typechecker/src/Unison/Codebase/Watch.hs	/^watchDirectory :: forall m. MonadUnliftIO m$/;"	ft	signature:(forall m. MonadUnliftIO m => FilePath -> (FilePath -> Bool) -> m (m (), m (FilePath, Text)))	line:87	language:Haskell
watchDirectory'	./parser-typechecker/src/Unison/Codebase/Watch.hs	/^watchDirectory' d = do$/;"	fi	line:46	language:Haskell
watchFileSystem	./parser-typechecker/src/Unison/CommandLine.hs	/^watchFileSystem :: TQueue Event -> FilePath -> IO (IO ())$/;"	ft	signature:(TQueue Event -> FilePath -> IO (IO ()))	line:51	language:Haskell
watchMaybe	./unison-core/src/Unison/Term.hs	/^watchMaybe :: (Var v, Semigroup a) => Maybe String -> Term v a -> Term v a$/;"	ft	signature:((Var v, Semigroup a) => Maybe String -> Term v a -> Term v a)	line:504	language:Haskell
watchPrinter	./parser-typechecker/src/Unison/CommandLine/OutputMessages.hs	/^watchPrinter src ppe ann kind term isHit =$/;"	fi	line:1708	language:Haskell
watched	./parser-typechecker/src/Unison/FileParser.hs	/^watched :: Var v => P v (UF.WatchKind, Text, Ann)$/;"	ft	signature:(Var v => P v (UF.WatchKind, Text, Ann))	line:128	language:Haskell
watches	./parser-typechecker/src/Unison/Codebase.hs	/^           , watches            :: UF.WatchKind -> m [Reference.Id]$/;"	c_a	cons:Codebase.Codebase	line:72	language:Haskell
watches	./parser-typechecker/src/Unison/UnisonFile.hs	/^  watches :: Map WatchKind [(v, Term v a)]$/;"	c_a	cons:UnisonFile.UnisonFile	line:45	language:Haskell
watchesDir	./parser-typechecker/src/Unison/Codebase/FileCodebase.hs	/^watchesDir :: CodebasePath -> Text -> FilePath$/;"	ft	signature:(CodebasePath -> Text -> FilePath)	line:205	language:Haskell
watchesOfKind	./parser-typechecker/src/Unison/UnisonFile.hs	/^watchesOfKind :: WatchKind -> UnisonFile v a -> [(v, Term v a)]$/;"	ft	signature:(WatchKind -> UnisonFile v a -> [(v, Term v a)])	line:48	language:Haskell
watchesOfOtherKinds	./parser-typechecker/src/Unison/UnisonFile.hs	/^watchesOfOtherKinds :: WatchKind -> UnisonFile v a -> [(v, Term v a)]$/;"	ft	signature:(WatchKind -> UnisonFile v a -> [(v, Term v a)])	line:51	language:Haskell
wcwidth	./yaks/haskeline/System/Console/Haskeline/Backend/WCWidth.hs	/^wcwidth :: Char -> Int$/;"	ft	signature:(Char -> Int)	line:18	language:Haskell
welcomeMessage	./parser-typechecker/src/Unison/CommandLine/Main.hs	/^welcomeMessage :: FilePath -> P.Pretty P.ColorText$/;"	ft	signature:(FilePath -> P.Pretty P.ColorText)	line:133	language:Haskell
wellTyped	./parser-typechecker/src/Unison/Typechecker.hs	/^wellTyped :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> f Bool$/;"	ft	signature:((Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> f Bool)	line:326	language:Haskell
wellformedType	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^wellformedType :: Var v => Context v loc -> Type v loc -> Bool$/;"	ft	signature:(Var v => Context v loc -> Type v loc -> Bool)	line:530	language:Haskell
whenLegacy	./yaks/haskeline/tests/Unit.hs	/^whenLegacy s = if legacyEncoding then s else B.empty$/;"	fi	line:36	language:Haskell
whenM	./unison-core/src/Unison/Util/Monoid.hs	/^whenM, unlessM :: Monoid a => Bool -> a -> a$/;"	ft	signature:(Monoid a => Bool -> a -> a)	line:17	language:Haskell
white	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
white	./parser-typechecker/src/Unison/Util/ColorText.hs	/^white = style White$/;"	fi	line:32	language:Haskell
white	./parser-typechecker/src/Unison/Util/Pretty.hs	/^white = map CT.white$/;"	fi	line:675	language:Haskell
win32Term	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^win32Term :: MaybeT IO RunTerm$/;"	ft	signature:(MaybeT IO RunTerm)	line:375	language:Haskell
win32TermStdin	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^win32TermStdin :: MaybeT IO RunTerm$/;"	ft	signature:(MaybeT IO RunTerm)	line:370	language:Haskell
win32WithEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^win32WithEvent :: MonadException m => Handles -> TChan Event$/;"	ft	signature:(MonadException m => Handles -> TChan Event -> (m Event -> m a) -> m a)	line:395	language:Haskell
withBehavior	./yaks/haskeline/System/Console/Haskeline/InputT.hs	/^withBehavior :: MonadException m => Behavior -> (RunTerm -> m a) -> m a$/;"	ft	signature:(MonadException m => Behavior -> (RunTerm -> m a) -> m a)	line:128	language:Haskell
withCodingMode	./yaks/haskeline/System/Console/Haskeline/Backend/Posix/Encoder.hs	/^withCodingMode :: ExternalHandle -> IO a -> IO a$/;"	ft	signature:(ExternalHandle -> IO a -> IO a)	line:44	language:Haskell
withCommandMode	./yaks/haskeline/System/Console/Haskeline/LineState.hs	/^withCommandMode :: (InsertMode -> InsertMode) -> CommandMode -> CommandMode$/;"	ft	signature:((InsertMode -> InsertMode) -> CommandMode -> CommandMode)	line:334	language:Haskell
withCtrlCHandler	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^withCtrlCHandler :: MonadException m => m a -> m a$/;"	ft	signature:(MonadException m => m a -> m a)	line:441	language:Haskell
withEffectDecl	./unison-core/src/Unison/DataDeclaration.hs	/^withEffectDecl f e = EffectDeclaration (f . toDataDecl $ e)$/;"	fi	line:247	language:Haskell
withEffectDeclM	./unison-core/src/Unison/DataDeclaration.hs	/^withEffectDeclM :: Functor f$/;"	ft	signature:(Functor f => (DataDeclaration' v a -> f (DataDeclaration' v' a')) -> EffectDeclaration' v a -> f (EffectDeclaration' v' a'))	line:249	language:Haskell
withEffects	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^withEffects :: [Type v loc] -> M v loc a -> M v loc a$/;"	ft	signature:([Type v loc] -> M v loc a -> M v loc a)	line:729	language:Haskell
withEffects0	./parser-typechecker/src/Unison/Typechecker/Context.hs	/^withEffects0 :: [Type v loc] -> M v loc a -> M v loc a$/;"	ft	signature:([Type v loc] -> M v loc a -> M v loc a)	line:734	language:Haskell
withGetEvent	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^    , withGetEvent :: forall m a . CommandMonad m => (m Event -> m a) -> m a$/;"	c_a	cons:TermOps.TermOps	line:44	language:Haskell
withHandleToHANDLE	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^withHandleToHANDLE :: Handle -> (HANDLE -> IO a) -> IO a$/;"	ft	signature:(Handle -> (HANDLE -> IO a) -> IO a)	line:147	language:Haskell
withHandler	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^withHandler :: MonadException m => Signal -> Handler -> m a -> m a$/;"	ft	signature:(MonadException m => Signal -> Handler -> m a -> m a)	line:223	language:Haskell
withInterrupt	./yaks/haskeline/System/Console/Haskeline.hs	/^withInterrupt :: MonadException m => InputT m a -> InputT m a$/;"	ft	signature:(MonadException m => InputT m a -> InputT m a)	line:314	language:Haskell
withPosixGetEvent	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^withPosixGetEvent :: (MonadException m, MonadReader Prefs m)$/;"	ft	signature:((MonadException m, MonadReader Prefs m) => TChan Event -> Handles -> [(String, Key)] -> (m Event -> m a) -> m a)	line:204	language:Haskell
withScreenBufferInfo	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^withScreenBufferInfo :: (Ptr () -> IO a) -> HANDLE -> IO a$/;"	ft	signature:((Ptr () -> IO a) -> HANDLE -> IO a)	line:195	language:Haskell
withSigIntHandler	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^withSigIntHandler :: MonadException m => m a -> m a$/;"	ft	signature:(MonadException m => m a -> m a)	line:216	language:Haskell
withStablePtr	./yaks/haskeline/System/Console/Haskeline/Backend/Win32/Echo.hs	/^withStablePtr :: a -> (StablePtr a -> IO b) -> IO b$/;"	ft	signature:(a -> (StablePtr a -> IO b) -> IO b)	line:169	language:Haskell
withSyntax	./parser-typechecker/src/Unison/Util/Pretty.hs	/^withSyntax :: ST.Element -> Pretty ST.SyntaxText -> Pretty ST.SyntaxText$/;"	ft	signature:(ST.Element -> Pretty ST.SyntaxText -> Pretty ST.SyntaxText)	line:248	language:Haskell
withWindowHandler	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^withWindowHandler :: MonadException m => TChan Event -> m a -> m a$/;"	ft	signature:(MonadException m => TChan Event -> m a -> m a)	line:212	language:Haskell
withWindowMode	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^withWindowMode :: MonadException m => Handles -> m a -> m a$/;"	ft	signature:(MonadException m => Handles -> m a -> m a)	line:243	language:Haskell
withoutConsuming	./yaks/haskeline/System/Console/Haskeline/Command.hs	/^withoutConsuming :: Command m s t -> KeyCommand m s t$/;"	ft	signature:(Command m s t -> KeyCommand m s t)	line:100	language:Haskell
withoutInputEcho	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            withoutInputEcho :: forall m a . MonadException m => m a -> m a,$/;"	c_a	cons:FileOps.FileOps	line:71	language:Haskell
word	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^word :: Text -> P Text$/;"	ft	signature:(Text -> P Text)	line:365	language:Haskell
word	./yaks/easytest/src/EasyTest.hs	/^word :: Test Word$/;"	ft	signature:(Test Word)	line:233	language:Haskell
word'	./parser-typechecker/src/Unison/Codebase/TranscriptParser.hs	/^word' :: Text -> P Text$/;"	ft	signature:(Text -> P Text)	line:359	language:Haskell
word'	./yaks/easytest/src/EasyTest.hs	/^word' :: Word -> Word -> Test Word$/;"	ft	signature:(Word -> Word -> Test Word)	line:253	language:Haskell
word8	./yaks/easytest/src/EasyTest.hs	/^word8 :: Test Word8$/;"	ft	signature:(Test Word8)	line:217	language:Haskell
word8'	./yaks/easytest/src/EasyTest.hs	/^word8' :: Word8 -> Word8 -> Test Word8$/;"	ft	signature:(Word8 -> Word8 -> Test Word8)	line:258	language:Haskell
wordErase	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^wordErase :: KillHelper$/;"	ft	signature:(KillHelper)	line:310	language:Haskell
wordLeft	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^wordRight, wordLeft, bigWordLeft :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:89	language:Haskell
wordLeft	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^wordLeft = goLeftUntil (atStart isAlphaNum)$/;"	fi	line:91	language:Haskell
wordRight	./yaks/haskeline/System/Console/Haskeline/Emacs.hs	/^wordRight, wordLeft, bigWordLeft :: InsertMode -> InsertMode$/;"	ft	signature:(InsertMode -> InsertMode)	line:89	language:Haskell
wordyDefinitionName	./parser-typechecker/src/Unison/Parser.hs	/^wordyDefinitionName :: Var v => P v (L.Token v)$/;"	ft	signature:(Var v => P v (L.Token v))	line:295	language:Haskell
wordyId	./parser-typechecker/src/Unison/Lexer.hs	/^wordyId :: String -> Either Err (String, String)$/;"	ft	signature:(String -> Either Err (String, String))	line:670	language:Haskell
wordyId'	./parser-typechecker/src/Unison/Lexer.hs	/^wordyId' :: String -> Either Err (String, String)$/;"	ft	signature:(String -> Either Err (String, String))	line:675	language:Haskell
wordyId0	./parser-typechecker/src/Unison/Lexer.hs	/^wordyId0 :: String -> Either Err (String, String)$/;"	ft	signature:(String -> Either Err (String, String))	line:636	language:Haskell
wordyIdChar	./parser-typechecker/src/Unison/Lexer.hs	/^wordyIdChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:646	language:Haskell
wordyIdStartChar	./parser-typechecker/src/Unison/Lexer.hs	/^wordyIdStartChar :: Char -> Bool$/;"	ft	signature:(Char -> Bool)	line:643	language:Haskell
wordyIdString	./parser-typechecker/src/Unison/Parser.hs	/^wordyIdString :: Ord v => P v (L.Token String)$/;"	ft	signature:(Ord v => P v (L.Token String))	line:302	language:Haskell
wordyNameSegment	./parser-typechecker/src/Unison/Codebase/Path.hs	/^wordyNameSegment, definitionNameSegment :: String -> Either String NameSegment$/;"	ft	signature:(String -> Either String NameSegment)	line:137	language:Haskell
wordyPatternName	./parser-typechecker/src/Unison/Parser.hs	/^wordyPatternName :: Var v => P v (L.Token v)$/;"	ft	signature:(Var v => P v (L.Token v))	line:284	language:Haskell
wrap	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrap :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s)	line:184	language:Haskell
wrap	./unison-core/src/Unison/ABT.hs	/^wrap :: (Functor f, Foldable f, Var v) => v -> Term f (V v) a -> (V v, Term f (V v) a)$/;"	ft	signature:((Functor f, Foldable f, Var v) => v -> Term f (V v) a -> (V v, Term f (V v) a))	line:84	language:Haskell
wrap	./yaks/easytest/src/EasyTest.hs	/^wrap :: Test a -> Test a$/;"	ft	signature:(Test a -> Test a)	line:301	language:Haskell
wrap	./yaks/haskeline/tests/Unit.hs	/^wrap :: B.ByteString$/;"	ft	signature:(B.ByteString)	line:283	language:Haskell
wrap'	./unison-core/src/Unison/ABT.hs	/^wrap' :: (Functor f, Foldable f, Var v)$/;"	ft	signature:((Functor f, Foldable f, Var v) => v -> Term f (V v) a -> (V v -> Term f (V v) a -> c) -> c)	line:90	language:Haskell
wrapColumn2	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrapColumn2 ::$/;"	ft	signature:((LL.ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> Pretty s)	line:526	language:Haskell
wrapFileInput	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            wrapFileInput :: forall a . IO a -> IO a,$/;"	c_a	cons:FileOps.FileOps	line:73	language:Haskell
wrapHandler	./parser-typechecker/src/Unison/Runtime/Rt1.hs	/^wrapHandler :: Value -> Req -> Req$/;"	ft	signature:(Value -> Req -> Req)	line:89	language:Haskell
wrapImpl	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrapImpl :: IsString s => [Pretty s] -> Pretty s$/;"	ft	signature:(IsString s => [Pretty s] -> Pretty s)	line:155	language:Haskell
wrapImplPreserveSpaces	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrapImplPreserveSpaces :: (LL.ListLike s Char, IsString s) => [Pretty s] -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => [Pretty s] -> Pretty s)	line:160	language:Haskell
wrapInterrupt	./yaks/haskeline/System/Console/Haskeline/Term.hs	/^            wrapInterrupt :: forall a . IO a -> IO a,$/;"	c_a	cons:RunTerm.RunTerm	line:37	language:Haskell
wrapKeypad	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^wrapKeypad :: MonadException m => Handle -> Terminal -> m a -> m a$/;"	ft	signature:(MonadException m => Handle -> Terminal -> m a -> m a)	line:140	language:Haskell
wrapLine	./yaks/haskeline/System/Console/Haskeline/Backend/Terminfo.hs	/^                        wrapLine :: TermOutput}$/;"	c_a	cons:Actions.Actions	line:40	language:Haskell
wrapPreserveSpaces	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrapPreserveSpaces :: (LL.ListLike s Char, IsString s) => Pretty s -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => Pretty s -> Pretty s)	line:203	language:Haskell
wrapString	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrapString :: (LL.ListLike s Char, IsString s) => String -> Pretty s$/;"	ft	signature:((LL.ListLike s Char, IsString s) => String -> Pretty s)	line:174	language:Haskell
wrapTerminalOps	./yaks/haskeline/System/Console/Haskeline/Backend/Posix.hsc	/^wrapTerminalOps :: MonadException m => Handles -> m a -> m a$/;"	ft	signature:(MonadException m => Handles -> m a -> m a)	line:339	language:Haskell
wrapV	./unison-core/src/Unison/Term.hs	/^wrapV :: Ord v => Term v a -> Term (ABT.V v) a$/;"	ft	signature:(Ord v => Term v a -> Term (ABT.V v) a)	line:281	language:Haskell
wrapV	./unison-core/src/Unison/Type.hs	/^wrapV :: Ord v => Type v a -> Type (ABT.V v) a$/;"	ft	signature:(Ord v => Type v a -> Type (ABT.V v) a)	line:61	language:Haskell
wrap_	./parser-typechecker/src/Unison/Util/Pretty.hs	/^wrap_ :: Seq (Pretty s) -> Pretty s$/;"	ft	signature:(Seq (Pretty s) -> Pretty s)	line:224	language:Haskell
writeConsole	./yaks/haskeline/System/Console/Haskeline/Backend/Win32.hsc	/^writeConsole :: HANDLE -> String -> IO ()$/;"	ft	signature:(HANDLE -> String -> IO ())	line:210	language:Haskell
writeHistory	./yaks/haskeline/System/Console/Haskeline/History.hs	/^writeHistory :: FilePath -> History -> IO ()$/;"	ft	signature:(FilePath -> History -> IO ())	line:70	language:Haskell
writeUTF8File	./yaks/haskeline/System/Console/Haskeline/History.hs	/^writeUTF8File :: FilePath -> String -> IO ()$/;"	ft	signature:(FilePath -> String -> IO ())	line:124	language:Haskell
writeUtf8	./unison-core/src/Unison/Prelude.hs	/^writeUtf8 :: FilePath -> Text -> IO ()$/;"	ft	signature:(FilePath -> Text -> IO ())	line:45	language:Haskell
x	./parser-typechecker/src/Unison/TermPrinter.hs	/^x |> f = f x$/;"	fi	line:856	language:Haskell
x	./parser-typechecker/tests/Unison/Test/Git.hs	/^x = 3$/;"	fi	line:47	language:Haskell
xa	./parser-typechecker/src/Unison/Typechecker/Extractor.hs	/^  xa >>= f = SubseqExtractor' $ \\note ->$/;"	fi	instance:Monad (SubseqExtractor' n)	line:321	language:Haskell
yankCommand	./yaks/haskeline/System/Console/Haskeline/Vi.hs	/^yankCommand :: InputCmd (ArgMode CommandMode) CommandMode$/;"	ft	signature:(InputCmd (ArgMode CommandMode) CommandMode)	line:234	language:Haskell
yellow	./parser-typechecker/src/Unison/Util/ColorText.hs	/^black, red, green, yellow, blue, purple, cyan, white, hiBlack, hiRed, hiGreen, hiYellow, hiBlue, hiPurple, hiCyan, hiWhite, bold, underline :: ColorText -> ColorText$/;"	ft	signature:(ColorText -> ColorText)	line:24	language:Haskell
yellow	./parser-typechecker/src/Unison/Util/ColorText.hs	/^yellow = style Yellow$/;"	fi	line:28	language:Haskell
yellow	./parser-typechecker/src/Unison/Util/Pretty.hs	/^yellow = map CT.yellow$/;"	fi	line:671	language:Haskell
yieldsError	./parser-typechecker/tests/Unison/Test/Typechecker/TypeError.hs	/^yieldsError :: forall v a. Var v => String -> ErrorExtractor v Ann a -> Bool$/;"	ft	signature:(forall v a. Var v => String -> ErrorExtractor v Ann a -> Bool)	line:53	language:Haskell
zeroOneOrMore	./parser-typechecker/src/Unison/Codebase/Editor/HandleInput.hs	/^zeroOneOrMore :: Foldable f => f a -> b -> (a -> b) -> (f a -> b) -> b$/;"	ft	signature:(Foldable f => f a -> b -> (a -> b) -> (f a -> b) -> b)	line:2028	language:Haskell
zipWith	./parser-typechecker/src/Unison/Runtime/SparseVector.hs	/^zipWith f a b =$/;"	fi	line:62	language:Haskell
