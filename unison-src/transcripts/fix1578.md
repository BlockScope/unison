
```ucm:hide
.> builtins.merge
```

```unison:hide
type Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat | Sun

foo.bar : Nat
foo.bar = 23
```

```ucm:hide
.> add
```

This should typecheck, using the local `bar`:

```unison
use Text ++

bar : Text
bar = "hello"

baz = bar ++ ", world!"
```

This should also typecheck, using the local `oog.bar`. This shows you can refer to a definition in the file by any suffix that is unique to definitions in the file (even if that suffix may match other definitions in the _codebase_). See below for overriding this behavior.

```unison
use Text ++

oog.bar = "hello"

baz = bar ++ ", world!"
```

This subtle test establishes that we aren't using type-directed name resolution (TDNR) for the local term references in the file. If this were using TDNR, it would fail with an ambiguity as there's nothing that pins down the expected type of `bar` here:

```unison
use Text ++

oog.bar = "hello"

baz = (bar, 42)
```

This should also typecheck, using the local `Sun`, and not `Day.Sun` which exists in the codebase.

```unison
type Zoot = Zonk | Sun

use Zoot Zonk

flip : Zoot -> Zoot
flip = cases
  Sun -> Zonk
  Zonk -> Sun
```

Even though local definitions are preferred, you can refer to definitions in the codebase via any unique suffix that doesn't also exist in the file.

```unison
type Zoot = Zonk | Sun

use Zoot Zonk

blah = cases
  Day.Sun -> Day.Tue
  day -> day

blah2 =
  use Day Sun
  cases Sun -> Wed
        day -> day
```
