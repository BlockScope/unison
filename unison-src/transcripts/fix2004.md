
```ucm:hide
.> builtins.merge
```

First, we create some common history before a fork:

```ucm
.a> alias.term .builtin.Nat.+ Nat.add
.a> alias.term .builtin.Nat.* Nat.times
.a> alias.term .builtin.Nat.drop Nat.subtract
.a> alias.type .builtin.Nat Nonneg
```

Now we fork `a2` off of `a`. `a` continues on, deleting the terms it added previously and then adding one unrelated term via a merge with little history.

```ucm
.> fork a a2
.a> delete.term Nat.add
.a> delete.term Nat.times
.a> delete.term Nat.subtract
.a> delete.type Nonneg
.newbranchA> alias.term .builtin.Float.+ addSomeFloats
.> merge newbranchA a
.a> find
```

Meanwhile, `a2` adds some other unrelated terms, some via merging in namespaces with little history. When merging `a2` back into `a`, the deletes from their common history should be respected.

```ucm
.a2> alias.term .builtin.Text.drop drop1
.a2> alias.term .builtin.Text.drop drop2
.a2> alias.term .builtin.Text.drop drop3
.a2> alias.term .builtin.Text.drop drop4
.a2> alias.term .builtin.Text.drop drop5
.newbranchA2> alias.term .builtin.Text.drop drop6
.> merge newbranchA2 a2
.a2> find
```

```ucm
.> fork a asquash
.> merge a2 a
.> squash a2 asquash
```

```ucm
.a> find
.asquash> find
```

```ucm:error
.> view a.Nonneg
```

```ucm:error
.> view asquash.Nat.add
```
