Previously, `alias.term` / `alias.type` would fail if the source argument was hash-only. Also, `replace.term` / `replace.type` only worked on full hashes.

With the PR, the source of an alias can be a shorthash, and the arguments to `replace.term` / `replace.type` can be hash-qualified or names-only.

Let's make some hash-only aliases, now that we can.

```ucm
.> alias.type ##Nat Cat

  Done.

.> alias.type ##Boolean Twoolean

  Done.

.> alias.term ##Nat.+ please_fix_763.+

  Done.

.> alias.term ##Universal.== please_fix_763.==

  Done.

```
And some functions that use them:
```unison
f = 3
g = 4
h = f + 1 == 5

> h
```

```ucm

  I found and typechecked these definitions in scratch.u. If you
  do an `add` or `update`, here's how your codebase would
  change:
  
    ⍟ These new definitions are ok to `add`:
    
      f : Cat
      g : Cat
      h : Twoolean
   
  Now evaluating any watch expressions (lines starting with
  `>`)... Ctrl+C cancels.

    5 | > h
          ⧩
          false

```
```ucm
.> add

  ⍟ I've added these definitions:
  
    f : Cat
    g : Cat
    h : Twoolean

```
We used to have to know the full hash for a definition to be able to use the `replace.*` commands, but now we don't:
```ucm
.> names g

  Term
  Hash:   #52addbrohu
  Names:  g

.> replace.term f g

  Done.

.> names g

  Term
  Hash:   #52addbrohu
  Names:  f g

.> view.patch

  Edited Terms: f#msp7bv40rv -> f

```
The value of `h` should have been updated too:
```unison
> h
```

```ucm

  ✅
  
  scratch.u changed.
   
  Now evaluating any watch expressions (lines starting with
  `>`)... Ctrl+C cancels.

    1 | > h
          ⧩
          true

```
