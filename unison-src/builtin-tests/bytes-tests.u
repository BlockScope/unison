bytes.tests = do
  !bytes.lit.tests
  !bytes.debug.tests
  !bytes.conversion.tests
  !bytes.eq.tests
  !bytes.ord.tests
  !bytes.ops.tests

bytes.lit.tests = do
  check "Bytes empty literal" do
    _ = 0xs
    true
  check "Bytes literal" do
    _ = 0xs68656c6c6f
    true

bytes.debug.tests = do
 checkEqual "Debug.toText on Bytes" (Debug.toText 0xs68656c6c6f) "0xs68656c6c6f"

bytes.conversion.tests = do
  use base Bytes.fromList Bytes.toList
  checkEqual "Bytes.fromList: empty" (Bytes.fromList []) Bytes.empty
  checkEqual "Bytes.fromList: non empty" (Bytes.fromList [104, 101, 108, 108, 111]) 0xs68656c6c6f
  check "Bytes.fromList: invalid" do
    match catch '(Bytes.fromList [104, 500]) with
      Left _ -> true
      Right _ -> false

  checkEqual "Bytes.toList: empty" (Bytes.toList Bytes.empty) []
  checkEqual "Bytes.toList: non empty" (Bytes.toList 0xs68656c6c6f) [104, 101, 108, 108, 111]

  check "fromUtf8: invalid" do
    match catch '(Text.fromUtf8 0xsfc80808080af) with
      Left _ -> true
      Right _ -> false

  checkEqual "fromUtf8" (Text.fromUtf8 0xs68656c6c6f) "hello"
  checkEqual "toUtf8" (Text.toUtf8 "hello") 0xs68656c6c6f

  loremIpsum = """
    In Unison, since definitions are identified by a content hash,
    arbitrary computations can just be moved from one location to
    another, with missing dependencies deployed on the fly.

    The basic protocol is something like: the sender ships the bytecode
    tree to the recipient, who inspects the bytecode for any hashes it's
    missing. If it already has all the hashes, it can run the
    computation; otherwise, it requests the ones it's missing and the
    sender syncs them on the fly. They'll be cached for next time.

    Of course, there's a lot of engineering that goes into making this
    work nicely, but the basic idea is simple and robust.

    This ability to relocate arbitrary computations subsumes the more
    limited notions of code deployment, remote procedure calls, and more,
    and lets us build powerful distributed computing components as
    ordinary Unison libraries.
   """
  checkEqual "ut8 roundTrip" (fromUtf8 (toUtf8 loremIpsum)) loremIpsum

bytes.eq.tests = do
  checkEqual "Bytes equality: empty" 0xs 0xs
  checkEqual "Bytes equality: non empty" 0xs0102 0xs0102
  check "Bytes inequality: non empty (1)" do 0xs0102 !== 0xs010203
  check "Bytes inequality: non empty (2)" do 0xs010203 !== 0xs0102
  check "Bytes inequality: non empty (3)" do 0xs0102 !== 0xs0103
  check "Bytes inequality: empty" do 0xs0102 !== 0xs
  checkEqual "Bytes equality: composite" (Some [0xs010203, 0xs040506]) (Some [0xs010203, 0xs040506])
  check "Bytes inequality: composite" do (Some [0xs010203, 0xs040506]) !== (Some [0xs010203, 0xs68656c6c6f])

bytes.ord.tests = do ()

bytes.ops.tests = do ()
