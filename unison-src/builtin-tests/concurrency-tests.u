concurrency.tests = Tests.main do
  !simpleRefTest
  !simpleRefTestScope
  !ticketTest
  !casTest
  -- !threadTest
  !promiseSequentialTest
  !promiseConcurrentTest
  !fullTest

simpleRefTest = do
  r = IO.ref 0
  Ref.write r 1
  i = Ref.read r
  Ref.write r 2
  j = Ref.read r
  Ref.write r 5
  checkEqual "Ref read-write"  (i, j, Ref.read r) (1, 2, 5)

simpleRefTestScope = do
  Scope.run do
    r = Scope.ref 0
    Ref.write r 1
    i = Ref.read r
    Ref.write r 2
    j = Ref.read r
    Ref.write r 5
    checkEqual "Ref read-write"  (i, j, Ref.read r) (1, 2, 5)

ticketTest = do
 r = IO.ref 3
 t = Ref.readForCas r
 v = Ticket.read t
 checkEqual "Ticket contains the Ref value" v 3

casTest = do
   ref = IO.ref 0
   ticket = Ref.readForCas ref
   v1 = Ref.cas ref ticket 5
   check "CAS is successful is there were no conflicting writes" 'v1
   Ref.write ref 10
   v2 = Ref.cas ref ticket 15
   check "CAS fails when there was an intervening write" '(not v2)

-- TODO try to access the failure details
threadTest = do
  millis = 1000
  thread ref =
    match catchAll do sleep (300 * millis) with
      Left _ -> Ref.write ref (Some "interrupted")
      Right _ -> Ref.write ref (Some "completed")
  ref1 = IO.ref None
  ref2 = IO.ref None
  t1 = fork do thread ref1
  t2 = fork do thread ref2
  sleep (200 * millis)
  kill t1
  sleep (200 * millis)
  kill t2
  r1 = while (Optional.isNone) do Ref.read ref1
  checkEqual "Thread has been interrupted" r1 (Some "interrupted")
  r2 = while (Optional.isNone) do Ref.read ref2
  checkEqual "Thread has completed" r2 (Some "completed")


promiseSequentialTest = do
  use Nat eq
  use Promise read write
  p = !Promise.new
  v0 = Promise.tryRead p
  checkEqual "Promise should be empty when created" v0 None
  Promise.write_ p 0
  v1 = read p
  checkEqual "Promise should read a value that's been written" v1 0
  Promise.write_ p 1
  v2 = read p
  checkEqual "Promise can only be written to once" v2 v1
  -- TODO fix bug in boot.ss here
  --  v3 = Promise.tryRead p
  --  checkEqual "Once the Promise is full, tryRead is the same as read" v3 (Some v2)

promiseConcurrentTest = do
  use Nat eq
  use concurrent fork
  millis = 1000
  p = !Promise.new
  _ = fork do
     unsafeRun! do sleep (200 * millis)
     Promise.write p 5
  v = Promise.read p
  checkEqual "Reads awaits for completion of the Promise" v 5

atomicUpdate : Ref {IO} a -> (a -> a) ->{IO} ()
atomicUpdate ref f =
  ticket = Ref.readForCas ref
  value = f (Ticket.read ticket)
  if Ref.cas ref ticket value then () else atomicUpdate ref f

spawnN : Nat -> '{IO} a ->{IO} [a]
spawnN n fa =
  use Nat eq -
  use concurrent fork
  
  go i acc =
    if eq i 0
    then acc
    else
      value = !Promise.new
      _ = fork do Promise.write value !fa
      go (i - 1) (acc :+ value)

  map Promise.read (go n [])

fullTest = do
  use Nat * + eq -
  
  numThreads = 100
  iterations = 100
  expected = numThreads * iterations

  state = IO.ref 0
  thread n =
    if eq n 0
    then ()
    else 
      atomicUpdate state (v -> v + 1)
      thread (n - 1)
  ignore (spawnN numThreads '(thread iterations))
  result = Ref.read state
  checkEqual "The state of the counter is consistent " result expected

