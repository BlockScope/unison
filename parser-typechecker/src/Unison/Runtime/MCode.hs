{-# language GADTs #-}
{-# language PatternGuards #-}
{-# language EmptyDataDecls #-}
{-# language PatternSynonyms #-}

module Unison.Runtime.MCode where

import Data.List (elemIndex)

import Data.Primitive.PrimArray

import Data.IntMap.Strict (IntMap)
import qualified Data.IntMap.Strict as IM

import Unison.Var (Var)
import Unison.ABT.Normalized (pattern TAbss)
import Unison.Runtime.ANF
  ( ANormal
  , ANormalT
  , ANormalTF(..)
  , Branched(..)
  , Handler(..)
  , Func(..)
  , pattern TVar
  , pattern TLit
  , pattern TApv
  , pattern TCom
  , pattern TCon
  , pattern TReq
  , pattern THnd
  , pattern TLet
  , pattern TName
  , pattern TTm
  , pattern TMatch
  )
import qualified Unison.Runtime.ANF as ANF

-- This outlines some of the ideas/features in this core
-- language, and how they may be used to implement features of
-- the surface language.

-----------------------
-- Delimited control --
-----------------------

-- There is native support for delimited control operations in
-- the core language. This means we can:
--   1. delimit a block of code with an integer tagged prompt,
--      which corresponds to pushing a frame onto the
--      continuation with said tag
--   2. capture a portion of the continuation up to a particular
--      tag frame and turn it into a value, which _removes_ the
--      tag frame from the continuation in the process
--   3. push such a captured value back onto the continuation

-- TBD: Since the captured continuations in _delimited_ control
-- are (in this case impure) functions, it may make sense to make
-- the representation of functions support these captured
-- continuations directly.

-- The obvious use case of this feature is effects and handlers.
-- Delimiting a block with a prompt is part of installing a
-- handler for said block at least naively. The other part is
-- establishing the code that should be executed for each
-- operation to be handled.

-- It's important (I believe) in #2 that the prompt be removed
-- from the continuation by a control effect. The captured
-- continuation not being automatically delimited corresponds to
-- a shallow handler's obligation to re-establish the handling of
-- a re-invoked computation if it wishes to do so. The delimiter
-- being removed from the capturing code's continuation
-- corresponds to a handler being allowed to yield effects from
-- the same siganture that it is handling.

-- In special cases, it should be possible to omit use of control
-- effects in handlers. At the least, if a handler case resumes
-- the computation in tail position, it should be unnecessary to
-- capture the continuation at all. If all cases act this way, we
-- don't need a delimiter, because we will never capture.

-- TBD: it may make more sense to have prompt pushing be part of
-- some other construct, due to A-normal forms of the code.

-----------------------------
-- Unboxed sum-of-products --
-----------------------------

-- It is not usually stated this way, but one of the core
-- features of the STG machine is that functions/closures can
-- return unboxed sum-of-products types. This is actually the way
-- _all_ data types work in STG. The discriminee of a case
-- statement must eventually return by pushing several values
-- onto the stack (the product part) and specifying which branch
-- to return to (the sum part).

-- The way heap allocated data is produced is that an
-- intermediate frame may be in the continuation that grabs this
-- information from the local storage and puts it into the heap.
-- If this frame were omitted, only the unboxed component would
-- be left. Also, in STG, the heap allocated data is just a means
-- of reconstructing its unboxed analogue. Evaluating a heap
-- allocated data type value just results in pushing its stored
-- fields back on the stack, and immediately returning the tag.

-- The portion of this with the heap allocation frame omitted
-- seems to be a natural match for the case analysis portion of
-- handlers. A naive implementation of an effect algebra is as
-- the data type of the polynomial functor generated by the
-- signature, and handling corresponds to case analysis. However,
-- in a real implementation, we don't want a heap allocated
-- representation of this algebra, because its purpose is control
-- flow. Each operation will be handled once as it occurs, and we
-- won't save work by remembering some reified representation of
-- which operations were used.

-- Since handlers in unison are written as functions, it seems to
-- make sense to define a calling convention for unboxed
-- sum-of-products as arguments. Variable numbers of stack
-- positions could be pushed for such arguments, with tags
-- specifying which case is being provided.

-- TBD: sum arguments to a function correspond to a product of
-- functions, so it's possible that the calling convention for
-- these functions should be similar to returning to a case,
-- where we push arguments and then select which of several
-- pieces of code to jump to. This view also seems relevant to
-- the optimized implementation of certain forms of handler,
-- where we want effects to just directly select some code to
-- execute based on state that has been threaded to that point.

-- One thing to note: it probably does not make sense to
-- completely divide returns into unboxed returns and allocation
-- frames. The reason this works in STG is laziness. Naming a
-- computation with `let` does not do any evaluation, but it does
-- allocate space for its (boxed) result. The only thing that
-- _does_ demand evaluation is case analysis. So, if a value with
-- sum type is being evaluated, we know it must be about to be
-- unpacked, and it makes little sense to pack it on the stack,
-- though we can build a closure version of it in the writeback
-- location established by `let`.

-- By contrast, in unison a `let` of a sum type evaluates it
-- immediately, even if no one is analyzing it. So we might waste
-- work rearranging the stack with the unpacked contents when we
-- only needed the closure version to begin with. Instead, we
-- gain the ability to make the unpacking operation use no stack,
-- because we know what we are unpacking must be a value. Turning
-- boxed function calls into unboxed versions thus seems like a
-- situational optimization, rather than a universal calling
-- convention.

-------------------------------
-- Delimited Dynamic Binding --
-------------------------------

-- There is a final component to the implementation of ability
-- handlers in this runtime system, and that is dynamically
-- scoped variables associated to each prompt. Each prompt
-- corresponds to an ability signature, and `reset` to a handler
-- for said signature, but we need storage space for the code
-- installed by said handler. It is possible to implement
-- dynamically scoped variables entirely with delimited
-- continuations, but it is more efficient to keep track of the
-- storage directly when manipulating the continuations.

-- The dynamic scoping---and how it interacts with
-- continuations---corresponds to the nested structure of
-- handlers. Installing a handler establishes a variable scope,
-- shadowing outer scopes for the same prompt. Shifting, however,
-- can exit these scopes dynamically. So, for instance, if we
-- have a structure like:

--    reset 0 $ ...
--      reset 1 $ ...
--        reset 0 $ ...
--          shift 1 <E>

-- We have nested scopes 0>1>0, with the second 0 shadowing the
-- first. However, when we shift to 1, the inner 0 scope is
-- captured into the continuation, and uses of the 0 ability in
-- <E> will be handled by the outer handler until it is shadowed
-- again (and the captured continuation will re-establish the
-- shadowing).

-- Mutation of the variables is possible, but mutation only
-- affects the current scope. Essentially, the dynamic scoping is
-- of mutable references, and when scope changes, we switch
-- between different references, and the mutation of each
-- reference does not affect the others. The purpose of the
-- mutation is to enable more efficient implementation of
-- certain recursive, 'deep' handlers, since those can operate
-- more like stateful code than control operators.

data Args'
  = Arg1 !Int
  | Arg2 !Int !Int
  -- frame index of each argument to the function
  | ArgN {-# unpack #-} !(PrimArray Int)
  | ArgR !Int !Int

data Args
  = ZArgs
  | UArg1 !Int
  | UArg2 !Int !Int
  | BArg1 !Int
  | BArg2 !Int !Int
  | DArg2 !Int !Int
  | UArgR !Int !Int
  | BArgR !Int !Int
  | DArgR !Int !Int !Int !Int
  | BArgN !(PrimArray Int)

ucount, bcount :: Args -> Int

ucount (UArg1 _) = 1
ucount (UArg2 _ _) = 2
ucount (DArg2 _ _) = 1
ucount (UArgR _ l) = l
ucount (DArgR _ l _ _) = l
ucount _ = 0
{-# inline ucount #-}

bcount (BArg1 _) = 1
bcount (BArg2 _ _) = 2
bcount (DArg2 _ _) = 1
bcount (BArgR _ l) = l
bcount (DArgR _ _ _ l) = l
bcount _ = 0
{-# inline bcount #-}

data Prim1 = Dec | Inc
data Prim2 = Add | Sub

-- Instructions for manipulating the data stack in the main portion of
-- a block
data Instr
  -- 1-argument primitive operations
  = Prim1 !Prim1 -- primitive instruction
          !Int   -- index of prim argument

  -- 2-argument primitive operations
  | Prim2 !Prim2 -- primitive instruction
          !Int   -- index of first prim argument
          !Int   -- index of second prim argument

  -- Set the value of a dynamic reference
  | SetDyn !Int -- the prompt tag of the reference
           !Int -- the stack index of the closure to store

  -- Capture the continuation up to a given marker.
  | Capture !Int -- the prompt tag

  -- This is essentially the opposite of `Call`. Pack a given
  -- statically known function into a closure with arguments.
  -- No stack is necessary, because no nested evaluation happens,
  -- so the instruction directly takes a follow-up.
  | Name !Int Args

  -- Dump some debugging information about the machine state to
  -- the screen.
  | Info !String -- prefix for output

  -- Pack a data type value into a closure and place it
  -- on the stack.
  | Pack !Int  -- tag
         !Args -- arguments to pack

  -- Unpack the contents of a data type onto the stack
  | Unpack !Int -- stack index of data to unpack

  -- Push a particular value onto the unboxed stack
  | Lit !Int -- value to push onto the stack

  -- Print a value on the unboxed stack
  | Print !Int -- index of the primitive value to print

  -- Put a delimiter on the continuation
  | Reset !Int -- prompt id

data Section
  -- Apply a function to arguments. This is the 'slow path', and
  -- handles applying functions from arbitrary sources. This
  -- requires checks to determine what exactly should happen.
  = App
      !Bool -- skip argument check for known calling convention
      !Ref  -- function to call
      !Args -- arguments

  -- This is the 'fast path', for when we statically know we're
  -- making an exactly saturated call to a statically known
  -- function. This allows skipping various checks that can cost
  -- time in very tight loops. This also allows skipping the
  -- stack check if we know that the current stack allowance is
  -- sufficient for where we're jumping to.
  | Call
      !Bool -- skip stack check
      !Int  -- global function reference
      !Args -- arguments

  -- Jump to a captured continuation value.
  | Jump
      !Int  -- index of captured continuation
      !Args -- arguments to send to continuation

  -- Branch on the value in the unboxed data stack
  | Match !Int    -- index of unboxed item to match on
          !Branch -- branches
  -- Yield control to the current continuation, with arguments
  | Yield !Args -- values to yield

  -- Prefix an instruction onto a section
  | Ins !Instr !Section

  -- Sequence two sections. The second is pushed as a return
  -- point for the results of the first. Stack modifications in
  -- the first are lost on return to the second.
  | Let !Section !Section

data Comb
  = Lam !Int -- Number of unboxed arguments
        !Int -- Number of boxed arguments
        !Int -- Maximum needed unboxed frame size
        !Int -- Maximum needed boxed frame size
        !Section -- Code

data Ref
  = Stk !Int -- stack reference to a closure
  | Env !Int -- global environment reference to a combinator
  | Dyn !Int -- dynamic scope reference to a closure

data Branch
  -- if tag == n then t else f
  = Test1 !Int
          !Section
          !Section
  | Test2 !Int !Section    -- if tag == m then ...
          !Int !Section    -- else if tag == n then ...
          !Section         -- else ...
  | TestT (IntMap Section)

type Ctx v = [Maybe v]

ctxResolve :: Var v => Ctx v -> v -> Int
ctxResolve ctx u
  | Just i <- elemIndex (Just u) ctx = i
  | otherwise = error $ "ctxResolve: bad variable scoping: " ++ show u

emitSection :: Var v => Ctx v -> ANormal v -> Section
emitSection ctx (TLet u bu bo)
  = emitLet ctx bu $ emitSection (Just u : ctx) bo
emitSection ctx (TName u f as bo)
  = Ins (Name f $ emitArgs ctx as) $ emitSection (Just u : ctx) bo
emitSection ctx (TVar v) = Yield . BArg1 $ ctxResolve ctx v
emitSection ctx (TApv v args)
  = App False (Stk $ ctxResolve ctx v) $ emitArgs ctx args
emitSection ctx (TCom n args)
  | False -- known saturated call
  = Call False n $ emitArgs ctx args
  | False -- known unsaturated call
  = Ins (Name n $ emitArgs ctx args) $ Yield (BArg1 0)
  | otherwise -- slow path
  = App False (Env n) $ emitArgs ctx args
emitSection ctx (TCon _ t args)
  = Ins (Pack t (emitArgs ctx args))
  . Yield $ BArg1 0
emitSection ctx (TReq a e args)
  -- Currently implementing packed calling convention for abilities
  = Ins (Pack e (emitArgs ctx args))
  . App True (Dyn a) $ BArg1 0
emitSection _   (TLit l)
  = Ins (emitLit l)
  . Ins (Pack 0 $ UArg1 0)
  . Yield $ BArg1 0
-- Currently implementing boxed integer matching
emitSection ctx (TMatch v cs)
  = Ins (Unpack $ ctxResolve ctx v)
  $ Match i $ emitBranches [Nothing] ctx cs
  where i | MatchIntegral _ <- cs = 1
          | otherwise = 0
emitSection ctx (THnd cs b)
  = emitHandler ctx cs $ emitSection ctx b
emitSection _ _ = error "emitSection: unhandled code"

emitLet :: Var v => Ctx v -> ANormalT v -> Section -> Section
-- Currently packed literals
emitLet _   (ALit l)
  = Ins (emitLit l)
  . Ins (Pack 0 $ UArg1 0)
emitLet ctx (AApp (FComb n) args)
  -- We should be able to tell if we are making a saturated call
  -- or not here. We aren't carrying the information here yet, though.
  | False -- not saturated
  = Ins . Name n $ emitArgs ctx args
emitLet ctx (AApp (FCon _ n) args) -- TODO: use reference number
  = Ins . Pack n $ emitArgs ctx args
emitLet ctx (AApp (FPrim p) args)
  = Ins . emitPOp p $ emitArgs ctx args
emitLet ctx bnd = Let (emitSection ctx (TTm bnd))

emitPOp :: ANF.POp -> Args -> Instr
emitPOp ANF.PADI = emitP2 Add
emitPOp ANF.PADN = emitP2 Add
emitPOp ANF.PSUI = emitP2 Sub
emitPOp ANF.PSUN = emitP2 Sub
emitPOp p = error $ "unhandled prim op: " ++ show p

emitP2 :: Prim2 -> Args -> Instr
emitP2 p (UArg2 i j) = Prim2 p i j
emitP2 _ _ = error "prim ops must be saturated"

emitBranches :: Var v => Ctx v -> Ctx v -> Branched (ANormal v) -> Branch
emitBranches tctx ctx bs
  = TestT $ IM.map (emitCase tctx ctx) $ cases bs

emitHandler
  :: Var v => Ctx v -> Handler (ANormal v) -> Section -> Section
emitHandler _   (Hndl _  _ ) _
  = error "TODO: handler"

emitCase :: Var v => Ctx v -> Ctx v -> ANormal v -> Section
emitCase tctx ctx (TAbss vs bo)
  = emitSection (tctx ++ fmap Just vs ++ ctx) bo

emitLit :: ANF.Lit -> Instr
emitLit l = Lit i
  where
  i = case l of
        ANF.I i -> fromIntegral i
        ANF.N n -> fromIntegral n
        _ -> error "unhandled literal"

emitArgs :: Var v => Ctx v -> [v] -> Args
emitArgs ctx args = case map (ctxResolve ctx) args of
  [] -> ZArgs
  [i] -> BArg1 i
  [i,j] -> BArg2 i j
  is -> BArgN $ primArrayFromList is
